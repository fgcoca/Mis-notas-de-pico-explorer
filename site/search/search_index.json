{"config":{"lang":["es"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introducci\u00f3n","text":"<p>La placa Pico Explorer es una placa de expansi\u00f3n para la Raspberry Pi Pico o Pico W fabricada por Pimoroni, dise\u00f1ada para el aprendizaje de circuitos b\u00e1sicos de electr\u00f3nica mediante la realizaci\u00f3n de experimentos reales. La placa incluye componentes funcionales como una mini protoboard, controladores de motor, un altavoz, una pantalla con cuatro botones utilizables y conectores de Breakout Garden para m\u00f3dulos de expansi\u00f3n. En la imagen siguiente vemos su aspecto.</p> <p> <p> Aspecto de la placa Pico Explorer</p> <p></p>"},{"location":"#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>Altavoz piezoel\u00e9ctrico</li> <li>Pantalla LCD IPS de 1,54\" (240 x 240px)</li> <li>Cuatro pulsadores controlables por el usuario</li> <li>Dos controladores de motor puente en H (con LED indicador de sobrecorriente)</li> <li>Conectores de pines GPIO y ADC de f\u00e1cil acceso</li> <li>Dos enchufes I2C Breakout Garden</li> <li>Mini placa protoboard de pruebas</li> <li>Patitas adhesivas de silicona</li> <li>Compatible con Raspberry Pi Pico/Pico W</li> <li>No se requiere soldadura (siempre que la Pico tenga las tiras de pines soldados).</li> <li>Dimensiones: aproximadas 117 mm x 63 mm x 20 mm (largo x ancho x alto)</li> <li>Requiere de Bibliotecas C/C++ y MicroPython</li> <li>Esquem\u00e1tico</li> </ul>"},{"location":"#pinouts","title":"Pinouts","text":""},{"location":"#raspberry-pi-pico","title":"Raspberry Pi Pico","text":"<p> <p> Distribuci\u00f3n de pines en la Pi Pico</p> <p></p>"},{"location":"#raspberry-pi-pico-w","title":"Raspberry Pi Pico W","text":"<p> <p> Distribuci\u00f3n de pines en la Pi Pico W</p> <p></p>"},{"location":"#placa-pico-explorer","title":"Placa Pico Explorer","text":"<p> <p> Distribuci\u00f3n de pines en la Pico Explorer</p> <p></p>"},{"location":"#pinout-desde-la-linea-de-comandos","title":"Pinout desde la l\u00ednea de comandos","text":"<p>Voy a exponer a t\u00edtulo de curiosidad el trabajo visto en el blog original no oficial de Raspberry Pi de Matt Hawkins donde podemos encontrar un script .sh que no dibuja el pinout de la Pi Pico en una ventana de terminal cuando lo invocamos. La web es muy recomendable por la cantidad de informaci\u00f3n y ejemplos que desarrolla con la Pi Pico.</p> <p>El script lo podemos descargar desde:</p> <ul> <li>wget https://raw.githubusercontent.com/RPiSpy/pi-pico/main/picopins.sh</li> <li>git clone https://github.com/RPiSpy/pi-pico.git</li> <li>Este enlace</li> </ul> <p>Una vez descargado nos dirigimos al directorio donde est\u00e1 el archivo y hacemos que el script sea ejecutable mediante <code>chmod +x piconpins.sh</code>.</p> <p>Ya podemos ejecutar el script tecleando en la l\u00ednea de comandos <code>./piconpins.sh</code> o <code>sh piconpins.sh</code> para obtener el siguiente resultado:</p> <p> <p> Pinout de la Pi Pico desde la l\u00ednea de comandos</p> <p></p> <p>Si queremos tener disponible el script lo podemos llevar al directorio de sistema /bin. En mi caso le voy a cambiar el nombre a pinoutpico haciendo <code>sudo cp picopins.sh /bin/pinoutpico</code>. El nuevo fichero tambi\u00e9n debe tener permiso de ejecuci\u00f3n, por lo que debemos dirigirnos al directorio /bin y en una terminal teclear <code>sudo chmod +x pinoutpico</code>. Ahora ya podemos invocar <code>pinoutpico</code> desde cualquier directorio siempre que lo necesitemos.</p>"},{"location":"Miscelanea/about/","title":"Autor","text":"<p>Federico Coca</p> <ul> <li> <p>GitHub</p> </li> <li> <p>Twitter</p> </li> <li> <p>Instagram</p> </li> <li> <p>Mas informaci\u00f3n</p> </li> <li> <p>En octubre de 2024 he puesto mi nombre para que viaje en la sonda Europa Clipper a estudiar el sat\u00e9lite Europa mientras gira alrededor del planeta J\u00fapiter. La operaci\u00f3n de la NASA se denomina Message in a bottle teniendo prevista su llegada en el 2030 tras recorrer 2900 millones de kil\u00f3metros (1800 millones de millas). El nombre viaja como firma de un poema escrito por Ada Lim\u00f3n, poetisa laureada estadounidense de ascendencia mexicana. En las im\u00e1genes siguientes vemos un captura del poema y el mensaje en la botella.</p> </li> </ul> <p> <p></p> <p></p>"},{"location":"Miscelanea/lic/","title":"Licencias","text":"<ul> <li> <p>Licencia MIT incluida en la creaci\u00f3n del repositorio.</p> </li> <li> <p>Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0 </p> </li> </ul> <p> <p> </p> <p></p>"},{"location":"Miscelanea/soft/","title":"Software utilizado","text":"<ul> <li> <p>Sistema operativo: Ubuntu Ubuntu 22.04.3 LTS  (Jammy Jellyfish)</p> </li> <li> <p>Paquete ofim\u00e1tico de referencia: LibreOffice</p> </li> <li> <p>Libreria Material para MkDocs</p> </li> <li> <p>Visual Studio Code</p> </li> <li> <p>plantilla-taller</p> </li> <li> <p>Creaci\u00f3n de GIF animados para Ubuntu Peek</p> </li> <li> <p>Sistema principal de capturas de pantalla: Shutter</p> </li> <li> <p>Dibujo 2D vectorial Inkscape</p> </li> <li> <p>Retoque de im\u00e1genes GIMP</p> </li> <li> <p>Generador de tablas para Markdown Tables Generator</p> </li> <li> <p>Editor de Python Thonny</p> </li> </ul>"},{"location":"Miscelanea/webgrafia/","title":"Webgraf\u00eda y bibliograf\u00eda","text":"<ul> <li> <p>Wikipedia</p> </li> <li> <p>Pimoroni</p> </li> <li> <p>Repositorio en Github Pimoroni Pico</p> </li> <li> <p>plantilla-taller desarrollada por Cristobal Contreras para La Jaquer\u00eda</p> </li> <li> <p>Hoja de datos de Pico: Datasheet de Pico</p> </li> <li> <p>Freenove Ultimate Starter Kit for Raspberry Pi</p> </li> <li> <p>El Libro De Python</p> </li> <li> <p>Guia oficial de Raspberry Pi Pico: Get started with MicroPython on Raspberry Pi Pico</p> </li> <li> <p>El libro de Python</p> </li> <li> <p>Tutorial de Python de The Data Schools</p> </li> <li> <p>Raspberry Pi Pico Python SDK</p> </li> <li> <p>Blog original no oficial de Raspberry Pi</p> </li> <li> <p>Documentaci\u00f3n de Raspberry Pi</p> </li> </ul>"},{"location":"actividades/A01/","title":"A01.Parpadeo LED onboard","text":"<p>Esta actividad marca el punto de partida en la construcci\u00f3n y exploraci\u00f3n de proyectos electr\u00f3nicos con Raspberry Pi Pico.</p> <p>Utilizaremos esta actividad para introducir conocimientos referentes a la carga de programas en la Pi Pico, como se importan archivos Python y por supuesto veremos los conocimientos de Python necesarios para un mejor entendimiento de la misma.</p>"},{"location":"actividades/A01/#enunciado","title":"Enunciado","text":"<p>Se trata de hacer parpadear el LED que incorpora la placa Pi Pico pr\u00f3ximo al conector USB que est\u00e1 conectado a GP25.</p>"},{"location":"actividades/A01/#lista-de-componentes","title":"Lista de componentes","text":"<ul> <li> - Placa pico explorer con Pi Pico</li> <li> - 1 Cable USB A a USB micro que utilizaremos para programar y alimentar la Pi Pico</li> </ul>"},{"location":"actividades/A01/#esquema-del-circuito","title":"Esquema del circuito","text":"<p>Es tan simple como conectar la Pi Pico al ordenador mediante el cable USB.</p> <p> <p> </p> <p></p>"},{"location":"actividades/A01/#programa","title":"Programa","text":""},{"location":"actividades/A01/#codigo","title":"C\u00f3digo","text":"<p>El c\u00f3digo de la actividad es el siguiente:</p> <pre><code>from machine import Pin\nimport time\n\n# Comentar una de las lineas y descomentar la otra segun version de Pico\n\n# led = Pin(25, Pin.OUT)   # LED en la Pi Pico\nled = Pin(\"LED\", Pin.OUT) # LED en la Pi Pico\n\ntry:\n    while True:\n        led.value(1)    # Enciende el LED\n        time.sleep(0.5) # Espera medio segundo\n        led.value(0)    # Apaga el LED\n        time.sleep(0.5) # Espera medio segundo\nexcept:\n    pass\n</code></pre> <p>Copiamos el c\u00f3digo anterior en Thonny sin preocuparnos demasiado por entenderlo en este momento. Antes de continuar lo primero que haremos es guardar el proyecto en nuestro caso le ponemos como nombre el n\u00famero de actividad y lo guardamos en un directorio con el mismo nombre.</p> <p> <p> A01_archivo_y_carpeta_guardados</p> <p></p> <p>Lo que vamos a hacer ahora es, con un c\u00f3digo v\u00e1lido y que realiza una tarea, entender como se ejecuta y como se carga en la Pi Pico. Nos dirigimos al enlace siguiente para ver esto:</p> <p>Firmware y software -&gt; Software Thonny -&gt; Ejecutando c\u00f3digo</p> <p>El programa lo podemos descargar de:</p> <ul> <li>A01_parpadeo LED onboard</li> </ul>"},{"location":"actividades/A01/#explicacion","title":"Explicaci\u00f3n","text":"<p>El programa de la imagen siguiente se ejecutar\u00e1 de arriba a abajo l\u00ednea a l\u00ednea. Cuando se encuentra un bucle ejecutar\u00e1 la sentencia del mismo seg\u00fan su condici\u00f3n.</p> <p> <p> A01_programa</p> <p></p> <p>Para trabajar con la Pi Pico necesitamos importar los m\u00f3dulos correspondientes a las funciones que vamos a emplear, en nuestro caso:</p> <pre><code>from machine import Pin\nimport time\n</code></pre> <p>A continuaci\u00f3n configuramos la patilla GPIO a la que est\u00e1 conectado el LED onboard como salida realizamos una asignaci\u00f3n a <code>led</code>. Se trata del pin GP25, que en la Pi Pico W se llama como objeto \"LED\" mientras que en la Pi Pico se llama por el n\u00famero de pin al que est\u00e1 conectado, el 25 en este caso.</p> <pre><code># led = Pin(25, Pin.OUT)\nled = Pin(\"LED\", Pin.OUT)\n</code></pre> <p>Esto significa que a partir de ahora, el LED que representa a GP25 est\u00e1 en modo de salida.</p> <p>Procedemos a poner a 1 <code>led</code> y el pin GP25 pasar\u00e1 a estar a nivel alto, encendiendo el LED.</p> <pre><code>led.value(1)\n</code></pre> <p>Para apagar el LED basta con poner un estado bajo en GP25:</p> <pre><code>led.value(0)\n</code></pre> <p>Entre encendido y apagado establecemos un tiempo de espera:</p> <pre><code>time.sleep(0.5)\n</code></pre> <p>El c\u00f3digo se ejecuta dentro de un bucle while:</p> <pre><code>while True:\n        led.value(1)\n        time.sleep(0.5)\n        led.value(0)\n        time.sleep(0.5\n</code></pre> <p>Este bucle es infinito puesto que la condici\u00f3n <code>True</code> no se cambia y siempre es cierta. </p> <p>Siempre es conveniente poner las instrucciones que pueden causar errores dentro de un bloque <code>try:</code> y las sentencias a ejecutar en caso de error en un bloque <code>except:</code>. En el programa normalmente se ejecutan las sentencias del bloque <code>try:</code>. Cuando se produce un error en la Raspberry Pi Pico se ejecutar\u00e1n las del bloque <code>except</code>. En este caso en <code>except</code> se pone la sentencia <code>pass</code>, que no hace nada, est\u00e1ndo su utilidad en marcar de forma completa la estructura del c\u00f3digo.</p> <pre><code>try:\n    while True:\n    ...\nexcept:\n    pass\n</code></pre> <p>MicroPython utiliza sangr\u00edas para distinguir diferentes bloques de c\u00f3digo. El n\u00famero de sangr\u00edas es modificable, pero debe ser consistente a lo largo de un bloque. Si la sangr\u00eda del mismo bloque de c\u00f3digo es inconsistente, causar\u00e1 errores cuando se ejecute el programa.</p>"},{"location":"actividades/A02/","title":"A02.Parpedeo LED externo","text":"<p>Contenidos de electr\u00f3nica b\u00e1sica que se aconseja repasar:</p> <ul> <li>Cables Dupont</li> <li>Protoboard</li> <li>Resistencias fijas</li> <li>Diodo LED</li> </ul>"},{"location":"actividades/A02/#enunciado","title":"Enunciado","text":"<p>En esta actividad haremos parpadear a un LED montado en la placa protoboard de la pico explorer junto con su resistencia de protecci\u00f3n.</p>"},{"location":"actividades/A02/#lista-de-componentes","title":"Lista de componentes","text":"<ul> <li> - Placa pico explorer con Pi Pico</li> <li> - 1 Cable USB A a USB micro que utilizaremos para programar y alimentar la Pi Pico</li> <li> - 1 Diodo LED</li> <li> - 1 Resistencia de 220R</li> <li> - Cables dupont</li> </ul>"},{"location":"actividades/A02/#esquema-del-circuito","title":"Esquema del circuito","text":"<p>El circuito que vamos a montar es el siguiente:</p> <p> <p> </p> <p></p> <p>La resistencia serie se puede omitir dado que Pico Explorer ya incluye una de 100 ohmios.</p>"},{"location":"actividades/A02/#programa","title":"Programa","text":"<p>El c\u00f3digo del programa es:</p> <pre><code>from machine import Pin\nimport time\nprint(machine.freq())\n\nled_externo = Pin(5, Pin.OUT) # pin 5 como salida\n\ntry:\n    while True:\n        led_externo.value(1)    # Enciende el LED\n        time.sleep(0.5) # Espera medio segundo\n        led_externo.value(0)    # Apaga el LED\n        time.sleep(0.5) # Espera medio segundo\nexcept:\n    pass\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A02_parpadeo_LED_externo</li> </ul>"},{"location":"actividades/A03/","title":"A03. Pulsador y LED","text":"<p>La actividad est\u00e1 pensada para aprender a controlar un LED con un pulsador. Lo primero que deberemos hacer es leer el estado del pulsador para despu\u00e9s decidir si el LED se enciende o no bas\u00e1ndonos en esa lectura.</p> <p>Contenidos de electr\u00f3nica b\u00e1sica que se aconseja repasar:</p> <ul> <li>Cables Dupont</li> <li>Protoboard</li> <li>Resistencias fijas</li> <li>Diodo LED</li> <li>Pulsador</li> <li>Rebotes</li> </ul>"},{"location":"actividades/A03/#enunciado","title":"Enunciado","text":"<p>En esta actividad vamos a controlar el estado de un diodo LED mediante un bot\u00f3n pulsador. Cuando presionemos el bot\u00f3n el LED debe encenderse y cuando lo soltemos debe apagarse.</p>"},{"location":"actividades/A03/#lista-de-componentes","title":"Lista de componentes","text":"<ul> <li> - Placa pico explorer con Pi Pico</li> <li> - 1 Cable USB A a USB micro que utilizaremos para programar y alimentar la Pi Pico</li> <li> - 1 Diodo LED</li> <li> - 1 Resistencia de 220R</li> <li> - 2 Resistencia de 100K</li> <li> - 1 pulsador</li> <li> - Cables dupont</li> </ul>"},{"location":"actividades/A03/#esquema-del-circuito","title":"Esquema del circuito","text":"<p>El circuito que vamos a montar es el siguiente:</p> <p> <p></p> <p></p>"},{"location":"actividades/A03/#programa","title":"Programa","text":""},{"location":"actividades/A03/#codigo","title":"C\u00f3digo","text":"<p>El c\u00f3digo de la actividad es el siguiente:</p> <pre><code>from machine import Pin\n\nled = Pin(5, Pin.OUT)\n\n#crea 'pulsador' y habilita su resistencia pull-up\npulsador = Pin(4, Pin.IN, Pin.PULL_UP)\n\ntry:\n    while True:\n        if not pulsador.value():\n            led.value(1)\n        else:\n            led.value(0)\nexcept:\n    pass\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A03_pulsador y bot\u00f3n</li> </ul>"},{"location":"actividades/A03/#explicacion","title":"Explicaci\u00f3n","text":"<p>El programa de la imagen siguiente se ejecutar\u00e1 de arriba a abajo l\u00ednea a l\u00ednea. Cuando se encuentra un bucle o un condicional ejecutar\u00e1 la sentencia del mismo seg\u00fan su condici\u00f3n.</p> <p> <p> A03_programa</p> <p></p> <p>Para trabajar con la Pi Pico necesitamos importar los m\u00f3dulos correspondientes a las funciones que vamos a emplear, en nuestro caso:</p> <pre><code>from machine import Pin\n</code></pre> <p>A continuaci\u00f3n configuramos la patilla GPIO a la que conectamos el LED como salida, realizamos una asignaci\u00f3n a <code>led</code> del pin GP5 y tambi\u00e9n configuramos como entrada el pin GP4 activando su resistencia de pull-up y asign\u00e1ndolo a <code>pulsador</code>.</p> <pre><code>led = Pin(5, Pin.OUT)\n\n#crea 'pulsador' y habilita su resistencia pull-up\npulsador = Pin(4, Pin.IN, Pin.PULL_UP)\n</code></pre> <p>Leemos el estado del pin del bot\u00f3n con la funci\u00f3n value(). Al accionar el pulsador, la funci\u00f3n devuelve nivel bajo y el resultado de <code>if</code> es verdadero (debido al <code>not</code>) y el LED se encender\u00e1; de lo contrario, el LED estar\u00e1 apagado.</p> <pre><code>if not pulsador.value():\n            led.value(1)\n        else:\n            led.value(0)\n</code></pre>"},{"location":"actividades/A04/","title":"A04. Pulsador como interruptor","text":""},{"location":"actividades/A04/#enunciado","title":"Enunciado","text":"<p>En esta actividad vamos a controlar el estado de un diodo LED mediante un bot\u00f3n pulsador pero de manera diferente a la actividad A03. Cuando presionemos el bot\u00f3n el LED se encender\u00e1 si estaba apagado o se apagar\u00e1 si estaba encendido. Es decir, la acci\u00f3n del pulsador ya no es moment\u00e1nea ya que el LED va a permanecer encendido sin necesidad de estar acionan\u00e1ndolo de forma continua.</p> <p>Contenidos de electr\u00f3nica b\u00e1sica que se aconseja repasar:</p> <ul> <li>Cables Dupont</li> <li>Protoboard</li> <li>Resistencias fijas</li> <li>Diodo LED</li> <li>Pulsador</li> <li>Rebotes</li> </ul>"},{"location":"actividades/A04/#lista-de-componentes","title":"Lista de componentes","text":"<ul> <li> - Placa pico explorer con Pi Pico</li> <li> - 1 Cable USB A a USB micro que utilizaremos para programar y alimentar la Pi Pico</li> <li> - 1 Diodo LED</li> <li> - 1 Resistencia de 220R</li> <li> - 2 Resistencia de 100K</li> <li> - 1 pulsador</li> <li> - Cables dupont</li> </ul>"},{"location":"actividades/A04/#esquema-del-circuito","title":"Esquema del circuito","text":"<p>El circuito que vamos a montar es el siguiente:</p> <p> <p></p> <p></p>"},{"location":"actividades/A04/#programa","title":"Programa","text":""},{"location":"actividades/A04/#codigo","title":"C\u00f3digo","text":"<p>El c\u00f3digo de la actividad es el siguiente:</p> <pre><code>from machine import Pin\nimport time\n\nled = Pin(5, Pin.OUT)\npulsador = Pin(4, Pin.IN, Pin.PULL_UP)\n\ndef invertirGPIO():\n    if led.value():\n        led.value(0)\n    else:\n        led.value(1)\n\ntry:\n    while True:\n        if not pulsador.value():\n            time.sleep_ms(20)\n            if not pulsador.value():\n                invertirGPIO()\n                while not pulsador.value():\n                    time.sleep_ms(20)\nexcept:\n    pass\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A04_pulsador como interruptor</li> </ul>"},{"location":"actividades/A04/#explicacion","title":"Explicaci\u00f3n","text":"<p>Veamos el funcionamiento del programa:</p> <ul> <li>Importaci\u00f3n de m\u00f3dulos y configuraci\u00f3n de pines. Ver actividades anteriores.</li> <li>Bucle infinito:</li> </ul> <p> <p> A04_bucle infinito</p> <p></p> <p>Cuando se detecta que se ha pulsado el bot\u00f3n (primer if), se genera un retardo de 20 ms para evitar el efecto rebote y, a continuaci\u00f3n, se comprueba si el bot\u00f3n ha sido pulsado de nuevo (segundo if). En caso afirmativo, se ejecutar\u00e1 la sentencia condicional, en caso contrario no se ejecutar\u00e1. Si el segundo if se cumple se invoca a la funci\u00f3n <code>invertirGPIO()</code>.</p> <ul> <li>Funci\u00f3n <code>invertirGPIO()</code>:</li> </ul> <p> <p> A04_funci\u00f3n invertir estado GPIO</p> <p></p> <p>Se eval\u00faa el estado de <code>led</code> y si est\u00e1 a 1 lo pone a 0 o viceversa.</p>"},{"location":"actividades/A05/","title":"A05. Barra de LEDs","text":""},{"location":"actividades/A05/#enunciado","title":"Enunciado","text":"<p>En esta actividad vamos a hacer un proyecto sencillo que haga que los LEDs se enciendan y apaguen simulando un desplazamiento del LED encendido. Jugaremos un poco con el valor de los retardos para dar sensaci\u00f3n de aceleraci\u00f3n.</p> <p>Contenidos de electr\u00f3nica b\u00e1sica que se aconseja repasar:</p> <ul> <li>Cables Dupont</li> <li>Protoboard</li> <li>Resistencias fijas</li> <li>Barras de LEDs</li> </ul>"},{"location":"actividades/A05/#lista-de-componentes","title":"Lista de componentes","text":"<ul> <li> - Placa pico explorer con Pi Pico</li> <li> - 1 Cable USB A a USB micro que utilizaremos para programar y alimentar la Pi Pico</li> <li> - 10 Resistencia de 220R</li> <li> - 1 barra de 10 LEDs</li> <li> - Cables dupont</li> </ul>"},{"location":"actividades/A05/#esquema-del-circuito","title":"Esquema del circuito","text":"<p>El circuito que vamos a montar es el siguiente:</p> <p> <p></p> <p></p>"},{"location":"actividades/A05/#programa","title":"Programa","text":""},{"location":"actividades/A05/#codigo","title":"C\u00f3digo","text":"<p>El c\u00f3digo de la actividad es el siguiente:</p> <pre><code>from machine import Pin\nimport time\n\npines = [0, 1, 2, 3, 4, 5, 6, 7, 27, 28] #27 y 28 son ADC0 y ADC1\ndef mostrarBarras(): \n    time.sleep(1) # parada entre recorridos\n    for pin in pines:\n        print(pin)\n        led = Pin(pin, Pin.OUT)\n        led.value(1)\n        time.sleep_ms(300)\n        led.value(0)\n        time.sleep_ms(300)        \n    time.sleep(1) # parada entre recorridos\n    for pin in reversed(pines):\n        print(pin)\n        led = Pin(pin, Pin.OUT)\n        led.value(1)\n        time.sleep_ms(300)\n        led.value(0)\n        time.sleep_ms(300)\n\nwhile True:\n    mostrarBarras()\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A05_barra de LEDs</li> </ul>"},{"location":"actividades/A05/#explicacion","title":"Explicaci\u00f3n","text":"<p>Veamos el funcionamiento del programa:</p> <ul> <li>Importaci\u00f3n de m\u00f3dulos. Ver actividades anteriores.</li> <li>Configuraci\u00f3n de pines. La definici\u00f3n se realiza mediante una matriz de 10 elementos, en correspondencia con los 10 pines que usaremos. Los pines 27 y 28 son los pines ADC0 y ADC1 usados como digitales en este caso. La configuraci\u00f3n de los pines como salida se realiza en la funci\u00f3n <code>mostrarBarras()</code> con la variable <code>led</code></li> </ul> <p> <p> A05_configuraci\u00f3n de pines</p> <p></p> <ul> <li>Se realiza la definici\u00f3n de la funci\u00f3n <code>mostrarBarras()</code> que incluye dos bucles <code>for</code>, uno para encender los segmentos en un sentido y el otro para hacerlo en sentido contrario (reversed). Cada bucle va precedido de un retardo de un segundo antes de iniciarse.</li> </ul> <p> <p> A05_definici\u00f3n de la funci\u00f3n mostrarBarras()</p> <p></p> <ul> <li>Bucle infinito: Se invoca la funci\u00f3n definida.</li> </ul> <p> <p> A05_bucle infinito</p> <p></p>"},{"location":"actividades/A06/","title":"A06.Control PWM de LED externo","text":"<p>Contenidos de electr\u00f3nica b\u00e1sica que se aconseja repasar:</p> <ul> <li>Cables Dupont</li> <li>Protoboard</li> <li>Resistencias fijas</li> <li>Diodo LED</li> <li>Se\u00f1ales</li> </ul>"},{"location":"actividades/A06/#enunciado","title":"Enunciado","text":"<p>En esta actividad haremos que un LED montado en la placa protoboard de la Pico Explorer se vaya iluminando de menos a mas hasta obtener el brillo maximo y despu\u00e9s que este disminuya hasta el total apagado.</p>"},{"location":"actividades/A06/#lista-de-componentes","title":"Lista de componentes","text":"<ul> <li> - Placa pico explorer con Pi Pico</li> <li> - 1 Cable USB A a USB micro que utilizaremos para programar y alimentar la Pi Pico</li> <li> - 1 Diodo LED</li> <li> - 1 Resistencia de 220R (opcional)</li> <li> - Cables dupont</li> </ul>"},{"location":"actividades/A06/#esquema-del-circuito","title":"Esquema del circuito","text":"<p>El circuito que vamos a montar es el siguiente:</p> <p> <p> </p> <p></p> <p>La resistencia serie se puede omitir dado que Pico Explorer ya incluye una de 100 ohmios.</p>"},{"location":"actividades/A06/#programa","title":"Programa","text":"<p>El c\u00f3digo del programa es:</p> <pre><code>from machine import Pin, PWM\nimport time\n\n# crea y configura GP7 como salida PWM\npwm5 = PWM(Pin(5))\npwm5.freq(10000) # metodo freq para hacer f=10kHz en GP5\n\ntry:\n    while True:\n        for i in range(0, 65535):\n            pwm5.duty_u16(i)\n            time.sleep_us(100)\n        for i in range(65535, 0, -1):\n            pwm5.duty_u16(i)\n            time.sleep_us(100)\nexcept:\n    pwm5.deinit()\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A06_controlPWM_LED_externo</li> </ul> <p>El rango del ciclo de trabajo va de 0 a 65535. El primer bucle for controla el PWM cambiando el valor del ciclo de trabajo para que la salida PWM var\u00ede de 0% a 100%. El segundo bucle for hace variar la salida PWM de 100% a 0%.</p> <p>Cada vez que se utiliza el PWM, el temporizador de hardware se pondr\u00e1 en ON para trabajar con \u00e9l. Por lo tanto, despu\u00e9s de cada uso de PWM, se debe llamar a la funci\u00f3n <code>deinit()</code> que es la encargada de apagar el temporizador. De lo contrario, el PWM puede fallar la pr\u00f3xima vez que intentemos trabajar con \u00e9l.</p>"},{"location":"actividades/A07/","title":"A07.LED RGB","text":"<p>Contenidos de electr\u00f3nica b\u00e1sica que se aconseja repasar:</p> <ul> <li>Cables Dupont</li> <li>Protoboard</li> <li>Resistencias fijas</li> <li>LED RGB</li> </ul>"},{"location":"actividades/A07/#enunciado","title":"Enunciado","text":"<p>En esta actividad vamos a controlar un diodo LED multicolor o LED RGB que haremos que cambie entre diferentes colores de forma autom\u00e1tica.</p>"},{"location":"actividades/A07/#lista-de-componentes","title":"Lista de componentes","text":"<ul> <li> - Placa pico explorer con Pi Pico</li> <li> - 1 Cable USB A a USB micro que utilizaremos para programar y alimentar la Pi Pico</li> <li> - 1 Diodo LED RGB</li> <li> - 3 Resistencias de 220R (opcionales)</li> <li> - Cables dupont</li> </ul>"},{"location":"actividades/A07/#esquema-del-circuito","title":"Esquema del circuito","text":"<p>El circuito que vamos a montar es el siguiente:</p> <p> <p> </p> <p></p> <p>La resistencia serie se puede omitir dado que Pico Explorer ya incluye una de 100 ohmios.</p>"},{"location":"actividades/A07/#programa","title":"Programa","text":"<p>El c\u00f3digo del programa es:</p> <pre><code># --1--&gt; Importar los m\u00f3dulos necesarios\nfrom machine import Pin, PWM\nfrom random import randint\nimport time # &lt;--1--\n\n# --2--&gt; Configurar pines GP3, GP4 y GP5 como salidas PWM y frecuencia de 10 kHz\npines = [3,4,5]\nfrecuencia = 10000\n\npwm0 = PWM(Pin(pines[0]))\npwm1 = PWM(Pin(pines[1]))\npwm2 = PWM(Pin(pines[2]))\npwm0.freq(frecuencia)\npwm1.freq(frecuencia)\npwm2.freq(frecuencia) # &lt;--2--\n\n# --3--&gt; Definicion de la funcion para establecer color del LED RGB\ndef establecer_color(r,g,b):\n    pwm0.duty_u16(65535 - r)\n    pwm1.duty_u16(65535 - g)\n    pwm2.duty_u16(65535 - b) #&lt;--3--\n\ntry:\n    while True:\n        #--4--&gt; Generar tres colores aleatorios y llamar funcion cada 150ms\n        rojo = randint(0, 65535)\n        verde = randint(0, 65535)\n        azul = randint(0, 65535)\n        establecer_color(rojo,verde,azul)\n        time.sleep_ms(150) # &lt;--4--\nexcept:\n    #--5--&gt; Apagado de los temporizadores de hardware\n    pwm0.deinit()\n    pwm1.deinit()\n    pwm2.deinit() # &lt;--5--\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A07_LED_RGB</li> </ul>"},{"location":"actividades/estructura/","title":"Estructura","text":"<p>Las actividades van a mantener la siguiente estructura de manera gen\u00e9rica:</p> <ul> <li> <p>Enunciado describiendo el objetivo que persigue la actividad</p> </li> <li> <p>Lista de componentes con indicaci\u00f3n de los datos necesarios para implementar el programa.</p> </li> <li> <p>Esquema del circuito.</p> </li> <li> <p>C\u00f3digo del programa que resuelve la actividad.</p> </li> <li> <p>Conceptos te\u00f3ricos referentes a Thonny. Los encontraremos en:</p> </li> </ul> <p>Firmware y software -&gt; Software Thonny</p> <ul> <li>Conceptos te\u00f3ricos referentes al componente o componentes utilizados. Los encontraremos en:</li> </ul> <p>Conceptos b\u00e1sicos de electr\u00f3nica</p> <p>Los principios b\u00e1sicos del lenguaje los tenemos descritos en el apartado Python y sus diferentes entradas.</p>"},{"location":"guias/control/","title":"Estructuras de control","text":"<p>Los programas se ejecutan de manera secuencial l\u00ednea tras l\u00ednea de c\u00f3digo, pero existen muchas situaciones en las que nos va a interesar que esto no sea as\u00ed, como por ejemplo hacer dos cosas diferentes seg\u00fan el valor de una variable o repetir un determinado n\u00famero de veces o hasta que se cumpla una condici\u00f3n dada ciertas instrucciones. Para realizar estas tareas se utilizan las estructuras de control que vamos a describir seguidamente.</p>"},{"location":"guias/control/#condicional-if","title":"Condicional if","text":"<p>En este apartado vamos en primer lugar a estudiar la funci\u00f3n if para posteriormente ver como realizar una instrucci\u00f3n muy \u00fatil que existe en otros lenguajes, pero no en Python, se trata de <code>switch</code>.</p>"},{"location":"guias/control/#if","title":"if","text":"<p>En programaci\u00f3n se utiliza la sentencia if para ejecutar un bloque de c\u00f3digo s\u00f3lo cuando se cumple una determinada condici\u00f3n. La sintaxis b\u00e1sica de <code>if</code> es:</p> <pre><code>...\nsentencias previas a if\n...\nif condicion:\n    sentecia 1\n    sentencia 2\n    ...\ncontinua el programa despues de if\n</code></pre> <p>Se eval\u00faa <code>condicion</code> siempre y:</p> <ul> <li>Si el resultado es cierto (True o 1) se ejecuta el bloque de sentencias y se contin\u00faa el programa</li> <li>Si el resultado es falsa (False o 0) se omite el bloque de sentencias y se contin\u00faa el programa</li> </ul> <p>En el <code>if</code> la condici\u00f3n tiene que ser una expresi\u00f3n l\u00f3gica que se pueda evaluar como <code>True</code> o como <code>False</code>. Esta l\u00ednea siemrpe tiene que acabar con dos puntos (:).</p> <p>En la figura siguiente vemos la explicaci\u00f3n de forma gr\u00e1fica mediante un ejemplo:</p> <p> <p></p> <p></p> <p>Veamos un ejemplo sencillo de uso. Se trata de que introduzcamos un valor por teclado y el programa nos indique si es el n\u00famero es positivo y el valor introducido.</p> <pre><code>numero = int(input(\"Escribe un n\u00famero y pulsa Enter: \"))\nif numero &gt; 0:\n    print(\"El n\u00famero introducido es positivo\")\nprint(\"El n\u00famero es:\", numero)\n</code></pre> <p>En la imagen vemos la respuesta a dos entradas diferentes, una negativa y la otra positiva.</p> <p> <p></p> <p></p>"},{"location":"guias/control/#ifelse","title":"if...else","text":"<p>Una sentencia <code>if</code> puede tener de manera opcional una clausula <code>else</code>. La sintaxis de esta declaraci\u00f3n en Python tiene la forma siguiente:</p> <pre><code>if condicion:\n    # Bloque de sentencias si condicion es True\n\n    else:\n    # Bloque de sentencias si condicion es False\n</code></pre> <p>La sentencia se eval\u00faa de la siguiente forma: Si <code>condici\u00f3n</code> es <code>True</code> se ejecuta el c\u00f3digo dentro del <code>if</code> y el c\u00f3digo dentro del <code>else</code> se omite. Si <code>condici\u00f3n</code> es <code>False</code> se ejecuta el c\u00f3digo dentro del <code>else</code> y el c\u00f3digo dentro del <code>if</code> se omite. Cuando finaliza bien la parte del <code>if</code> o bien la del <code>else</code> el programa continua con la siguiente sentencia del programa.</p> <p>En la figura siguiente vemos la explicaci\u00f3n de forma gr\u00e1fica.</p> <p> <p></p> <p></p>"},{"location":"guias/control/#ifelifelse","title":"if...elif...else","text":"<p>La sentencia  se utiliza para ejecutar un bloque de c\u00f3digo entre dos alternativas posibles. Sin embargo, si necesitamos elegir entre m\u00e1s de dos alternativas debemos utilizar la sentencia <code>if...elif...else</code>. Su sintaxis es:</p> <pre><code>if condicion_1:\n    # Bloque 1\nelif condicion_2:\n    #Bloque 2\n\n    else:\n    # Bloque 3\n</code></pre> <p>Se eval\u00faa as\u00ed: Si <code>condicion_1</code> es <code>True</code>, se ejecuta Bloque 1. Si <code>condicion_1</code> es <code>False</code>, se eval\u00faa <code>condicion_2</code>. Si <code>condicion_2</code> es <code>True</code>, se ejecuta Bloque 2. Si <code>condicion_2</code> es <code>False</code>, se ejecuta Bloque 3. Y as\u00ed sucesivamente tantas veces como sea necesario. Opcionalmente esta sentencia tambi\u00e9n puede tener una clausula <code>else</code> que se ejecutar\u00e1 si no se cumple ninguna de las condiciones.</p> <p>En la figura siguiente vemos la explicaci\u00f3n de forma gr\u00e1fica.</p> <p> <p></p> <p></p>"},{"location":"guias/control/#switch","title":"Switch","text":"<p>La sentencia <code>switch</code> junto con <code>case</code> (en el caso de lenguaje C) est\u00e1 pensada para el control de sentencias condicionales de bifurcaci\u00f3n complejas y su funcionamiento es muy similar al de un conmutador rotativo de m\u00faltiples posiciones, siendo <code>case</code> cada una de estas posiciones. Es decir, se eval\u00faa la expresi\u00f3n de <code>switch</code> y en funci\u00f3n del resultado (un n\u00famero entero) se transfiere el control a un <code>case</code> o posici\u00f3n determinada. Esta sentencia adem\u00e1s tiene una clausula <code>default</code> para devolver un valor si no se cumple ninguna de las condiciones, es decir no existe el case para el valor obtenido.</p> <p>Este tipo de sentencia resulta muy \u00fatil en algunos casos pero en Python no est\u00e1 implementada, as\u00ed que tendremos que crear c\u00f3digo con <code>if</code> que simulen su comportamiento.</p> <p>Se puede utilizar <code>elif</code> para hacerlo, pero si el n\u00famereo de condiciones es elevado el tiempo en el que se eval\u00faa cada una puede ser importante. Tenemos que tener en cuenta que las sentencias de evaluan de manera secuencial y no transcurre el mismo tiempo en que se evaluen las primeras que las \u00faltima en un conjunto de 200 sentencias.</p> <pre><code>if caso == 1:\n    print(\"1\")\nelif caso == 2:\n    print(\"2\")\nelif caso == 3:\n    print(\"3\")\nelif caso == 4:\n    print(\"4\")\n# ...\nelif caso == 200:\n    print(\"200\")\nelse:\n    print(\"Equivale a default\")\n</code></pre> <p>Vamos a ver un ejemplo en el que emularemos de dos maneras diferentees a <code>switch</code> para convertir los caracteres del sistema de numeraci\u00f3n octal en binario de tres digititos creando sendas funciones mediante <code>def</code>.</p> <ul> <li><code>switch</code> con <code>if</code>:</li> </ul> <pre><code>def switch_if(octal):\n    if octal == '0':\n        return \"000\"\n    elif octal == '1':\n        return \"001\"\n     elif octal == '2':\n        return \"010\"\n     elif octal == '3':\n        return \"011\"\n     elif octal == '4':\n        return \"100\"\n     elif octal == '5':\n        return \"101\"\n     elif octal == '6':\n        return \"110\"\n     elif octal == '7':\n        return \"111\"\n    else:\n        return \"NAN\" #Not A Number\n</code></pre> <ul> <li><code>switch</code> con un diccionario:</li> </ul> <pre><code>dicc = {\n    '0':'000',\n    '1':'001',\n    '2':'010',\n    '3':'011',\n    '4':'100',\n    '5':'101',\n    '6':'110',\n    '7':'111',\n    }\ndef switch_dicc(octal):\n    return dicc.get(octal, \"NAN\")\n</code></pre>"},{"location":"guias/control/#bucle-for","title":"Bucle for","text":"<p>En los bucles <code>for</code> la acci\u00f3n est\u00e1 dirigida a contar el n\u00famero de veces que ocurre algo o realizar una acci\u00f3n un determinado n\u00famero de veces. Es especialmente \u00fatil para recorrer los datos de una lista, tupla o diccionario.</p> <p>La sintaxis de este tipo de bucles en Python es:</p> <pre><code>for variable in secuencia:\n    declaracion\n</code></pre> <p>Siendo \"<code>variable</code>\" la variable que se va a recorrer en el bucle de forma que cuando se alcance el valor establecido se sale del bucle.</p> <p>La variable puede ser una cadena, un rango de valores que se expresa con <code>range(n)</code>, siendo n el n\u00famero de valores del rango que se inicia en 0 y que pueden ser iterados con una variable. Mas ampliamente, la sintaxis de <code>range()</code> es <code>range(start, stop, step)</code> siendo <code>start</code> y <code>stop</code> opcionales.</p> <p>El bucle <code>for</code> se utiliza para ejecutar un programa sin fin e iterar en el orden de los elementos (una lista o una cadena) en la secuencia.</p> <p>Usos comunes son:</p> <pre><code>for pin in pines\n</code></pre> <p>Donde <code>pines</code> es una lista de elementos que son iterados por un bucle <code>for</code> y asignados a la variable del bucle <code>pin</code> cada vez.</p> <pre><code>for i in range(start, end, num: 1)\n</code></pre> <p>Donde:</p> <ul> <li> - <code>start</code>: es el valor inicial, a partir del cual el bucle for empieza a contar. El valor inicial por defecto es 0. Por ejemplo, <code>range(5)</code> es igual a <code>range(0, 5)</code>.</li> <li> - <code>end</code>: es el valor con el que termina. El bucle for cuenta hasta llegar a este valor, pero este valor no se incluye en el conteo.</li> <li> - <code>num</code>: El valor de incremento del bucle. El valor por defecto es 1.</li> </ul> <p>En el bucle <code>for</code> existe un iterable que define las veces que se ejecutar\u00e1 el c\u00f3digo del mismo. Un ejemplo de <code>for</code> ser\u00eda:</p> <pre><code>for i in range(0,7):\n    print(i)\n</code></pre> <p>Genera la siguiente salida:</p> <pre><code>0\n1\n2\n3\n4\n5\n6\n</code></pre> <p>Vamos a crear un ejemplo de <code>for</code> que realice iteraciones sobre una cadena de texto:</p> <pre><code>for i in \"Cadena de texto\":\n    print(i)\n</code></pre> <p>Genera la siguiente salida:</p> <pre><code>C\na\nd\ne\nn\na\n\nd\ne\n\nt\ne\nx\nt\no\n</code></pre>"},{"location":"guias/control/#for-anidados","title":"For anidados","text":"<p>Los bucles se pueden anidar, es decir se puede crear un bucle dentro de otro del mismo o diferente tipo, de forma que por cada iteraci\u00f3n del bucle mas externo se tienen que producir todas las iteraciones del bucle mas interno. Esto resulta muy \u00fatil si por ejemplo tenemos listas anidadas (cada elemento de la lista es otra lista). Veamos un  ejemplo:</p> <pre><code>lista_de_listas = [[5, 7, 9], [\"Cadena\", \"de\", \"texto\"], [2, 4, 6]]\nfor i in lista_de_listas:\n    print(i)\n</code></pre> <p>Un solo <code>for</code> simplemente nos muestra la lista:</p> <pre><code>[5, 7, 9]\n['Cadena', 'de', 'texto']\n[2, 4, 6]\n</code></pre> <p>En este caso podemos acceder a cada elemento individual anidando dos <code>for</code>, as\u00ed:</p> <pre><code>lista_de_listas = [[5, 7, 9], [\"Cadena\", \"de\", \"texto\"], [2, 4, 6]]\nfor i in lista_de_listas:\n    for j in i:\n        print(j)\n</code></pre> <p>Que nos devuelve:</p> <pre><code>5\n7\n9\nCadena\nde\ntexto\n2\n4\n6\n</code></pre> <p>El bucle for puede tener de manera opcional un bloque else cuyas sentencias se ejecutan cuando se han realizado todas las iteraciones del bucle. Un ejemplo lo vemos a continuaci\u00f3n:</p> <pre><code>for var in range(5):\n    print(var)\nelse:\n    print(\"bucle finalizado\")\n</code></pre>"},{"location":"guias/control/#bucle-for-decontando","title":"Bucle for decontando","text":"<p>Se trata del mismo bucle for pero ahora la cuenta la realizamos hacia atr\u00e1s. Hay dos formas sencillas de hacerlo:</p> <ul> <li>Utilizando la funci\u00f3n range(). Si queremos darle un enfoque Pythonic simplemente configuramos los argumentos de la funci\u00f3n de manera que se indique el principio, el final y el incremento, que ser\u00e1 logicamente negativo.</li> </ul> <pre><code>for i in range(20, 0, -2): #imprimere 20, 18, 16, ... 0\n</code></pre> <ul> <li>Utilizando la funci\u00f3n reversed(). Es una funci\u00f3n incorporada en la que hay que indicar como primer argumento el final de la cuenta, como segundo el principio, teniendo en cuenta que se omite, y como tercero el decremento si es ditintos de 1, pero se especifica en m\u00f3dulo. Se utiliza as\u00ed:</li> </ul> <pre><code>for i in reversed(range(0,21,2)): #imprimere 20, 18, 16, ... 0\n</code></pre>"},{"location":"guias/control/#range","title":"Range","text":"<p>Una de las operaciones mas comunes en programaci\u00f3n es iterar n\u00fameros entre un valor dado (muy usual comenzar por 0) y un n\u00famero <code>n</code>. Si por ejemplo queremos iterar una variable <code>i</code> entre 0 y 4 podemos escribir:</p> <pre><code>for i in (0,1,2,3,4):\n    print(i)\n</code></pre> <p>Que nos devuelve una salida con:</p> <pre><code>0\n1\n2\n3\n4\n</code></pre> <p>Esto es totalmente correcto ya que la tupla <code>(0,1,2,3,4)</code> es perfectamente iterable. Pero no es una buena pr\u00e1ctica, sobre todo si esa tupla tiene un n\u00famero muy elevado de elementos. En Python es posible hacer esto mismo utilizando <code>range()</code>:</p> <pre><code>for i in range(5):\n    print(i)\n</code></pre> <p>Nos va a devolver el mismo resultado y podemos observar que el par\u00e1metro de range es el n\u00famero de elementos y como se comienza en 0 se iterar\u00e1 hasta el 4, o sea el n\u00famero de elementos menos uno.</p> <p>En <code>range()</code> podemos pasar hasta tres par\u00e1metros en lugar de utilizar la opci\u00f3n por defecto del n\u00famero de elementos. Tendr\u00eda una sintaxis como:</p> <pre><code>for i in range(inicio, fin, incremento)\n</code></pre> <p>donde <code>inicio</code> es  el valor inicial de la iteraci\u00f3n, <code>fin</code> es el valor final e <code>incremento</code> es el salto entre valores. Cabe destacar que <code>incremento</code> puede ser un valor negativo. Un ejemplo nos aclara estos t\u00e9rminos:</p> <pre><code>for i in range(20, 51, 10):\n    print(i)\nprint(\"----------------------------\")\nfor j in range(50, 19, -10):\n    print(j)\n</code></pre> <p>Genera el siguiente resultado:</p> <pre><code>20\n30\n40\n50\n----------------------------\n50\n40\n30\n20\n</code></pre> <p>Observese la congruencia de los valores inicial y final con el valor de incremento de las variables. Si hacemos:</p> <pre><code>for j in range(19, 50, -10):\n    print(j)\n</code></pre> <p>No devolver\u00e1 ning\u00fan resultado porque es imposible realizar esa iteraci\u00f3n.</p>"},{"location":"guias/control/#bucle-while","title":"Bucle While","text":"<p>La sintaxis de while es la siguiente:</p> <pre><code>while condicion:\n    bloque de codigo\n</code></pre> <p>donde \"condicion\", que se eval\u00faa en cada iteraci\u00f3n, puede ser cualquier expresi\u00f3n realizado con operadores condicionales que devuelva como resultado un valor <code>True</code> o <code>False</code>. Mientra que \"bloque de codigo\" es el conjunto de instrucciones que se estar\u00e1n ejecutando mientras la condici\u00f3n sea <code>verdadera</code> (<code>True</code> o '<code>1</code>'). Es lo mismo poner <code>while true:</code> que <code>poner while 1:</code>.</p> <p>El bucle <code>while</code> es de los bucles que no tienen un n\u00famero definido de iteraciones. Un ejemplo sencillo nos va a permitir entender su estructura y funcionamiento:</p> <pre><code>valor = 4\nwhile valor &gt; 0:\n    valor -= 1\n    print(valor) # salida: 3, 2, 1, 0\nprint(\"Iteraciones finalizadas\")\n</code></pre> <p>Las dos partes de este bucle <code>while</code> son:</p> <ul> <li>Condici\u00f3n: <code>valor &gt; 0</code></li> <li>Bloque de c\u00f3digo: <code>x -= 1</code> y <code>print(valor)</code></li> <li>proceso de ejecuci\u00f3n: El programa sigue esta secuencia de pasos:</li> </ul> <ul> <li>Primera iteraci\u00f3n: La primera vez entra con <code>valor = 4</code> que es mayor que 0, por lo que se decrementa en 1 y se imprime la variable (se obtiene el 3) finalizando la primera iteraci\u00f3n para volver a evaluar condici\u00f3n.</li> <li>Segunda iteraci\u00f3n: Ahora la variable es <code>valor = 3</code> que es mayor que 0, por lo que se decrementa en 1 y se imprime la variable (se obtiene el 2) y ha terminado la segunda iteraci\u00f3n volvi\u00e9ndose a evaluar condici\u00f3n.</li> <li>Tercera iteraci\u00f3n: La variable es <code>valor = 2</code> que es mayor que 0, por lo que se decrementa en 1 y se imprime la variable (se obtiene el 1) y se pone fin a la tercera iteraci\u00f3n para volver a evaluar condici\u00f3n.</li> <li>Cuarta iteraci\u00f3n: Ahora la variable es <code>valor = 1</code> que es mayor que 0, por lo que se decrementa en 1 y se imprime la variable (se obtiene el 0) y ha terminado la cuarta iteraci\u00f3n volvi\u00e9ndose a evaluar condici\u00f3n.</li> <li>Salida de while: Ya no se cumple la condici\u00f3n por lo que se finaliza el while y se imprime el mensaje del <code>print()</code> final.</li> </ul>"},{"location":"guias/control/#clausula-else","title":"Cl\u00e1usula <code>else</code>","text":"<p>El bucle while puede tener de manera opcional una clausula else cuyas sentencias se ejecutan cuando se han realizado todas las iteraciones del bucle. Vamos a ver su uso continuando con el ejemplo anterior:</p> <pre><code>valor = 4\nwhile valor &gt; 0:\n    valor -= 1\n    print(valor) # salida: 3, 2, 1, 0\nelse:\n    print(\"Iteraciones del while finalizadas\")\n    print(\"\")\n    print(\"---------------------------\")\n\nprint(\"Continuaci\u00f3n del programa\")\nvalor = 8\nprint(\"Cambiado valor a:\",valor)\nprint(\"... mas programa\")\n</code></pre> <p>Esto nos devuelve el siguiente resultado:</p> <pre><code>3\n2\n1\n0\nIteraciones del while finalizadas\n\n---------------------------\nContinuaci\u00f3n del programa\nCambiado valor a: 8\n... mas programa\n</code></pre>"},{"location":"guias/control/#anidar-while","title":"Anidar while","text":"<p>Los bucles <code>while</code> se pueden anidar de manera similar a los bucles <code>for</code> y pueden a su vez tener o no cl\u00e1usula <code>else</code> tanto el primero como el o los anidados. Vamos a ver un ejemplo en que se generan todas las combinaciones de los valores de tres n\u00fameros dados variando sus valores entre 0 y 2. Generaremos una tabla a partir de estas combinaciones:</p> <pre><code>i, j, k = 0, 0, 0\nprint(\"| i | j | k |\")\nprint(\"-------------\")\nwhile i &lt; 3:\n    while j &lt; 3:\n        while k &lt; 3:\n            print(\"|\",i,\"|\",j,\"|\",k,\"|\")\n            k += 1\n            j += 1\n        k = 0\n    i += 1\n    j = 0\n</code></pre> <p>El resultado que devuelve el programa es:</p> <pre><code>| i | j | k |\n-------------\n| 0 | 0 | 0 |\n| 0 | 1 | 1 |\n| 0 | 2 | 2 |\n| 1 | 0 | 0 |\n| 1 | 1 | 1 |\n| 1 | 2 | 2 |\n| 2 | 0 | 0 |\n| 2 | 1 | 1 |\n| 2 | 2 | 2 |\n</code></pre>"},{"location":"guias/control/#ejemplos","title":"Ejemplos","text":"<p>Para terminar de explicar vamos a ver como resolver en Python dos ejemplos cl\u00e1sicos de programaci\u00f3n:</p> <ul> <li>Sucesi\u00f3n de Fibonacci. La sucesi\u00f3n de Fibonacci es una sucesi\u00f3n infinita de n\u00fameros naturales que comienza con los valores 0 y 1 y en la que se van obteniendo 'hijos de Fibonacci' sumando los dos t\u00e9rminos anteriores:</li> </ul> <p>1,1,2,3,5,8,13,21,34,55,89,144,...</p> <p>Un programa que resuelve esto ser\u00eda:</p> <pre><code>print(\"Hijos de Fibonacci menores o iguales a 5000:\")\nx,y = 0,1\nwhile y &lt; 5000:\n    print(y)\n    x,y = y, x + y\n</code></pre> <p>El resultado para ese u otros l\u00edmites lo puede observar el lector creando el programa.</p> <ul> <li>Iterar una cadena. El ejemplo va aclararnos el funcionamiento de while pero no es la mejor forma de iterar una cadena.</li> </ul> <pre><code>texto = \"Cadena de texto\"\ni=0\nwhile i &lt; len(texto):\n    print(texto[:i +  1])\n    i += 1\n</code></pre> <p>Se nuevo invitamos al lector a ver los resultados creando el programa.</p>"},{"location":"guias/control/#break","title":"Break","text":"<p>La sentencia <code>break</code> se utiliza para terminar un bucle <code>for</code> o <code>while</code> de manera inmediata al ser encontrada. En la imagen vemos la sintaxis de la sentencia <code>break</code> y su funcionamiento.</p> <p> <p></p> <p></p> <p>Veamos un ejemplo de uso de <code>break</code> con un bucle<code>for</code> para iterar una cadena hasta que encontremos un caracter concreto.</p> <pre><code>texto = \"Cadena de texto\"\nfor caracter in texto:\n    if caracter == 't':\n        print(\"He encontrado la letra t\")\n        break \n    print(caracter)\n</code></pre> <p>Con el siguiente resultado:</p> <pre><code>C\na\nd\ne\nn\na\n\nd\ne\n\nHe encontrado la letra t\n</code></pre> <p>Vamos a retomar un ejemplo anterior para ver ahora un ejemplo de <code>break</code> en un bucle <code>while</code> y como su uso inadecuado va a impedir que se ejecute la cl\u00e1usula <code>else</code> del mismo.</p> <pre><code>valor = 4\nwhile True:\n    valor -= 1\n    print(valor) # salida: 3, 2, 1, 0\n    if valor == 0:\n        break\nelse:\n    print(\"Iteraciones del while finalizadas\")\n    print(\"\")\n    print(\"---------------------------\")\n\nprint(\"Continuaci\u00f3n del programa\")\nvalor = 8\nprint(\"Cambiado valor a:\",valor)\nprint(\"... mas programa\")\n</code></pre> <p>Comprobamos como efectivamente la cl\u00e1usula <code>else</code> no tiene ning\u00fan efecto debido al break por lo que las sentencias del else nunca se ejecutar\u00e1n:</p> <pre><code>3\n2\n1\n0\nContinuaci\u00f3n del programa\nCambiado valor a: 8\n... mas programa\n</code></pre>"},{"location":"guias/control/#continue","title":"Continue","text":"<p>La sentencia <code>continue</code> se utiliza para saltar la iteraci\u00f3n actual del bucle y el flujo de control del programa pasa a la siguiente iteraci\u00f3n. En la imagen vemos la sintaxis de la sentencia <code>continue</code> y su funcionamiento.</p> <p> <p></p> <p></p> <p>La sentencia <code>continue</code> se salta el c\u00f3digo restante en la iteraci\u00f3n actual y vuelve al principio siempre que a\u00fan queden iteraciones por realizar.</p> <p>La diferencia entre <code>break</code> y <code>continue</code> es que este \u00faltimo no rompe el bucle, si no que pasa a la siguiente iteraci\u00f3n saltandose el c\u00f3digo pendiente.</p> <p>Un ejemplo como:</p> <pre><code>cuenta = 0\nwhile cuenta &lt; 10:\n    cuenta += 1\n    if (cuenta % 2) == 0: # el n\u00famero es par\n        continue # se salta por ser par\n    print(cuenta)\n</code></pre> <p>Da como salida los n\u00fameros impares:</p> <pre><code>1\n3\n5\n7\n9\n</code></pre> <p>Este otro ejemplo muestra como eliminar un n\u00famero en la iteraci\u00f3n:</p> <pre><code>for i in range(5):\n    if i == 2: # vamos a saltarnos el 2\n        continue\n    print(i)\n</code></pre> <p>Genera el siguiente resultado:</p> <pre><code>0\n1\n3\n4\n</code></pre>"},{"location":"guias/datos/","title":"Datos en Python","text":"<p>En Python, al igual que en programaci\u00f3n en general, los tipos de datos especifican el tipo de datos que puede almacenarse en una variable.</p>"},{"location":"guias/datos/#numericos","title":"Num\u00e9ricos","text":"<p>Contienen valores num\u00e9ricos y sabemos que:</p> <ul> <li>Los n\u00fameros enteros son de tipo int</li> <li>Los fraccionarios son de tipo float</li> <li>La divisi\u00f3n (/) siempre devuelve un n\u00famero en coma flotante</li> <li>Para obtener la parte entera de una divisi\u00f3n se usa el operador //</li> <li>Para calcular el resto de una divisi\u00f3n se usa el operador %</li> <li>Para calcular potencias podemos usar el operador **</li> <li>Los par\u00e9ntesis se pueden usar para agrupar expresiones</li> <li>El signo igual (=) se utiliza para asignar un valor (n\u00fameros, booleanos, cadenas, \u2026) a una variable</li> <li>El tipo de la variable ser\u00e1 el del dato asignado, no se declara el tipo de la variable al crearla</li> <li>Por convenci\u00f3n el nombre comienza en min\u00fascula y si son varias palabras se unen por gui\u00f3n bajo</li> </ul> <p>Los tipos b\u00e1sicos de datos son:</p> <ul> <li><code>int</code>: n\u00fameros enteros con signo sin l\u00edmite de tama\u00f1o, ejemplo: entero = 5</li> <li><code>float</code>: n\u00fameros reales, decimales o de coma flotante con precisi\u00f3n de hasta 15 decimales, ejemplo: real = 5.6</li> <li><code>complex</code>: n\u00fameros complejos, por ejemplo 5.5 - 5j</li> <li>Para averiguar el tipo de dato usamos la funci\u00f3n <code>type()</code>.</li> </ul> <p>Podemos realizar conversi\u00f3n de tipos as\u00ed:</p> <ul> <li>A entero int(variable)</li> <li>A real float(variable)</li> </ul>"},{"location":"guias/datos/#cadenas","title":"Cadenas","text":"<p>Contienen secuencias de caracteres. Una cadena es una secuencia de caracteres representada entre comillas simples o dobles.</p> <p>Las cadenas pueden estar encerradas entre comillas simples ('...') o dobles (\"...\") con el mismo resultado. Podemos usar  para incluir comillas en una cadena.</p> <p>La funci\u00f3n print() devuelve la cadena que encierra entre los par\u00e9ntesis, omitiendo las comillas que la encierran.</p> <p>En la imagen siguiente se ven varios ejemplos con cadenas utilizando como editor el IDLE que por defecto se instala con Python y que se abre desde una terminal simplemente invocando a Python.</p> <p> <p> Cadenas en el IDLE</p> <p></p> <p>Una cadena raw (cruda) se interpreta tal como se escribe, es decir, se omiten los caracteres especiales expresados con . Las cadenas raw se escriben entrecomilladas y van precedidas del car\u00e1cter 'r'. En la imagen vemos un ejemplo.</p> <p> <p> Cadena cruda en el IDLE</p> <p></p> <p>Es posible aplicar la operaci\u00f3n de multiplicar a textos haciendo que estos se repitan. En la imagen siguientes vemos ejemplos de concatenaci\u00f3n y multiplicaci\u00f3n, as\u00ed como un error cometido.</p> <p> <p> Concatenar y multiplicar textos en el IDLE</p> <p></p>"},{"location":"guias/datos/#secuencias","title":"Secuencias","text":"<p>Contienen colecciones de datos, como las listas, las tuplas, las colecciones de datos (set) o los diccionarios.</p> <p>Una lista es una colecci\u00f3n ordenada de elementos similares o de distinto tipo separados por comas y encerrados entre corchetes [ ].</p> <p>Tupla es una secuencia ordenada de elementos, igual que una lista. La \u00fanica diferencia es que las tuplas son inmutables. Una vez creadas, las tuplas no pueden modificarse. En Python, se utilizan los par\u00e9ntesis () para almacenar los elementos de una tupla.</p> <p>Las colecciones de datos son un conjunto desordenada de elementos \u00fanicos. Una colecci\u00f3n de datos se define por valores separados por comas dentro de llaves { }.</p> <p>Un diccionario es una colecci\u00f3n ordenada de elementos. Almacena los elementos como pares clave/valor. Siendo las claves identificadores \u00fanicos que se asocian a cada valor.</p> <p>Estudiaremos estos \u00faltimos tipos mas extensamente cuando los necesitemos.</p> <p>Los datos de tipo booleano solamente pueden contener <code>True</code> o <code>False</code>.</p> <p>Dado que en programaci\u00f3n Python todo es un objeto, los tipos de datos son en realidad clases y las variables son instancias(objeto) de estas clases.</p>"},{"location":"guias/estr_datos/","title":"Estructuras de datos en Python","text":"<p>En estructuras de datos y de control en Python es habitual utilizar los conceptos de <code>iterable</code> e <code>iterador</code> por lo que antes de nada vamos a describir estos dos conceptos un tanto abstractos y complicados de entender. Utilizaremos para su descripci\u00f3n la sentencia de control <code>for</code>.</p>"},{"location":"guias/estr_datos/#iterables-e-iteradores","title":"iterables e iteradores","text":"<p>Iterar significa que se repite o se ha repetido muchas veces. En programaci\u00f3n una iteraci\u00f3n es un conjunto de instrucciones que se repiten una o varias veces hasta que una condici\u00f3n se cumple o deja de cumplirse.</p> <p>Los <code>iterables</code> son objetos que pueden ser indexados y los <code>iteradores</code> son objetos que hacen referencia a un elemento. Los iteradores tienen un m\u00e9todo <code>next</code> que permite hacer referencia al siguiente objeto.</p> <p>La mayor\u00eda de objetos contenedores se pueden recorrer en bucle utilizando una sentencia for:</p> <pre><code>for element in [1, 2, 3]:\n    print(element)\nfor element in (1, 2, 3):\n    print(element)\nfor key in {'one':1, 'two':2}:\n    print(key)\nfor char in \"123\":\n    print(char)\nfor line in open(\"mifichero.txt\"):\n    print(line, end='')\n</code></pre> <p>Este estilo de acceso es claro, conciso y c\u00f3modo. La sentencia <code>for</code> llama a <code>iter()</code> sobre el objeto contenedor. La funci\u00f3n devuelve un objeto iterador que define el m\u00e9todo <code>__next__()</code> que accede a los elementos del contenedor de uno en uno. Cuando no hay m\u00e1s elementos, <code>__next__()</code> lanza una excepci\u00f3n <code>StopIteration</code> que indica al bucle <code>for</code> que termine. El m\u00e9todo <code>__next__()</code> se invoca utilizando la funci\u00f3n incorporada <code>next()</code>; A continuaci\u00f3n vemos una imagen de un ejemplo de iteraciones desde la consola que muestra c\u00f3mo funciona esto:</p> <p> <p> Ejemplo de uso de next() en iteraciones</p> <p></p> <p>Podemos a\u00f1adir un comportamiento iterador a nuestras clases. Definimos un m\u00e9todo <code></code> que devuelva un objeto con un m\u00e9todo <code>__next__()</code>. Si la clase define <code>__next__()</code>, entonces <code>__iter__()</code> puede devolver simplemente <code>self</code>. Hacemos un ejemplo de recorrer una cadena en orden inverso al escrito. Definimos la clase <code>Orden_inverso</code></p> <pre><code>class Orden_inverso:\n    \"\"\"Iterador para recorrer una secuencia hacia atr\u00e1s\"\"\"\n    def __init__(self, data):\n        self.data = data\n        self.index = len(data)\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.index == 0:\n            raise StopIteration\n        self.index = self.index - 1\n        return self.data[self.index]\n</code></pre> <p>Con la clase definida ponemos el interprete en marcha y trabajamos en la consola haciendo lo que vemos en la imagen siguiente:</p> <p> <p> Ejemplo de definici\u00f3n de clase y iterar us\u00e1ndola</p> <p></p> <p>En Python la funci\u00f3n <code>iter()</code> solamente puede ser llamada sobre un objeto que sea iterable, lo que nos devolver\u00e1 un iterador. En el ejemplo anterior el iterable es 'cadena' y cuando invocamos <code>iter()</code> nos retorna el iterador <code>&lt;Orden_inverso object at 200159c0&gt;</code>. Veamos otro ejemplo con una lista sencilla:</p> <pre><code>lista = [7, 2, 5, 4, 6, 1, 3]\niteradora = iter(lista)\nprint(iteradora) # muestra el iterador\nprint(type(iteradora)) # muestra el tipo de iterador y su clase\n</code></pre> <p>Nos devuelve el resultado siguiente en consola:</p> <pre><code>MPY: soft reboot\n&lt;iterator&gt;\n&lt;class 'iterator'&gt;\n</code></pre> <p>Lavariable <code>iteradora</code> itera sobre la lista lo que permite acceder a sus elementos con <code>next()</code>. Siguiendo con el ejemplo, si hacemos:</p> <pre><code>lista = [7, 2, 5, 4, 6, 1, 3]\niteradora = iter(lista)\nprint(iteradora) # muestra el iterador\nprint(next(iteradora)) # muestra el primer elemento\nprint(next(iteradora)) # muestra el segundo elemento\nprint(next(iteradora)) # muestra el tercer elemento\nprint(next(iteradora)) # muestra el cuarto elemento\nprint(next(iteradora)) # muestra el quinto elemento\nprint(next(iteradora)) # muestra el sexto elemento\nprint(next(iteradora)) # muestra el septimo elemento\n</code></pre> <p>Da como resultado:</p> <pre><code>lista = [7, 2, 5, 4, 6, 1, 3]\niteradora = iter(lista)\nprint(iteradora) # muestra el iterador\nprint(next(iteradora)) # muestra el primer elemento\nprint(next(iteradora)) # muestra el segundo elemento\nprint(next(iteradora)) # muestra el tercer elemento\nprint(next(iteradora)) # muestra el cuarto elemento\nprint(next(iteradora)) # muestra el quinto elemento\nprint(next(iteradora)) # muestra el sexto elemento\nprint(next(iteradora)) # muestra el septimo elemento\n</code></pre> <p>Exsiten iteradores para otras  clases, y estos son:</p> <ul> <li><code>str_iterator</code> para cadenas</li> <li><code>list_iterator</code> para listas</li> <li><code>tuple_iterator</code> para tuplas</li> <li><code>dict_keyiterator</code> para diccionarios</li> </ul> <p>Se pueden tener varios iteradores para la misma lista y tendr\u00e1n un funcionamiento totalmente independiente unos de otros.</p>"},{"location":"guias/estr_datos/#las-listas-list","title":"Las listas (list)","text":"<p>Se trata de un tipo de dato que permite almacenar series de datos de cualquier tipo bajo su estructura. Se suelen asociar a las matrices o arrays de otros lenguajes de programaci\u00f3n.</p> <p>En Python las listas son muy versatiles permitiendo almacenar un conjunto arbitrario de datos. Es decir, podemos guardar en ellas lo que sea.</p> <p>Una lista se crea con <code>[]</code> y sus elementos se separan por comas. Una gran ventaja es que pueden tener datos de diferentes tipos.</p> <pre><code>lista = [1, \"Hola\", 3.141592, [1 , 2, 3], Image.HAPPY]\n</code></pre> <p>Algunas de las principales propiedades de las listas:</p> <ul> <li>Son ordenadas, mantienen el orden en el que han sido definidas</li> <li>Pueden ser formadas por tipos arbitrarios de datos</li> <li>Pueden ser indexadas con [i]</li> <li>Se pueden anidar, es decir, meter una lista dentro de otra</li> <li>Son mutables, ya que sus elementos pueden ser modificados</li> <li>Son din\u00e1micas, ya que se pueden a\u00f1adir o eliminar elementos</li> </ul> <p>Hay dos m\u00e9todos aplicables:</p> <ul> <li><code>append</code>. Permite agregar elementos a la lista.</li> <li><code>remove</code>. Elimina elementos de la lista.</li> <li><code>insert(pos,elem)</code>. Inserta el elemento <code>elem</code> en la posici\u00f3n <code>pos</code> indicada.</li> </ul> <p>En el ejemplo vemos el funcionamiento.</p> <p> <p> Ejemplo de listas y sus m\u00e9todos</p> <p></p>"},{"location":"guias/estr_datos/#trabajando-con-listas","title":"Trabajando con listas","text":"<p>Una vez que tenemos una lista creada sus elementos son accesibles para trabajar con ellos, modificarlos o incluso eliminar o a\u00f1adir elementos a la lista. Vamos a trabajar con un ejemplo sencillo para que se entienda mejor. </p> <ul> <li>Acceso por \u00edndice. Un programa como el siguiente:</li> </ul> <pre><code>lista = [1,2,\"texto\",2.87]\nprint(lista[0]) # indice 0 -&gt; valor =  1 entero\nprint(lista[2]) # indice 2 -&gt; valor = texto\nprint(lista[3]) # indice 3 -&gt; valor = 2.87 real\n</code></pre> <p>Nos devuelve en la consola:</p> <pre><code>1\ntexto\n2.87\n</code></pre> <p>Casos especiales de valores de \u00edndice son:</p> <pre><code>lista = [1,2,\"texto\",2.87]\nprint(lista[-1]) # ultimo elemento\nprint(lista[-2]) # penultimo elemento\nprint(lista[-3]) # antepenultimo elemento\nprint(lista[4]) # Error fuera de rango\n</code></pre> <p>Que da el siguiente resultado:</p> <pre><code>2.87\ntexto\n2\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 5, in &lt;module&gt;\nIndexError: list index out of range\n</code></pre> <ul> <li>Modificar elementos. Continuamos con el mismo ejemplo.</li> </ul> <pre><code>lista = [1,2,\"texto\",2.87]\nprint(lista)\nlista[2] = \"nuevo texto\" # cambio en elemento 2\nprint(lista)\ndel lista[1] # se elimina el elemento 1\nprint(lista)\n</code></pre> <p>Resultado:</p> <pre><code>[1, 2, 'texto', 2.87]\n[1, 2, 'nuevo texto', 2.87]\n[1, 'nuevo texto', 2.87]\n</code></pre> <ul> <li>Listas anidadas. Es posible crear dentro de otras listas e incluso dentro de otra lista. El acceso a los elementos consiste en utilizar tantos [] como anidados tengamos. Ejemplo de lista con tres niveles de anidado.</li> </ul> <pre><code>lista = [1,\"texto\",2,[22,\"pico\",45,'p'],[50,60]]\nprint(lista)\nprint(lista[1]) #texto\nprint(lista[3][0]) # 2lista\nprint(lista[3][-1]) # p\nprint(lista[4][0]) # 50\n</code></pre> <p>Resultado:</p> <pre><code>[1, 'texto', 2, [22, 'pico', 45, 'p'], [50, 60]]\ntexto\n22\np\n50\n</code></pre> <ul> <li>Sublistas. Son listas obtenidas a partir de otra de mayor tama\u00f1o. Se utiliza el operador dos puntos (:) entre corchetes dejando a la izquierda el valor de inicio y a la derecha el valor siguiente al final, dado que el \u00faltimo valor indicado no se incluye. Utilizando el concepto de sublista se pueden modificar varios valores de una sola vez. A continuaci\u00f3n vemos esto con un ejemplo.</li> </ul> <pre><code>lista = [1,\"texto\",2,3,4,'p']\nprint(lista)\nprint(lista[2:4]) # sublista [2,3]\nprint(lista[2:6]) # sublista [2,3,4,'p']\nlista[2:6]=[22,33,44,'pp'] # modificacion de multiples valores\nprint(lista)\n</code></pre> <p>Devuelve el siguiente resultado:</p> <pre><code>[1, 'texto', 2, 3, 4, 'p']\n[2, 3]\n[2, 3, 4, 'p']\n[1, 'texto', 22, 33, 44, 'pp']\n</code></pre> <ul> <li>otras funcionalidades. Se puede utilizar el operador suma (+) para a\u00f1adir elementos a una lista y el operador de asignaci\u00f3n (=) para asignar los valores de una lista a variables discretas. Veamos un ejemplo:</li> </ul> <pre><code>lista = [1,\"texto\",2,3,4,'p']\nlista += [20,30,\"otro texto\"]\nprint(lista)\na,b,c,d,e,f,g,h,i = lista\nprint(a,b,c,d,e,f,g,h,i)\n</code></pre> <p>Que devuelve lo siguiente:</p> <pre><code>[1, 'texto', 2, 3, 4, 'p', 20, 30, 'otro texto']\n1 texto 2 3 4 p 20 30 otro texto\n</code></pre>"},{"location":"guias/estr_datos/#iterar","title":"Iterar","text":"<p>Las listas se pueden iterar de diferentes formas, tal y como vemos a continuaci\u00f3n.</p> <ul> <li>Con \u00edndices. Se trata de recorrer la  lista utilizando los \u00edndices. Para ello se suele utilizar lafunci\u00f3n <code>len()</code>, que devuelve la longitud de la lista, y as\u00ed por ejemplo:</li> </ul> <pre><code>lista = [1,2,'texto',3]\n# iteramos toda la lista\nfor i in range(0, len(lista)):\n    print(lista[i])\n\nprint(\"------\")\n\n#iteramos parte de la lista\nfor i in range(2, len(lista)):\n    print(lista[i])\n</code></pre> <p>Nos mostrar\u00e1 en consola el siguiente resultado:</p> <pre><code>1\n2\ntexto\n3\n------\ntexto\n3\n</code></pre> <ul> <li>recorriendola. Se trata de recorrer la lista mostrando el valor de cada elemento de la misma. Por ejemplo:</li> </ul> <pre><code>lista = [1,2,'texto',3]\n# iteramos toda la lista\nfor indice in lista:\n    print(indice)\n# iteramos un elemento por su \u00edndice\nprint(lista[2])\n</code></pre> <p>Nos devuelve el siguiente resultado:</p> <pre><code>1\n2\ntexto\n3\ntexto\n</code></pre> <ul> <li>enumerando elementos. Se trata de mostrar tanto el \u00edndice como el valor. Como ejemplo hacemos:</li> </ul> <pre><code>lista = [1,2,'texto',3]\nfor indice,valor in enumerate(lista):\n    print(\"Elemento\", indice, \"=\", valor)\n</code></pre> <p>Que nos devuelve como resultado lo siguiente:</p> <pre><code>Elemento 0 = 1\nElemento 1 = 2\nElemento 2 = texto\nElemento 3 = 3\n</code></pre> <ul> <li>iterando varias listas a la vez. Un ejemplo que utiliza esta t\u00e9cnica es:</li> </ul> <pre><code>lista1 = [1,2,'tres',4]\nlista2 = [\"uno\",\"dos\",3,\"cuatro\"]\nfor v1,v2 in zip(lista1,lista2):\n    print(v1,v2)\n</code></pre> <p>Que devuelve el siguiente resultado:</p> <pre><code>1 uno\n2 dos\ntres 3\n4 cuatro\n</code></pre>"},{"location":"guias/estr_datos/#las-tuplas-tuple","title":"Las tuplas (tuple)","text":"<p>Son muy similares a las listas con una diferencia principal con las mismas y es que las tuplas no pueden ser modificadas directamente, lo que implica que no dispone de los m\u00e9todos vistos para listas. Una tupla permite tener agrupados un n\u00famero inmutable de elementos. Cuando decimos inmutable significa que no pueden ser modificadas una vez declaradas.</p> <p>Una tupla se inicializa con <code>()</code> en lugar de los corchetes y sus elementos se separan por comas. Los par\u00e9ntesis se pueden omitir y dejar los elementos simplemente separados por comas.</p> <pre><code>tupla = (1, 2, 3)\nprint(tupla)\n</code></pre> <p>Principales propiedades:</p> <ul> <li>Se pueden declarar sin usar los par\u00e9ntesis, pero no se recomienda. No usarlos puede llevarnos a ambig\u00fcedades del tipo print(1, 2, 3) y print((1, 2, 3)).</li> <li>Si la tupla tiene un solo elemento esta debe finalizar con coma.</li> <li>Se pueden anidar tuplas, por ejemplo <code>tupla2 = tupla1, 4, 5, 6, 7</code>.</li> <li>Se pueden declarar tuplas vacias, por ejemplo <code>tupla3 = ()</code>.</li> <li>Las tuplas son iterables por lo que sus elementos pueden ser accesados mediante la notaci\u00f3n de \u00edndice del elemento entre corchetes. Si se quiere acceder a un rango de indices se separan por \":\" ambos \u00edndices.</li> <li>Es posible convertir listas en tuplas simplemente poniendo la lista dentro de los par\u00e9ntesis de la tupla, por ejemplo:</li> </ul> <p><code>tupla_lista = ([1, \"Hola\", 3.141592, [1 , 2, 3]])</code></p> <p>A continuaci\u00f3n vemos la imagen de un ejemplo donde se explica todo lo anterior.</p> <p> <p> Ejemplo de tuplas</p> <p></p> <p>Existen dos m\u00e9todos aplicables a las tuplas:</p> <ul> <li><code>count()</code>. Se utiliza para contar el n\u00famero de veces que el objeto que le pasamos como par\u00e1metro se encuentra en la tupla.</li> </ul> <pre><code>tupla = (1,2,'tres',4, 1,1,1,2,'tres')\nprint(tupla.count(1))\nprint(tupla.count(2))\nprint(tupla.count('tres'))\n</code></pre> <p>Resultado:</p> <pre><code>4\n2\n2\n</code></pre> <ul> <li><code>index()</code>. Localiza y devuelve el \u00edndice del objeto pasado como par\u00e1metro. Si no encuentra nada devuelve un error. Este m\u00e9todo acepta un segundo par\u00e1metro que permite indicar a partir de que elemento se comienza a buscar el objeto.</li> </ul> <pre><code>tupla = (1,2,'tres',4, 1,1,1,2,'tres')\nprint(tupla.index(4)) # el indice del 4 es 3\nprint(tupla.index(2)) # primera aparicion del 2 en indice 1\nprint(tupla.index(2,2)) # aparicion del 2 tras la posicion 2\nprint(tupla.index(3)) # elemento no existente genera Error\n</code></pre> <p>Resultado:</p> <pre><code>3\n1\n7\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 5, in &lt;module&gt;\nValueError: object not in sequence\n</code></pre>"},{"location":"guias/estr_datos/#diccionarios-dict","title":"Diccionarios (dict)","text":"<p>Estas estructuras contienen la colecci\u00f3n de elementos con la forma <code>clave:valor</code> separados por comas y encerrados entre <code>{}</code>. Las claves son objetos inmutables y los valores pueden ser de cualquier tipo. Sus principales caracter\u00edsticas son:</p> <ul> <li>En lugar de por \u00edndice como en listas y tuplas, en diccionarios se acceder al valor por su clave.</li> <li>Permiten eliminar cualquier entrada.</li> <li>Al igual que las listas, el diccionario permite modificar los valores.</li> <li>El m\u00e9todo <code>dicc.get()</code> accede a un valor por la clave del mismo.</li> <li>El m\u00e9todo <code>dicc.items()</code> devuelve una lista de tuplas <code>clave:valor</code>.</li> <li>El m\u00e9todo <code>dicc.keys()</code> devuelve una lista de las claves.</li> <li>El m\u00e9todo <code>dicc.values()</code> devuelve una lista de los valores.</li> <li>El m\u00e9todo <code>dicc.update()</code> a\u00f1ade elemento <code>clave:valor</code> al diccionario.</li> <li>El m\u00e9todo <code>del dicc</code> borra el par <code>clave:valor</code>.</li> <li>El m\u00e9todo <code>dicc.pop()</code> borra el par <code>clave:valor</code>.</li> </ul> <p>A continuaci\u00f3n vemos un ejemplo.</p> <p> <p> Ejemplo de diccionario</p> <p></p> <p>En diccionarios tenemos disponibles los siguiente m\u00e9todos:</p> <ul> <li><code>clear()</code>. Vac\u00eda el diccionario eliminando todos sus elementos.</li> </ul> <pre><code>dicc = {'Ana':40,'Juan':42,'Laura':36,'Isa':30}\nprint(dicc)\ndicc.clear()\nprint(dicc)\n</code></pre> <p>Resultado:</p> <pre><code>{'Isa': 30, 'Juan': 42, 'Laura': 36, 'Ana': 40}\n{}\n</code></pre> <ul> <li><code>copy()</code>. Copia un diccionario.</li> </ul> <pre><code>dicc = {'Ana':40,'Juan':42,'Laura':36,'Isa':30}\ndicc_copia = dicc.copy()\nprint(dicc_copia)\n</code></pre> <p>Resultado:</p> <pre><code>{'Isa': 30, 'Juan': 42, 'Laura': 36, 'Ana': 40}\n</code></pre> <ul> <li><code>fromkeys()</code>. Retorna un diccionario con las claves y el valor indicados. Es decir, el m\u00e9todo <code>fromkeys()</code> se utiliza en diccionarios para crear un nuevo diccionario a partir de una relaci\u00f3n de claves. De manera opcional se puede especificar un valor.</li> </ul> <pre><code>dicc = {'Ana':40,'Juan':42,'Laura':36,'Isa':30}\nnuevo_dicc = dicc.fromkeys(dicc)\nprint(nuevo_dicc)\n</code></pre> <p>Resultado:</p> <pre><code>{'Ana': None, 'Juan': None, 'Isa': None, 'Laura': None}\n</code></pre> <ul> <li><code>get()</code>. Retorna el valor de la clave indicada. La ventaja de usar <code>get()</code> en lugar del acceso gen\u00e9rico por clave es que con <code>get()</code> no se genera una excepci\u00f3n KeyError si la clave no existe ya que devuelve un valor predeterminado. Si no indicamos un valor predeterminado devulve <code>None</code>.</li> </ul> <pre><code>dicc = {'Ana':40,'Juan':42,'Laura':36,'Isa':30}\nclave1 = dicc.get('Ana')\nclave2 = dicc.get('Isabel')\nclave3 = dicc.get('Isa', \"No existe\")\nclave4 = dicc.get('Isabel', \"No existe\")\n\nprint(clave1,clave2,clave3,clave4)\n</code></pre> <p>Resultado:</p> <pre><code>40 None 30 No existe\n</code></pre> <ul> <li><code>items()</code>. Retorna una lista con una tupla por cada par de elementos.</li> </ul> <pre><code>dicc = {'Ana':40,'Juan':42,'Laura':36,'Isa':30}\nclave = dicc.items()\ndicc['Ana']=38 # modificamos la clave 'Ana'\nprint(clave)\n</code></pre> <p>Resultado:</p> <pre><code>dict_items([('Isa', 30), ('Juan', 42), ('Laura', 36), ('Ana', 38)])\n</code></pre> <ul> <li><code>keys()</code>. Retorna una lista con las claves del diccionario.</li> </ul> <pre><code>dicc = {'Ana':40,'Juan':42,'Laura':36,'Isa':30}\nclave = dicc.keys()\nprint(clave)\n</code></pre> <p>Resultado:</p> <pre><code>dict_keys(['Isa', 'Juan', 'Laura', 'Ana'])\n</code></pre> <ul> <li><code>pop()</code>. Elimina el elemento con la clave indicada y devuelve el valor asociado a esa clave.</li> </ul> <pre><code>dicc = {'Ana':40,'Juan':42,'Laura':36,'Isa':30}\nclave_elminada = dicc.pop('Ana',\"No existe\") # elimina clave 'Ana'\nprint(dicc)\nprint(clave_elminada)\n</code></pre> <p>Resultado:</p> <pre><code>{'Isa': 30, 'Juan': 42, 'Laura': 36}\n40\n</code></pre> <ul> <li><code>popitem()</code>. Elimina el \u00faltimo par de clave-valor introducido. Se utiliza para eliminar y devolver un par clave/valor aleatorio.</li> </ul> <pre><code>dicc = {'Ana':40,'Juan':42,'Laura':36,'Isabel':60,'Puri':50}\npar_elminado = dicc.popitem() # elimina y obtiene par clave/valor aleatorio\nprint(\"El par clave/valor eliminado es:\",par_elminado)\nprint(\"El diccionario queda asi:\",dicc)\n</code></pre> <p>Resultado:</p> <pre><code>El par clave/valor eliminado es: ('Isabel', 60)\nEl diccionario queda asi: {'Laura': 36, 'Puri': 50, 'Ana': 40, 'Juan': 42}\n</code></pre> <ul> <li><code>setdefault()</code>. Retorna el valor de la clave indicada. Si la clave no existe la inserta con el valor indicado. Si la clave existe, el m\u00e9todo retorna el valor de esa clave sin realizar cambios en el diccionario.</li> </ul> <pre><code>dicc = {'Ana':40,'Juan':42,'Laura':36,'Isabel':60,'Puri':50}\npuri_edad = dicc.setdefault('Puri', 20)\nemilia_edad = dicc.setdefault('Emilia',15)\nprint(\"Edad de Puri:\",puri_edad)\nprint(dicc)\n</code></pre> <p>Resultado:</p> <pre><code>Edad de Puri: 50\n{'Juan': 42, 'Puri': 50, 'Laura': 36, 'Ana': 40, 'Emilia': 15, 'Isabel': 60}\n</code></pre> <ul> <li><code>update()</code>. Actualiza el diccionario con los pares clave-valor indicados. Se utiliza para actualizar o modificar un diccionario con una secuencia de pares clave/valor o bien con otro diccionario. Los pares clave/valor se agregan o actualizan  si ya existen.</li> </ul> <pre><code>dicc = {'Ana':40,'Juan':42,'Laura':36,'Isabel':60,'Puri':50}\ndicc.update({'Puri':55,'Juan':45})\nprint(dicc)\n</code></pre> <p>Resultado:</p> <pre><code>{'Isabel': 60, 'Laura': 36, 'Puri': 55, 'Ana': 40, 'Juan': 45}\n</code></pre>"},{"location":"guias/estr_datos/#iterar_1","title":"Iterar","text":"<p>Los diccionarios se pueden iterar de forma similar a las listas. En el ejemplo vemos como hacerlo.</p> <pre><code>dicc = {'Ana':40,'Juan':42,'Laura':36,'Isabel':60,'Puri':50}\nfor i in dicc:\n    print(i) # imprime las claves\nprint(\"-------------------------\")\nfor j in dicc:\n    print(dicc[j]) # imprime los valores de las claves\nprint(\"-------------------------\")\nfor k,l in dicc.items():\n    print(k,\":\",l) # imprime los pares clave/valor\n</code></pre> <p>Que arroja el siguiente resultado:</p> <pre><code>Isabel\nLaura\nPuri\nAna\nJuan\n------------------------\n60\n36\n50\n40\n42\n------------------------\nIsabel : 60\nLaura : 36\nPuri : 50\nAna : 40\nJuan : 42\n</code></pre>"},{"location":"guias/estr_datos/#set-o-conjuntos","title":"Set o conjuntos","text":"<p>Se trata de una estructura que se utiliza para almacenar datos de manera similar a las listas pero con las siguientes diferencias:</p> <ul> <li>En un <code>set</code> los elementos son \u00fanicos no pudiendo existir duplicados.</li> <li>Los <code>set</code> no mantienen un orden en sus elementos de cuando son declarados a cuando se trabaja con ellos.</li> <li>Los elementos de un <code>set</code> son inmutables.</li> <li>Los <code>set</code> se iteran de la misma forma que las listas.</li> </ul> <p>La forma de crear un <code>set</code> en Python es:</p> <pre><code>conjunto = {2,5,7,4,1} # forma simplificada\n</code></pre>"},{"location":"guias/estr_datos/#operaciones-con-conjuntos","title":"Operaciones con conjuntos","text":"<p>Como conjuntos que son permiten realizar diferentes operaciones que vamos a mostrar a partir del ejemplo siguiente:</p> <pre><code>set1 = {0,1,2,3,4,5}\nset2 = {3,4,5,6,7,8}\n# uni\u00f3n\nunion = set1.union(set2)\nprint(union)\n# interseccion\ninter = set1.intersection(set2)\nprint(inter)\n# diferencia\ndif = set1.difference(set2)\nprint(dif)\n# agregar elementos\nset1.add(6)\nprint(set1)\n# elminar elementos\nset1.remove(6)\nprint(set1)\n</code></pre> <p>El resultado de estas operaciones es:</p> <pre><code>{0, 1, 2, 3, 4, 5, 6, 7, 8}\n{4, 5, 3}\n{0, 1, 2}\n{0, 1, 2, 3, 4, 5, 6}\n{0, 1, 2, 3, 4, 5}\n</code></pre>"},{"location":"guias/estr_datos/#metodos","title":"M\u00e9todos","text":"<p>Los conjuntos tienen disponibles los siguientes m\u00e9todos:</p> <ul> <li>add(). Agrega un elemento al conjunto.</li> <li>clear(). Elimina todos los elementos de un conjunto.</li> <li>copy(). Retorna una copia del conjunto.</li> <li>difference(). Retorna un conjunto que es la diferencia entre dos o m\u00e1s conjuntos.</li> <li>difference_update(). Elimina los elementos de un conjunto est\u00e1n incluidos en otro conjunto especificado.</li> <li>discard(). Elimina el elemento especificado.</li> <li>intersection(). Retorna el conjunto intersecci\u00f3n de dos o m\u00e1s conjuntos.</li> <li>intersection_update(). Elimina los elementos de un conjunto que no est\u00e1n presentes en otros conjuntos especificados.</li> <li>isdisjoint(). Retorna si dos conjuntos tienen una intersecci\u00f3n o no.</li> <li>issubset(). Retorna si otro conjunto contiene a este conjunto o no.</li> <li>issuperset(). Retorna si este conjunto contiene otro conjunto o no.</li> <li>pop() Elimina un elemento del conjunto.</li> <li>remove(). Elimina el elemento especificado.</li> <li>symmetric_difference(). Retorna un conjunto con las diferencias sim\u00e9tricas de dos conjuntos.</li> <li>symmetric_difference_update(). Inserta las diferencias sim\u00e9tricas de este conjunto y otro conjunto.</li> <li>union(). Retorna el conjunto uni\u00f3n de conjuntos.</li> <li>update(). Actualiza el conjunto con otro conjunto, o cualquier otro dato iterable.</li> </ul>"},{"location":"guias/estr_datos/#casting","title":"Casting","text":"<p>Hacer casting es convertir de un tipo de dato a otro. Es decir, podemos convertir los tipos <code>int</code>, <code>float</code> o <code>string</code> de uno a otro.</p> <p>En Python existen dos tipos de cast:</p> <ul> <li>Implicita. Es la que realiza Python cuando tiene que trabjar con dos tipos distintos de datos. Se realiza de manera autom\u00e1tica sin que intervengamos, pero es importante saber lo que est\u00e1 pasando realmente si no queremos tener problemas futuros. Vamos a ver un ejemplo en el que tenemos dos tipos de datos, uno <code>int</code> y otro <code>float</code> y operamos con ellos.</li> </ul> <pre><code>entero = 5\nreal = 3.5\nsuma = entero + real\ndiferencia = entero - real\nproducto = entero * real\nprint(\"La suma es:\", suma)\nprint(\"La diferencia es:\",diferencia)\nprint(\"El producto es:\",producto)\ncadena =\"2\"\ncociente = entero / cadena\n</code></pre> <p>El resultado es:</p> <pre><code>La suma es: 8.5\nLa diferencia es: 1.5\nEl producto es: 17.5\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 10, in &lt;module&gt;\nTypeError: unsupported types for __truediv__: 'int', 'str'\n</code></pre> <p>El error se produce porque es evidente que no se puede dividir un n\u00famero por la cadena \"2\". Imagenemos que en lugar de \"2\" la cadena fuese \"Hola mundo!\" \u00bfcomo vamos a realizar esa divisi\u00f3n?.</p> <p>Es evidente entonces que Python realiza un <code>cast()</code> de forma autom\u00e1tica si los datos son congruentes entre si.</p> <ul> <li>Explicita. Es la que realizamos nosotros y se  puede realizar a partir de las funciones que tiene Python. Las funciones mas comunes para hacer <code>cast()</code> son las siguientes:</li> </ul> <ul> <li>float()</li> <li>str()</li> <li>int()</li> <li>list()</li> <li>set()</li> <li>hex()</li> <li>oct()</li> <li>bin()</li> </ul>"},{"location":"guias/estr_datos/#conversion-float-a-int","title":"Conversion <code>float</code> a <code>int</code>","text":"<p>Para convertir un <code>float</code> en un <code>int</code> basta con utilizar la funci\u00f3n <code>int()</code> teniendo en cuenta que perderemos la parte fraccionaria del n\u00famero.</p> <pre><code>x = 3.45\ny = int(x) # y toma el valor 3 desapareciendo el 0.45\nprint(y) # da como resultado 3\n</code></pre>"},{"location":"guias/estr_datos/#conversion-float-a-string","title":"Conversion <code>float</code> a <code>string</code>","text":"<p>Para convertir un <code>float</code> en un <code>string</code> vamos a utilizar la funci\u00f3n <code>str()</code>. En el ejemplo como hacerlo con un dato mediante <code>casting</code>:</p> <pre><code>x = 5.5 # tipo float\nprint(type(x)) # da como salida &lt;class 'float'&gt;\nx = str(x) # casting de x y lo guardamos en x\nprint(type(x)) # da como salida &lt;class 'str'&gt;\n</code></pre>"},{"location":"guias/estr_datos/#conversion-string-a-float","title":"Conversion <code>string</code> a <code>float</code>","text":"<p>Se puede convertir una cadena num\u00e9rica en un float utilizando <code>float()</code>. Es importante entender que se pueden convertir cadenas que tengan sentido num\u00e9rico y no cualquier cadena. En el ejemplo vemos la conversi\u00f3n correcta y la incorrecta que genera un error.</p> <pre><code>cadena = \"5.5\"\nx = 2\ny = 0.0 # siempre hay que usar punto como separador decimal\ncadena2 = \"Hola\"\ny = float(cadena) # cast de cadena\nx = y/x # operamos entre cast de cadena y numero\nprint(x)\nprint(float(cadena2)) # conversion imposible\n</code></pre> <p>Nos genera el siguiente resultado:</p> <pre><code>2.75\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 8, in &lt;module&gt;\nValueError: invalid syntax for number\n</code></pre>"},{"location":"guias/estr_datos/#conversion-string-a-int","title":"Conversion <code>string</code> a <code>int</code>","text":"<p>Totalmente similar a la conversi\u00f3n de <code>string</code> a <code>float</code> utilizando la funci\u00f3n <code>int()</code>. Un ejemplo similar nos lo aclara mejor:</p> <pre><code>cadena = \"5\"\nx = 2\ny = 0\ncadena2 = \"Hola\"\ny = int(cadena) # cast de cadena\nx = y/x # operamos entre cast de cadena y numero\nprint(x) # resultado float por cast implicito\nprint(int(cadena2)) # conversion imposible\n</code></pre> <p>Que nos devuelve el siguiente resultado:</p> <pre><code>2.5\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 8, in &lt;module&gt;\nValueError: invalid syntax for integer with base 10\n</code></pre>"},{"location":"guias/estr_datos/#conversion-int-a-string","title":"Conversion <code>int</code> a <code>string</code>","text":"<p>Esta conversi\u00f3n se realiza con str(). Es una conversi\u00f3n que siempre es realizable porque cualquier n\u00famero entero es susceptible de convertirse en una cadena.</p> <pre><code>x = 5 # tipo int\nprint(type(x)) # da como salida &lt;class 'int'&gt;\nx = str(x) # casting de x y lo guardamos en x\nprint(type(x)) # da como salida &lt;class 'str'&gt;\n</code></pre>"},{"location":"guias/estr_datos/#conversion-entre-list-y-set","title":"Conversion entre <code>list</code> y <code>set</code>","text":"<p>Es posibles hacer cast a lista con list(). Por ejemplo:</p> <pre><code>set1 = {0,1,2,3,4,5}\nlista = list(set1)\nprint(set1, type(set1))\nprint(lista, type(lista))\n</code></pre> <p>Resultado:</p> <pre><code>{0, 1, 2, 3, 4, 5} &lt;class 'set'&gt;\n[0, 1, 2, 3, 4, 5] &lt;class 'list'&gt;\n</code></pre> <p>De manera similar es posible convertir unalista en un set utilizando <code>set()</code>. Por ejemplo</p> <pre><code>lista = [0,1,2,3,4,5]\nset1 = set(lista)\nprint(lista, type(lista))\nprint(set1, type(set1))\n</code></pre> <p>Resultado:</p> <pre><code>[0, 1, 2, 3, 4, 5] &lt;class 'list'&gt;\n{0, 1, 2, 3, 4, 5} &lt;class 'set'&gt;\n</code></pre>"},{"location":"guias/intro/","title":"Introducci\u00f3n a Python","text":""},{"location":"guias/intro/#que-es-python-y-de-donde-viene","title":"\u00bfQue es Python y de donde viene?","text":"<p>Una breve introducci\u00f3n a cosas de Python que nos pueden ayudar con la gu\u00eda de MicroPython. Al final se trata el asunto de los permisos en Linux, que aunque sea un poco \"off topic\" puede resultar \u00fatil.</p>"},{"location":"guias/intro/#creador-de-python","title":"Creador de Python","text":"<p>Python es un lenguaje de programaci\u00f3n interpretado (no hay que compilar los programas) cuya filosof\u00eda hace hincapi\u00e9 en una sintaxis que favorezca un c\u00f3digo legible.</p> <p>Python fue creado a finales de los ochenta, por el holand\u00e9s Guido van Rossum en el Centro para las Matem\u00e1ticas y la Inform\u00e1tica (CWI, Centrum Wiskunde &amp; Informatica), en los Pa\u00edses Bajos.</p> <p>El nombre del lenguaje proviene de la afici\u00f3n de su creador por los humoristas brit\u00e1nicos Monty Python y no de la serpiente del mismo nombre. Aunque se suele usar un s\u00edmbolo con una serpiente pit\u00f3n para representarlo, de ah\u00ed la normal confusi\u00f3n.</p> <p>Se trata de un lenguaje de programaci\u00f3n multiparadigma o que soporta m\u00e1s de un paradigma de programaci\u00f3n, representando un paradigma un enfoque particular o filosof\u00eda para la construcci\u00f3n del software. Python soporta:</p> <ul> <li>Orientaci\u00f3n a objetos. En la programaci\u00f3n orientada a objetos (OOP) los objetos manipulan los datos de entrada para la obtenci\u00f3n de datos de salida espec\u00edficos, donde cada objeto ofrece una funcionalidad especial. Los objetos permiten la agrupaci\u00f3n en librer\u00edas y usualmente permiten al usuario la creaci\u00f3n de sus propias librer\u00edas. Se basa en t\u00e9cnicas de herencia, cohesi\u00f3n, abstracci\u00f3n, polimorfismo, acoplamiento y encapsulamiento.</li> <li>Programaci\u00f3n imperativa. Es la forma natural de programar un ordenador, es el estilo de programaci\u00f3n que se utiliza en el ensamblador y el m\u00e1s cercano a la m\u00e1quina. Sigue la arquitectura arquitectura cl\u00e1sica de Von Newmann con una memoria donde se almacenan los datos y el programa y una unidad de control que ejecuta las instrucciones del programa, conocida c\u00f3mo contador del programa.</li> <li>Programaci\u00f3n funcional. Es un estilo de programaci\u00f3n cuyo m\u00e9todo b\u00e1sico de computaci\u00f3n es la aplicaci\u00f3n de funciones a sus argumentos.</li> </ul>"},{"location":"guias/intro/#filosofia-python","title":"Filosof\u00eda Python","text":"<p>Es muy parecida a la filosof\u00eda de Unix. El c\u00f3digo que sigue los principios de Python de legibilidad y transparencia se dice que es \"pythonic\". Por el contrario, el c\u00f3digo opaco u ofuscado es bautizado como \"unpythonic\". Los puntos que describen su filosofia son:</p> <ul> <li>Bello es mejor que feo.</li> <li>Expl\u00edcito es mejor que impl\u00edcito.</li> <li>Simple es mejor que complejo.</li> <li>Complejo es mejor que complicado.</li> <li>Plano es mejor que anidado.</li> <li>Disperso es mejor que denso.</li> <li>La legibilidad cuenta.</li> <li>Los casos especiales no son tan especiales como para quebrantar las reglas.</li> <li>Lo pr\u00e1ctico gana a lo puro.</li> <li>Los errores nunca deber\u00edan dejarse pasar silenciosamente.</li> <li>A menos que hayan sido silenciados expl\u00edcitamente.</li> <li>Frente a la ambig\u00fcedad, rechaza la tentaci\u00f3n de adivinar.</li> <li>Deber\u00eda haber una -y preferiblemente s\u00f3lo una- manera obvia de hacerlo.</li> <li>Aunque esa manera puede no ser obvia al principio a menos que usted sea holand\u00e9s (en clara referencia a su autor).</li> <li>Ahora es mejor que nunca.</li> <li>Aunque nunca es a menudo mejor que ya mismo.</li> <li>Si la implementaci\u00f3n es dif\u00edcil de explicar, es una mala idea.</li> <li>Si la implementaci\u00f3n es f\u00e1cil de explicar, puede que sea una buena idea.</li> <li>Los espacios de nombres (namespaces) son una gran idea \u00a1Hagamos m\u00e1s de esas cosas!</li> </ul> <p>El Zen de Python viene incorporado (en ingl\u00e9s) a partir de la versi\u00f3n 2.1.2 y podemos invocarlo con <code>import this</code> abriendo Python en una terminal en un sistema en el que lo tengamos instalado, l\u00f3gicamente.</p> <p> <p> Arrastrar y soltar un fragmento de c\u00f3digo</p> <p></p>"},{"location":"guias/modulos/","title":"M\u00f3dulos en Python","text":"<p>Antes de nada decir que vamos a realizar una pasada bastante r\u00e1pida por el tema y que no es ni mucho menos todo lo que hay que decir sobre los m\u00f3dulos, los paquetes y las librer\u00edas, el tema es mas complejo, pero dada la utilidad que nosotros le vamos a dar, entiendo que con esto ser\u00e1 suficiente. Si se necesita se puede consultar la documentaci\u00f3n de Python en espa\u00f1ol y en concreto la de m\u00f3dulos.</p>"},{"location":"guias/modulos/#introduccion","title":"Introducci\u00f3n","text":"<p>Los m\u00f3dulos con archivos .py que pueden contiener funciones, variables o clases y que se pueden usar por otros m\u00f3dulos. Fundamentalmente sirven para reutilizar c\u00f3digo. Vamos a analizar su funcionamiento en base a un ejemplo muy sencillo en el que definimos un m\u00f3dulo para sumar, restar, multiplicar y dividir dos n\u00fameros x e y.</p> <p>El m\u00f3dulo ser\u00eda:</p> <pre><code>def suma(x, y):\n    return x + y\ndef resta(x, y):\n    return x - y\ndef producto(x, y):\n    return x * y\ndef division(x, y):\n    return x/y\n</code></pre> <p>Podemos observar que se han definido las funciones necesarias para realizar las operaciones citadas y retornas el resultado. Este m\u00f3dulo por si solo no hace nada pues no puede retornar valores si no recibe par\u00e1metros.</p> <p>Vamos a implementar ahora un programa que utilice este m\u00f3dulo, ser\u00eda:</p> <pre><code>import modulo_tonto\n\nprint(modulo_tonto.suma(5, 5))\nprint(modulo_tonto.resta(5, 5))\nprint(modulo_tonto.producto(5, 5))\nprint(modulo_tonto.division(5, 5))\n</code></pre> <p>Pero ATENCI\u00d3N, la situaci\u00f3n que debemos tener en Thonny es la de la siguiente imagen:</p> <p> <p> Situaci\u00f3n en  Thonny para importar m\u00f3dulos</p> <p></p> <p>Recuerdese que para subir archivos a la Pi Pico basta con hacer clic derecho sobre el nombre del archivo y escoger Subir a  / del men\u00fa contextual.</p> <p>La importaci\u00f3n del m\u00f3dulo se puede realizar tambi\u00e9n de la siguiente forma:</p> <pre><code>from modulo_tonto import *\n\nprint(suma(5, 5))\nprint(resta(5, 5))\nprint(producto(5, 5))\nprint(division(5, 5))\n</code></pre> <p>Donde observamos queahora las funciones se invocan directamente y no a trav\u00e9s del nombre del m\u00f3dulo. El resultado de la salida es exactamente el mismo que antes.</p> <p>Tambi\u00e9n es posible importa solamente ciertos componentes, tal y como vemos a continuaci\u00f3n:</p> <pre><code>from modulo_tonto import suma, producto\n\nprint(suma(5, 5))\nprint(producto(5, 5))\nprint(division(5, 5))\n</code></pre> <p>Que nos genera la siguiente salida:</p> <pre><code>10\n25\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 5, in &lt;module&gt;\nNameError: name 'division' isn't defined\n</code></pre> <p>El error es evidentemente porque, aunque la funci\u00f3n est\u00e1 definida en el m\u00f3dulo, esta no se ha importado y no es posible invocarla.</p> <p>Cuando importamos un m\u00f3dulo es posible cambiarle el nombre de forma sencilla. Por ejemplo:</p> <pre><code>import modulos.modulo_tonto as mt\n\nprint(mt.suma(5, 5))\nprint(mt.resta(5, 5))\nprint(mt.producto(5, 5))\nprint(mt.division(5, 5))\n</code></pre>"},{"location":"guias/modulos/#directorios-y-sus-rutas","title":"Directorios y sus rutas","text":"<p>Como hemos visto en los ejemplos anteriores es habitual que los m\u00f3dulos est\u00e9n situados en el mismo directorio que el archivo de proyecto, pero cuando se trabaja con programas mas extensos que usan varios m\u00f3dulos y archivos auxiliares, lo mas comodo va a ser tenerlo organizados por directorios.</p> <p>Aunque por su sencillez no es necesario, lo vamos a hacer con el ejemplo anterior. Si partimos de la situaci\u00f3n de la imagen inicial de la animaci\u00f3n siguiente se nos producir\u00e1 un error al intentar ejecutar el programa.</p> <p> <p> Situaci\u00f3n en Thonny con m\u00f3dulo en directorio</p> <p></p> <p>En la misma animaci\u00f3n se ve como acceder al directorio del m\u00f3dulo y solucionar el problema anterior.</p> <p>Es importante conocer la forma en que Python busca los m\u00f3dulos. Inicialmente, cuando se importa un m\u00f3dulo, Python intenta buscar en los directorios indicados en el archivo <code>sys.path</code>. Con un sencillo programa es posible consultar <code>sys.path</code>:</p> <pre><code>import sys\nprint(sys.path)\n</code></pre> <p>Que nos devolver\u00e1 una lista de los directorios y el orden en que buscar\u00e1.</p> <p>Al tratarse de un fichero de sistema no se recomienda su modificaci\u00f3n porque podemos estropear algo sin querer.</p> <p>Es posible ver lon nombres de variables, funciones, clases, etc que est\u00e1n en nuestro <code>namespace</code> mediante la funci\u00f3n <code>dir()</code>:</p> <ul> <li>Sobre un m\u00f3dulo vacio veremos los nombres por defecto que ha generado Python:</li> </ul> <pre><code>print(dir())\n</code></pre> <p>La lista que devuelve es <code>['machine', 'cppmem', '__name__', 'rp2']</code>.</p> <p>Si hacemos la consulta en un programa como el del ejemplo que llevamos viendo devolver\u00e1 algo como:</p> <p><code>['machine', 'producto', '__name__', 'cppmem', 'division', 'rp2', 'resta', 'suma']</code></p> <p>Donde podemos apreciar como aparecen tambi\u00e9n las funciones creadas por nosotros.</p>"},{"location":"guias/modulos/#modulos-personalizados","title":"M\u00f3dulos personalizados","text":"<p>Cada archivo con extensi\u00f3n .py, si est\u00e1 almacenado en el sistema de archivos de Raspberry Pi Pico, es un m\u00f3dulo. Si queremos importar un m\u00f3dulo personalizado su archivo debe estar ubicado en la ruta de la variable de entorno de MicroPython o en la misma ruta que el programa que est\u00e1 en ejecuci\u00f3n.</p> <p>Vamos a ver un ejemplo trabajando con la funci\u00f3n <code>main()</code>. </p> <ul> <li>Primero, creamos un m\u00f3dulo python \"aleatorio_0_99.py\" en un directorio que denominaremos \"mi_funcion\" y le escribimos el siguiente c\u00f3digo:</li> </ul> <pre><code>import random\n\ndef aleatorio():\n    num_aleatorio = random.randint(0, 100)\n    return num_aleatorio\n</code></pre> <p>Una vez acabado de escribir el c\u00f3digo subimos el m\u00f3dulo a la Pi Pico.</p> <ul> <li>Segundo, creamos un nuevo archivo de nombre \"main.py\", importamos el m\u00f3dulo anterior y escribimos el siguiente c\u00f3digo:</li> </ul> <pre><code>import aleatorio_0_99\nimport time\n\nwhile True:\n    print(aleatorio_0_99.aleatorio())\n    time.sleep(3)\n</code></pre> <p>En la animaci\u00f3n vemos su funcionamiento generando un n\u00famero aleatorio cada tres segundos. Al tener un archivo <code>main.py</code> en la Pi Pico el programa se ejecutar\u00e1 con solo alimentar la misma sin necesidad de estar conectado a un ordenador.</p> <p> <p> Ejemplo de generaci\u00f3n de aleatorios</p> <p></p>"},{"location":"guias/operaradores/","title":"Operadores en Python","text":"<p>Los operadores son s\u00edmbolos especiales que realizan operaciones con variables y valores.</p> <p>A continuaci\u00f3n tenemos una lista de los diferentes tipos de operadores de Python:</p> <ul> <li>Operadores aritm\u00e9ticos</li> <li>Operadores de asignaci\u00f3n</li> <li>Operadores de Comparaci\u00f3n</li> <li>Operadores L\u00f3gicos</li> <li>Operadores Bitwise</li> <li>Operadores especiales</li> </ul>"},{"location":"guias/operaradores/#operadores-aritmeticos","title":"Operadores aritm\u00e9ticos","text":"<p>Los operadores aritm\u00e9ticos se utilizan para realizar operaciones matem\u00e1ticas como sumas, restas, multiplicaciones, etc.</p> <p> Operador Descripci\u00f3n Ejemplo + Suma o concatenaci\u00f3n en textos <code>5+3=8</code>, <code>\"Hola\" + \"Mundo\" = \"Hola Mundo</code> - Diferencia <code>6-3=3</code> * Multiplicaci\u00f3n <code>3*3=9</code> / Divisi\u00f3n <code>6/2=3</code> // Parte entera de un cociente <code>10//3=3</code> % Resto de un cociente <code>10%3=1</code> ** Potenciaci\u00f3n <code>5**2=25</code> <p></p>"},{"location":"guias/operaradores/#operadores-de-asignacion","title":"Operadores de asignaci\u00f3n","text":"<p>Los operadores de asignaci\u00f3n se utilizan para asignar valores a variables.</p> <p> Operador Descripci\u00f3n Ejemplo = Asignaci\u00f3n <code>x=4</code>, <code>a = a + 1</code> += Suma y asignaci\u00f3n <code>x+=1</code> equivale a <code>x = x + 1</code> -= Diferencia y asignaci\u00f3n <code>x-=1</code> equivale a <code>x = x - 1</code> *= Multiplicaci\u00f3n y asignaci\u00f3n <code>x*=3</code> equivale a <code>x = x * 3</code> /= Divisi\u00f3n y asignaci\u00f3n <code>x/=3</code> equivale a <code>x = x / 3</code> %= Asignaci\u00f3n de restos <code>x%=3</code> equivale a <code>x = x % 3</code> **= Asignaci\u00f3n de exponentes <code>x**=3</code> equivale a <code>x = x ** 3</code> <p></p>"},{"location":"guias/operaradores/#operadores-de-comparacion","title":"Operadores de Comparaci\u00f3n","text":"<p>Los operadores de comparaci\u00f3n comparan dos valores/variables y devuelven un resultado booleano: Verdadero o Falso <code>True</code> o <code>False</code>.</p> <p> Operador Descripci\u00f3n Ejemplo == Igual a <code>2==3</code> retorna <code>False</code> != Distinto de <code>2!=3</code> retorna <code>True</code> &lt; Menor que <code>2&lt;3</code> retorna <code>True</code> &gt; Mayor que <code>2&gt;3</code> retorna <code>False</code> &lt;= Menor o igual que <code>2&lt;=3</code> retorna <code>True</code> &gt;= Mayor o igual que <code>2&gt;=3</code> retorna <code>False</code> <p></p>"},{"location":"guias/operaradores/#operadores-logicos","title":"Operadores L\u00f3gicos","text":"<p>Los operadores l\u00f3gicos se utilizan para comprobar si una expresi\u00f3n es Verdadera o Falsa. Se utilizan en la toma de decisiones.</p> <p> Operador Descripci\u00f3n Ejemplo and AND l\u00f3gica <code>a and b #True si a y b son ciertos</code> or OR l\u00f3gica <code>a or b #True si a o b son ciertos</code> not NOT l\u00f3gica <code>not a #True si el operador a es falso</code> <p></p> <p>En la figura siguiente vemos un ejemplo con lo que devuelve en cada caso.</p> <p> <p> Ejemplos en el IDLE de operadores l\u00f3gicos</p> <p></p>"},{"location":"guias/operaradores/#operadores-bitwise","title":"Operadores Bitwise","text":"<p>Los operadores bit a bit o bitwise act\u00faan sobre los operandos como si fueran cadenas de d\u00edgitos binarios. Operan bit a bit, de ah\u00ed su nombre.</p> <p> Operador Descripci\u00f3n Ejemplo &amp; AND bit a bit <code>5&amp;6 # 101 &amp; 110 = 110 = 4</code> | OR bit a bit <code>5 \\| 6 # 101 \\| 110 = 111 = 7</code> ~ NOT bit a bit <code>~3 # ~011 = 100 = -4</code> ^ XOR bit a bit <code>5^3 # 101^011 = 110 = 6</code> &lt;&lt; Desplazamiento izquierda <code>4&lt;&lt;1 # 100 &lt;&lt; 1 = 1000 = 8</code> &gt;&gt; Desplazamiento derecha <code>4 &gt;&gt; 1 # 100 &gt;&gt; 1 = 010 = 2</code> <p></p>"},{"location":"guias/operaradores/#operadores-especiales","title":"Operadores especiales","text":"<p>El lenguaje Python ofrece algunos tipos especiales de operadores como el operador de identidad (<code>identity</code>) y el operador de pertenencia (<code>membership</code>).</p> <ul> <li>Operadores <code>identity</code></li> </ul> <p>En Python, <code>is</code> e <code>is not</code> se utilizan para comprobar si dos valores se encuentran en la misma parte de la memoria. Dos variables que son iguales no implica que sean id\u00e9nticas. Algunos ejemplos aclaran mejor lo dicho.</p> <pre><code>x1 = 5\ny1 = 5\nx2 = 'Hello'\ny2 = 'Hello'\n\nprint(x1 is not y1)  # False\n\nprint(x2 is y2)  # True\n</code></pre> <p>Vemos que x1 e y1 son enteros con los mismos valores, por lo que son iguales e id\u00e9nticos. Lo mismo ocurre con x2 e y2 (cadenas).</p> <ul> <li>Operadores <code>membership</code></li> </ul> <p>En Python, <code>in</code> y <code>not in</code> son los operadores de pertenencia. Se utilizan para comprobar si un valor o variable se encuentra en una secuencia (cadena, lista, tupla, conjunto y diccionario).</p> <p>En un diccionario s\u00f3lo podemos comprobar la presencia de la clave, no del valor.</p>"},{"location":"guias/permisos/","title":"Permisos en Linux","text":"<p>Aunque no es un tema de Python si es muy probable que necesitemos en alg\u00fan momento cambiar los permisos de un directorio o de un archivo y por eso dejo aqu\u00ed esta peque\u00f1a gu\u00eda.</p>"},{"location":"guias/permisos/#tipos-de-permisos-en-linux","title":"Tipos de permisos en Linux","text":"<p>El comando CHMOD nos da la posibilidad de poder cambiar los permisos de los archivos y directorios combinando entre clases y tipos. Hay cuatro clases:</p> <ul> <li>Propietario (u). Creador del archivo o la carpeta</li> <li>Grupo (g). Usuarios que tendr\u00e1n acceso al archivo o carpeta</li> <li>Otros (o). Todos los usuarios</li> <li>Todos (a). Todos los tipos de usuario (propietario, grupo y otros)</li> </ul> <p>Hay tres tipos de permisos:</p> <ul> <li>Lectura ( r). Permite que el usuario vea el archivo pero no puede realizar cambios en el mismo ni copiarlo o borrarlo.</li> <li>Escritura (w). Se permite que los usuarios que acceden al archivo o carpeta puedan realizar sobre el mismo cualquier tipo de edici\u00f3n, copiar, cortar o borrar.</li> <li>Ejecutar (x). Al activar esta opci\u00f3n, la cual viene por defecto deshabilitada, podemos ejecutar archivos.</li> </ul> <p>Hay tres modificadores para la tarea:</p> <ul> <li>+. Concede el permiso</li> <li>-. Deniega el permiso</li> <li>=. Sobreescribe un permiso con el permiso anterior.</li> </ul> <p>En entornos Unix cada permiso tiene el siguiente valor:</p> <ul> <li>Lectura: 4</li> <li>Escritura: 2</li> <li>Ejecuci\u00f3n: 1</li> </ul>"},{"location":"guias/permisos/#trabajar-con-permisos","title":"Trabajar con permisos","text":"<p>Jugando con sumas de estos valores establecemos distintos permisos, por ejemplo, si queremos dar un permiso de escritura usaremos el 6 = 4 + 2 (Lectura + Escritura). Si queremos que pueda ejecutar usaremos el 7 = 4 + 2 + 1 (Lectura + Escritura + Ejecuci\u00f3n).</p> <p>En la tabla tenemos todos los valores posibles.</p> <p> Dec. Bin. Permiso read write exe 0 000 Sin permisos N N N 1 001 Ejecuci\u00f3n N N Y 2 010 Escritura N Y N 3 011 Lectura y escritura N Y Y 4 100 Lectura Y N N 5 101 Lectura y ejecuci\u00f3n Y N Y 6 110 Lectura y escritura Y Y N 7 111 Lectura, escritura y ejecuci\u00f3n Y Y Y <p></p> <p>El procedimiento para establecer el permiso es muy sencillo. Basta con ir a una terminal y ejecutar la siguiente orden:</p> <pre><code>chmod Tipo-permiso Ruta-Archivo\n</code></pre> <p>Ejemplos para modificar permisos en modo terminal:</p> <pre><code>chmod o=rwx * \u2192 Dar permisos de lectura, escritura y ejecuci\u00f3n a los otros usuarios.\n\nchmod go= * \u2192 Quitar todos los permisos a grupo y los otros usuarios.\n\nchmod 666 /Documentos/curso-python/Ejercicios/holamundo.py\n</code></pre> <p>En sistemas Linux con letras veremos algo como lo siguiente:</p> <ul> <li>0 \u2192 ---  \u2192 sin acceso</li> <li>1 \u2192 --x \u2192 ejecuci\u00f3n</li> <li>2 \u2192 -w- \u2192 escritura</li> <li>3 \u2192 -wx \u2192 escritura y ejecuci\u00f3n</li> <li>4 \u2192 r-- \u2192 lectura</li> <li>5 \u2192 r-x \u2192 lectura y ejecuci\u00f3n</li> <li>6 \u2192 rw- \u2192 lectura y escritura</li> <li>7 \u2192 rwx \u2192 lectura, escritura y ejecuci\u00f3n</li> </ul> <p>Por ejemplo: chmod 777. Le damos a los 3 tipos de usuarios permiso de lectura, ejecuci\u00f3n y escritura (hemos sumado4+2+1).  Si queremos dar permisos de lectura y escritura ser\u00eda 4+2 = 6 y si si lo que queremos es s\u00f3lo dar lectura ser\u00eda 4. Si lo que queremos es dar lectura y ejecuci\u00f3n ser\u00eda de sumar 4 + 1 = 5.</p> <p>Diferentes combinaciones t\u00edpicas:</p> <ul> <li>chmod 755. Permiso de lectura y ejecuci\u00f3n (4+1) a todos los usuarios excepto al propietario que lo tiene completo (lectura, escritura, ejecuci\u00f3n 4+2+1).</li> <li>chmod 666. Permisos de lectura y escritura a todos, excepto ejecuci\u00f3n (4+2). Todos pueden acceder al archivo, leer su contenido y modificarlo.</li> <li>chmod 644. Se suele utilizar para no permitr la escritura a nadie que no sea el propietario. El 755 es similar, lectura y ejecuci\u00f3n aunque este es m\u00e1s restrictivo (s\u00f3lo lectura) y (lectura, escritura para propietario).</li> </ul>"},{"location":"guias/poo/","title":"Programaci\u00f3n Orientada a Objetos","text":"<p>Este apartado se crea especificamente por la dificultad que tiene el tema que vamos a explicar a continuaci\u00f3n:</p> <p>Hay ciertos elementos o dispositivos que van a requerir de una librer\u00eda externa a Python y estas librerias se hacen utilizando las clases. En el editor online de MicroPython de micro:bit se pueden incluir y utilizar este tipo de liber\u00edas. Para centrar un poco el tema vamos a ver:</p> <ul> <li>Las clases en Python de una forma no muy profunda.</li> <li>La utilizaci\u00f3n del men\u00fa Project de python.microbit, necesario para poder incluir librerias</li> <li>Ejemplo de trabajo con una libreria para una LCD I2C.</li> </ul>"},{"location":"guias/poo/#las-clases-en-python","title":"Las clases en Python","text":"<p>La Programaci\u00f3n Orientada a Objetos (POO) es un modelo de programaci\u00f3n que proporciona unas gu\u00edas acerca de c\u00f3mo trabajar con \u00e9l y que est\u00e1 basado en el concepto de clases y objetos.</p> <p>Una clase es una especie de plantilla que define, de forma gen\u00e9rica, como ser\u00e1n los objetos de un determinado tipo. Pongamos por ejemplo que una clase representa a un club, que podemos denominar \"club\". Esta clase puede tener atributos (propiedades) como nombre, edad, profesion. Se pueden implementar como m\u00e9todos (funciones) de esas propiedades comportamientos como socio, socia o imparte_taller.</p> <p>Un ejemplo sencillo de un objeto puede ser un profesor, que puede ser socio por lo que se crea un atributo de profesi\u00f3n y adem\u00e1s puede impartir_taller, por lo que se define un nuevo m\u00e9todo.</p> <p>Una clase en Python es una estructura que permite definir los m\u00e9todos y atributos que definen un objeto. En Python una clase es una plantilla para crear objetos que son instancias de esa clase.</p> <p>En Python, una clase se define mediante la palabra clave <code>class</code>, seguida del nombre de la clase, dos puntos (:) y el cuerpo de la clase. Este cuerpo contiene definiciones de m\u00e9todos y atributos, que pueden ser p\u00fablicos o privados seg\u00fan su acceso.</p> <pre><code>class club:\n    def __init__(self, nombre, edad, profesion):\n        self.nombre = nombre\n        self.edad = edad\n        self.profesion = profesion\n    def saludo(self)\n        print(\"Hola, me llamo \" + self.nombre + \"y soy \" + self.profesion)\n</code></pre> <p>Las principales ventajas de utilizar clases son:</p> <ul> <li>Reutilizaci\u00f3n. Una clase la podemos reutilizar en diferentes partes del programa y en distintos programas. Esto puede ahorrar mucho tiempo y evita repeticiones de c\u00f3digo.</li> <li>Modulaci\u00f3n. El c\u00f3digo de un programa se divide en partes mas peque\u00f1as lo que facilita el mantenimiento y la soluci\u00f3n de problemas.</li> <li>Encapsulaci\u00f3n. Consiste en ocultar la complejidad de un objeto para mostrar solamente una interfaz simple f\u00e1cil de usar para interactuar ese objeto.</li> <li>Polimorfismo. Se trata de implementar el mismo conjunto de m\u00e9todos con diferentes comportamientos para distintos objetos. Esto dota de mayor flexibilidad al dise\u00f1o de programas.</li> </ul> <p>Las principales desventajas de utilizar clases son:</p> <ul> <li>Complejidad. Una clase puede hacer mas dificil de entender y depurar un programa debido al incremento de complejidad.</li> <li>Curva de aprendiza. Aprender Programaci\u00f3n Orientada a Objetos y clases tiene una curva de aprendizaje mas pronunciada, sobre todo cuando se empieza a programar.</li> <li>Abuso. A veces se abusa inncesariamente de las clases en situaciones en las que una funci\u00f3n har\u00eda lo mismo incluso de forma mas eficiente.</li> </ul> <p>Las variables que se definen dentro de las clases se denominan atributos y sirven para almacenar datos de un objeto de esa clase. Se utilizizan para representar propiedades de un objeto.</p> <p>Los atributos pueden ser como las variables normales, enteros, reales, cadenas, listas, tuplas, diccionarios, etc. Adem\u00e1s pueden tener distintos niveles de visibilidad que se indican mediante modificadores de acceso. En Python los modificadores son p\u00fablicos por defecto, lo que significa que son accesibles desde cualquier lugar del programa.</p> <p>Un atributo se define como una variable que se inicializa con el m\u00e9todo <code>__init__</code>. Por ejemplo:</p> <pre><code>class club:\n    def __init__(self, nombre, edad, profesion):\n        self.nombre = nombre\n        self.edad = edad\n        self.profesion = profesion\n</code></pre> <p>En la clase <code>club</code> los atributos nombre, edad y profesion, se definen como se ve en el c\u00f3digo. En este caso los tres son atributos p\u00fablicos de la clase <code>club</code>, que se inicializan con los valores que se proporcionen al crear un objeto de la clase. El acceso a los atributos de un objeto de una clase se utiliza el modificador (.) seguido del nombre del atributo, por ejemplo, para acceder al atributo <code>nombre</code> de un objeto <code>socio</code> de la clase <code>club</code> hariamos:</p> <pre><code>socio1 = socio1.nombre\n</code></pre> <p>Los tipos de atributos son:</p> <ul> <li>P\u00fablicos. Ya hemos indicado que se puede acceder a ellos desde cualquier parte del programa y desde fuera de la clase y que en Python lo son por defecto, por lo que no requieren ning\u00fan modificador de acceso. Se accede a ello con (.).</li> <li>Privados. Solo son accesibles desde la propia clase y se definen con el prefijo (__) seguido del nombre del atributo.</li> <li>Protegidos. Solamente son accesibles desde la propia clase o desde sus clases heredadas. Se utiliza el prefijo \"\" seguido del nombre del atributo para su definici\u00f3n. En Python es simplemente una convenci\u00f3n y si es posible acceder desde fuera de la clase.</li> </ul> <p>En Python se utilizan los m\u00e9todos, que son funciones que se definen dentro de una clase y que se utilizan para hacer operaciones en los objetos creados a partir de esa clase. La definici\u00f3n de un m\u00e9todo se realiza de la misma forma que la de una funci\u00f3n con la diferencia de que en un m\u00e9todo siempre tiene como primer par\u00e1metro el objeto al que se aplicar\u00e1 el m\u00e9todo, que por defecto se llama <code>self</code>.</p> <p>Para utilizar un m\u00e9todo de una clase lo primero que tenemos que hacer es crear un objeto a partir de la clase y as\u00ed poder llamar al m\u00e9todo sobre ese objeto.</p> <p>El objeto <code>self</code> se utiliza como referencia del objeto que se manipula cuando se llama al m\u00e9todo. Al crear una instancia de una clase, necesitamos diferenciar o especificar los atributos de la instancia de los argumentos y otras variables. Y ah\u00ed es donde necesitamos la palabra clave <code>self</code> para especificar que estamos pasando el valor a los atributos de la instancia y no a la variable o argumento local con el mismo nombre.</p> <p>Existen tambi\u00e9n otros m\u00e9todos que se denominan dunder (de double underscore methods) que tienen un doble gui\u00f3n bajo (__) al principio y al final del nombre.</p> <ul> <li>init: Inicializar un objeto cuando se crea una instancia de una clase. Se usa para asignar valores a los atributos de una instancia de clase.</li> <li>str: Se utiliza para devolver una cadena de una instancia de una clase. Es el m\u00e9todo que se llama cuando usamos la funci\u00f3n <code>str()</code> para convertir un objeto en una cadena de caracteres.</li> <li>repr(): M\u00e9todo especial de Python que se utiliza para devolver una cadena legible de un objeto. Se llama cuando usamos la funci\u00f3n repr().</li> </ul> <p>Y bueno, hay mas conceptos y definiciones necesarias para trabajar creando clases, pero como este no es el objetivo, lo vamos a dejar aqu\u00ed que ya es suficiente para manejarnos un poco con clases ya creadas.</p>"},{"location":"guias/rand/","title":"El m\u00f3dulo random","text":"<p>El m\u00f3dulo implementa generadores de n\u00fameros pseudoaleatorios y este es su c\u00f3digo fuente: \u0142ib/random.py.</p> <p>Antes de cada uso del m\u00f3dulo random, hay que a\u00f1adir la declaraci\u00f3n <code>import random</code> al principio del archivo Python.</p> <p>Tenemos disponibles las siguientes opciones:</p> <ul> <li><code>randint(inicio, fin)</code>: Genera aleatoriamente un n\u00famero entero entre los valores inicial y final.</li> </ul> <ul> <li>inicio: Valor inicial en el rango especificado, que se incluir\u00eda en el rango.</li> <li>fin: Valor final en el rango especificado, que se incluir\u00eda en el rango.</li> <li>random(): Genera aleatoriamente un n\u00famero de coma flotante entre 0 y 1.</li> </ul> <ul> <li><code>random.uniform(inicio, fin)</code>: Genera aleatoriamente un n\u00famero de coma flotante entre los valores inicial y final.</li> </ul> <ul> <li>inicio: Valor inicial en el rango especificado, que se incluir\u00eda en el rango.</li> <li>fin: Valor final en el rango especificado, que se incluir\u00eda en el rango.</li> </ul> <ul> <li><code>random.getrandbits(size)</code>: Genera un aleatorio entero del tama\u00f1o especificado por <code>size</code>.</li> </ul> <p>Por ejemplo:</p> <p>si size = 4, se genera un entero en el rango de 0 a 0b1111, o sea entre 0 y 15.</p> <p>si size = 8, se genera un entero en el rango de 0 a 0b11111111, o sea entre 0 y 255.</p> <ul> <li><code>random.randrange(inicio, fin, paso)</code>: Genera aleatoriamente un entero positivo en el rango de inicio a fin que se incrementa seg\u00fan el valor de paso.</li> </ul> <ul> <li>inicio: Valor inicial en el rango especificado, que se incluir\u00eda en el rango.</li> <li>fin: Valor final en el rango especificado, que se incluir\u00eda en el rango.</li> <li>paso: Un n\u00famero entero que especifica el incremento.</li> </ul> <ul> <li><code>random.seed(sed)</code>: Especifica una semilla aleatoria, que suele aplicarse junto con otros generadores de n\u00fameros aleatorios.</li> </ul> <ul> <li>sed: Semilla aleatoria, un punto de partida en la generaci\u00f3n de n\u00fameros aleatorios.</li> </ul> <ul> <li><code>random.choice(obj)</code>: Genera aleatoriamente un elemento a partir del dato <code>obj</code>.</li> </ul>"},{"location":"guias/sintaxis/","title":"Sintaxis en Python","text":"<p>Se puede decir que sintaxis es el conjunto de reglas que definen como se escribe c\u00f3digo en un determinado lenguaje de programaci\u00f3n, con un paralelismo total con la gramatica de una lengua. Por lo tanto la sintaxis indica la forma en la que debemos escribir las instrucciones de nuestro programa para que se entienda. A diferencia de la sintaxis del lenguaje, en programaci\u00f3n es 100% estricta y no podemos cometer \"faltas de ortografia\". Vamos a ver que peculiaridades tiene el lenguaje Python.</p> <p>Continuando con el paralelismo anterior ocurre exactamente lo mismo en un idioma que en un lenguaje de programaci\u00f3n, solamente por sabernos todas sus palabras no lo hablamos ni programamos correctamente.</p> <p>La forma de escribir un programa en Python es bastante parecida al lenguaje natural. Veamos esto con un sencillo ejemplo:</p> <pre><code># Definimos variable de tipo cadena\ntexto = \"El resultado de a + b*c es: \"\n# Asignamos valores a las variables\na, b, c = 2, 3, 4\n# Realizamos las operaciones y las guardamos en sol\nsol = 2 + 3*4\n# Mostramos resultados\nprint(texto, sol)\n# El resultado obtenido es 14\n</code></pre>"},{"location":"guias/sintaxis/#comentarios","title":"Comentarios","text":"<p>Los comentarios se utilizan para dar informaci\u00f3n complementaria de nuestro c\u00f3digo. Los comentarios no son c\u00f3digo y son ignorados por el interprete de Python. Pueden ser de dos tipos:</p> <ul> <li> <p>Una sola linea: Escribiendo el s\u00edmbolo almohadilla (#) delante del comentario, como los vistos en el ejemplo de mas arriba.</p> </li> <li> <p>Multilinea: Escribiendo triple comillas dobles (\u201c\u201d\u201d) o simples (''') al principio y al final del comentario. Tanto al principio como al final deben ser del mismo tipo.</p> </li> </ul> <p>En los comentarios, pueden incluirse palabras que nos ayuden a identificar adem\u00e1s, el subtipo de comentario:</p> <pre><code># TODO esto es algo por hacer\n# FIXME (arreglarme) esto es algo que debe corregirse\n# XXX esto tambi\u00e9n, es algo que debe corregirse\n</code></pre>"},{"location":"guias/sintaxis/#identation-o-sangria","title":"Identation o sangria","text":"<p>La sangr\u00eda se refiere a los espacios al comienzo de una l\u00ednea de c\u00f3digo. En Python estos espacios se utilizan para definir los bloques de c\u00f3digo. Es posible utilizar (es lo habitual) la tecla de tabulaci\u00f3n para dejar esos espacios.</p> <p>Mientras que en otros lenguajes de programaci\u00f3n la sangr\u00eda en el c\u00f3digo es solo para facilitar la lectura, la sangr\u00eda en Python es muy importante ya que se usa para indicar un bloque de c\u00f3digo.</p> <pre><code>if 5 &gt; 2:\n    print(\"Cinco es mayor que 2\")\n</code></pre> <p>Lo siguiente ser\u00eda un error de sintaxis.</p> <pre><code>if 5 &gt; 2:\nprint(\"Cinco es mayor que 2\")\n</code></pre> <p>El n\u00famero de espacios de la identation puede ser cualquiera siempre que al menos sea un espacio. Siempre hay que usar el mismo n\u00famero de espacios en el mismo bloque de c\u00f3digo y la norma, si no usamos la tabulaci\u00f3n es dejar cuatro espacios.</p> <p>Se puede utilizar el punto y coma (;) para poner dos o mas sentencias en la misma l\u00ednea: <code>a = 2 ; b = 3 ; c = 3</code></p> <p>Hay ocasiones en que una l\u00ednea de c\u00f3digo resulta demasiado larga. En estos casos puede resultar conveniente romper esa l\u00ednea en varias para hacer el c\u00f3digo mas legible.</p> <p>La recomendaci\u00f3n que realiza la guia de estilo para c\u00f3digo Python PEP 8 recomienda que no se excedan los 79 caracteres.</p> <p>Hay dos casos para romper en varias l\u00edneas:</p> <ul> <li>Cuando no hay par\u00e9ntesis. En este caso se a\u00f1ade al final de cada l\u00ednea el conjunto + y se salta a la siguiente.</li> </ul> <pre><code>a = a+1+b+2+c+3 +\\\nd+5+e+f+g+6+7+8+9 +\\\nh+i+j\n</code></pre> <ul> <li>Cuando existen par\u00e9ntesis. En este caso se puede omitir el caracter . Es aplicable a las llamadas a funciones cuando les pasamos par\u00e1metros.</li> </ul> <pre><code>a = (a+1+b+2+c+3 +\nd+5+e+f+g+6+7+8+9 +\nh+i+j)\n</code></pre>"},{"location":"guias/sintaxis/#palabras-reservadas","title":"Palabras reservadas","text":"<p>Son palabras reservadas que tienen un significado especial para el compilador y que no podemos usar para poner nombres a variables o funciones. Todas las palabras, excepto <code>True</code>, <code>False</code> y <code>None</code> se escriben en min\u00fasculas. A continuaci\u00f3n se da un listado de todas las palabras reservadas o keywords:</p> <pre><code>False, None, True, and, as, assert, async, await, break, class, continue, \n\ndef, del, elif, else, except, finally, for, from, global, if, import, in, \n\nis, lambda, nonlocal, not, or, pass, raise, return, try, while, with, yield\n</code></pre> <p>El listado al principio nos puede resultar abrumador, pero imaginemos un lenguaje con tan solo esas palabras y entenderemos que no resultar\u00e1 tan complejo familiarizarse, al menos con las mas usuales.</p>"},{"location":"guias/sintaxis/#identificadores","title":"Identificadores","text":"<p>Los identificadores son los nombres que se dan a variables, clases, m\u00e9todos, etc. No podemos usar palabras reservadas para estos nombres.</p> <p>Algunas reglas que nos pueden resultar \u00fatiles para nombrar idetificadores son:</p> <ul> <li>Los identificadores son sensibles a may\u00fasculas y min\u00fasculas</li> <li>Los identificadores no pueden ser palabras reservadas</li> <li>Los espacios en blanco no est\u00e1n permitidos</li> <li>Un identificador puede ser una secuencia de letras y n\u00fameros. Siempre debe empezar por una letra o por el s\u00edmbolo de subrayado \"_\". El primer car\u00e1cter de un identificador no puede ser un n\u00famero.</li> <li>No podemos utilizar caracteres especiales como la \u00f1, \u00a1, \u00bf o letras con acentos.</li> <li>No podemos utilizar los s\u00edmbolos como !, @, #, $, etc.</li> </ul> <p>Nos va a resultar muy \u00fatil recordar lo siguiente:</p> <ul> <li>Python es un lenguaje que distingue entre may\u00fasculas y min\u00fasculas. Esto significa que <code>Variable</code> y <code>variable</code> no son lo mismo</li> <li>Damos siempre a los identificadores un nombre que tenga sentido. Aunque que <code>c = 10</code> es un perfectamente v\u00e1lido, escribir <code>contador = 10</code> tendr\u00eda m\u00e1s sentido, y ser\u00eda m\u00e1s f\u00e1cil averiguar lo que representa cuando miremo el c\u00f3digo pasado un tiempo.</li> <li>Las palabras m\u00faltiples se pueden separar usando un gui\u00f3n bajo, como por ejemplo <code>esto_es_un_nombre_de_variable_muy_largo</code>.</li> </ul>"},{"location":"guias/sintaxis/#variables-constantes-y-literales","title":"Variables, constantes y literales","text":""},{"location":"guias/sintaxis/#variables","title":"Variables","text":"<p>En programaci\u00f3n, una variable es un nombre que se utiliza para referirse a una posici\u00f3n de memoria donde se almacena un valor. De forma m\u00e1s abstracta, puede considerarse como una caja que almacena un valor. El nombre de la caja es el nombre de la variable y el contenido su valor. Todas las variables constan de tres partes: un nombre, un tipo de dato y un valor. En la figura siguiente vemos tres variables de distintos tipos:</p> <p> <p> Concepto gr\u00e1fico de variable</p> <p>Enlace a la fuente</p> <p></p> <p>La variable <code>name</code> contiene la cadena <code>Bob</code>, la variable <code>winner</code> es cierta y la variable <code>score</code> contiene el valor <code>35</code>.</p> <p>Python no dispone de ning\u00fan comando para declarar variables. Una variable se crea cuando se le asigna valor por primera vez. La t\u00e9cnica de declarar variables es poner un nombre seguido del signo de asignaci\u00f3n (=) y el valor asignado a la variable. En la declaraci\u00f3n es importante tener claro que se distinguen may\u00fasculas de min\u00fasculas y que no est\u00e1n permitidos los caracteres especiales.</p> <p>En Python no se declara de forma explicita el tipo de la variable pues se trata de un lenguaje inferido. Las variables incluso pueden cambiar de tipo desde el que se establece al asignarle valor la primera vez. Es decir, si declaro <code>valor = 5</code> inicialmente la variable ser\u00e1 de tipo entero (int), pero si en el programa se realizan operaciones que al final hacen que <code>valor = 1.33</code> ahora valor es de tipo float. Autom\u00e1ticamente sabe que <code>valor</code> es un n\u00famero entero y declara la variable <code>valor</code> como un <code>int</code>.</p> <p>Aunque no es necesario si es posible especificar el tipo de dato de una variable, haciendo:</p> <pre><code>x = str(22) # x ser\u00e1 la cadena '22'\ny = int(22) # y ser\u00e1 el entero 22\nz = float(22) # z ser\u00e1 el n\u00famero de coma flotante 22.0\n</code></pre> <p>Es posible saber el tipo de una variable en un momento dado con la sentencia <code>type(variable)</code>.</p> <p>Algunas reglas para nombrar variables que podemos tener en cuenta son:</p> <ul> <li>Los nombres pueden tener una combinaci\u00f3n de letras min\u00fasculas o may\u00fasculas o n\u00fameros o el s\u00edmbolo de subrayado \"_\".</li> <li>Crear nombres que tengan sentido, aunque sean largos.</li> <li>Si usamos varias palabras para definir el nombre, estas las separamos por \"_\"</li> <li>Python es sensible a may\u00fasculas y min\u00fasculas.</li> <li>Hay que evitar palabras reservadas en nombres de variables.</li> </ul>"},{"location":"guias/sintaxis/#constantes","title":"Constantes","text":"<p>Una constante no es mas que un tipo especial de variable cuyo valor no puede modificarse.</p> <p>En Python, las constantes suelen declararse y asignarse en un m\u00f3dulo (un nuevo archivo que contiene variables, funciones, etc y que se importa al archivo principal).</p> <p>Veamos c\u00f3mo declaramos constantes en un archivo separado y lo usamos en el archivo principal,</p> <ul> <li>Creamos un archivo que nombramos constantes.py y que contendr\u00e1:</li> </ul> <pre><code>PI = 3.141592\nFUERZA_GRAVEDAD = 9.82\n</code></pre> <ul> <li>Creamos el archivo principal main.py, que contendr\u00e1:</li> </ul> <pre><code>import constantes\n\nprint(constantes.PI)\nprint(constantes.FUERZA_GRAVEDAD)\n</code></pre> <p>En el ejemplo creamos el archivo de m\u00f3dulo constantes.py y asignamos el valor constante a PI y FUERZA_GRAVEDAD.</p> <p>Despu\u00e9s, creamos el archivo main.py e importamos el m\u00f3dulo constantes. Finalmente, imprimimos el valor de cada constante.</p> <p>La convenci\u00f3n es nombrarlas en may\u00fasculas para distinguirlas de las variables.</p>"},{"location":"guias/sintaxis/#literales","title":"Literales","text":"<ul> <li>Num\u00e9ricos</li> </ul> <p>Los literales son representaciones de valores fijos en un programa. Pueden ser n\u00fameros, caracteres, cadenas, etc. Por ejemplo, \"\u00a1Hola, mundo!\", 12, 23.0, \"C\", etc.</p> <p>Los literales num\u00e9ricos son inmutables (no pueden cambiar) y pueden pertenecer a uno de los tres tipos de datos num\u00e9ricos posibles: Entero, Coma flotante y Complejo. Los tipos son:</p> <ul> <li>Decimal. N\u00fameros regulares. Por ejemplo: 5, 22, -40</li> <li>Binario. Deben comenzar por 0b. Por ejemplo: 0b110, 0b11</li> <li>Octal. Deben empezar con 0o. Por ejemplo: 0o13, 0o7</li> <li>Hexadedicmal. Deben empezar con 0x. Por ejemplo 0x13, 0xFF</li> <li>Coma flotante. Contienen el punto decimal. Por ejemplo 10.2, 3.14</li> <li> <p>Complejo. Tienen la forma <code>a + bj</code>. Por ejemplo: 3 - 2j, -4 + j</p> </li> <li> <p>Booleanos</p> </li> </ul> <p>Solamente hay dos literales booleanos <code>True</code> y <code>False</code></p> <ul> <li>Cadenas de caracteres</li> </ul> <p>Los literales de caracteres son caracteres unicode encerrados entre comillas, por ejemplo <code>S</code>. Los literales cadenas de caracteres son cadenas de csaracteres encerradas entre comillas, por ejemplo <code>Python es divertido</code>.</p> <ul> <li>Especiales</li> </ul> <p>En Python existe un literal especial, <code>None</code>. Podemos usarlo, por ejemplo, para especificar una variable nula, por ejemplo:</p> <pre><code>var = None\nprint(var)\n# El resultado ser\u00e1: None\n</code></pre>"},{"location":"inicio/inicio/","title":"Como comenzar","text":"<p>Lo primero que debemos hacer es posicionar nuestra Raspberry Pi Pico o PicoW en su posici\u00f3n teniendo la precuaci\u00f3n de orientarla adecuadamente seg\u00fan nos marca el serigrafiado de la placa que vemos en la imagen siguiente, donde est\u00e1 indicado el conector USB como clara referencia.</p> <p> <p> Serigrafia en la placa Pico Explorer</p> <p></p> <p>Estas notas se van a dedicar a crear programas en MicroPython para RaspBerry Pi Pico, por lo tanto aclaremos algunos conceptos:</p> <ul> <li>Python es un lenguaje de programaci\u00f3n de alto nivel, limpio, elegante. \u00e1gil y sencillo, que facilita el aprendizaje de la programaci\u00f3n dada su curva de aprendizaje.</li> <li> <p>Python no es un lenguaje compilado sino interpretado por lo que se puede experimentar mientras se programa. Dispone de una libreria est\u00e1ndar y de multitud de librerias desarrolladas que permiten realizar tareas complejas de forma mas sencilla que otros lenguajes.</p> </li> <li> <p>MicroPython es un eficiente interprete del lenguaje Python que se ha optimizado para funcionar en microcontroladores y ambientes restringidos.</p> </li> <li>El interprete se encarga de procesar el c\u00f3digo de programa para hacer posible que el hardware ejecute lo que en \u00e9l se indica. El interprete se sit\u00faa como una capa l\u00f3gica de software entre el c\u00f3digo y el hardware.</li> <li>MicroPython dispone de m\u00f3dulos que permiten el acceso al hardware del microcontrolador y dispone de multitud de librerias para las distintas tareas.</li> </ul> <p>Dado el hardware que vamos a utilizar es recomendable comenzar descargando y copiando MicroPython uf2 personalizado de Pimorini en nuestra Rasberry Pi Pico; ya que incluye todas las liberias que necesitaremos para usarlo.</p> <p>En otro apartado vamos a ver como comenzar con RBP Pico, que versi\u00f3n descargar de MicroPython y comenzaremos a trabajar con todo ello.</p>"},{"location":"inicio/inicio_pi_pico/","title":"Inicio con Raspberry Pi Pico","text":"<p>Vamos a realizar una introducci\u00f3n a Raspberry Pi Pico mostrando los pasos necesarios para montarla, configurarla y prepararla para la programaci\u00f3n con MicroPython. Tambi\u00e9n veremos como trabajar con algunas placas que se conectan a los breakout garden.</p> <p>No vamos a profundizar en exceso en los contenidos, aunque si es necesario podemos recurrir a:</p> <ul> <li>Busquedas en la web sobre el tema. Existen multitud de p\u00e1ginas con informaci\u00f3n mas o menos detallada, aunque siempre debemos asegurarnos de que la informaci\u00f3n es confiable.</li> <li>El libro Getting Started with MicroPython on the Raspberry Pi Pico.</li> <li>El sitio oficial de Raspberry Pi.</li> <li>La hoja de datos de Pico: Datasheet de Pico.</li> <li>Repositorio de Github Pimoroni Pico Libraries and Examples.</li> </ul>"},{"location":"inicio/inicio_pi_pico/#sobre-raspberry-pi","title":"Sobre Raspberry Pi","text":"<p>La Raspberry Pi es una placa construida con un microcontrolador RP2040 a la que si a\u00f1adimos un teclado, un rat\u00f3n y un monitor se convierte en un ordenador que ejecuta Linux con un buen nivel de procesamiento y memoria RAM.</p> <p>Raspberri Pi Pico est\u00e1 orientada a computaci\u00f3n f\u00edsica, es decir, para conectarla a sensores y actuadores. A diferencia de la Pi, la Pico est\u00e1 dotada de conversores anal\u00f3gico a digital (ADC) pra ampliar la gama de sensores y entradas. La mayor\u00eda de los pines son de tipo PIO (Programmable Input Output) de prop\u00f3sito general. En el RP2040 estos pines est\u00e1n controlados por el IO programable, lo que significa que se actualizan en segundo plano con muy poco uso de la CPU. Esto hace que las entradas/salidas programables sean tan r\u00e1pidas que se puede alcanzar una resoluci\u00f3n de 14 bits en lugar de los 8 bits habituales.</p> <p>La Raspberry Pi Pico es programable a trav\u00e9s de USB con C, C++ o MicroPython, siendo este \u00faltimo lenguaje el que nos ocupar\u00e1 aqu\u00ed.</p> <p>Desde el mes de julio de 2022 adem\u00e1s se puede conseguir la Pico W con conectividad inal\u00e1mbrica.</p>"},{"location":"inicio/inicio_pi_pico/#lo-que-vamos-a-necesitar","title":"Lo que vamos a necesitar","text":"<ul> <li>Una Raspberry Pi Pico o Pico W</li> </ul> <p> <p> Aspecto de las Pi Pico y Pico W</p> <p></p> <ul> <li>Un cable micro USB para conectar la Pico al ordenador y as\u00ed poder programarla. Lo \u00fanico a tener en cuenta aqu\u00ed es que el cable debe ser apto para alimentaci\u00f3n y datos. Esto se indica porque algunos cables de tel\u00e9fonos antiguos por ejemplo, solamente suministran alimentaci\u00f3n.</li> </ul> <p> <p> Cable USB micro</p> <p></p> <ul> <li>Tiras de pines rectos macho de paso 2.54 mm para poder conectar la Pi Pico a la placa Pico Explorer (veremos como soldarlas mas adelante). Usualmente se comercializan como tiras de 40 pines que debemos cortar en dos trozos de 20 como los que vemos en la imagen siguiente:</li> </ul> <p> <p> Tiras de 20 pines rectos macho de paso 2.54 mm</p> <p></p> <ul> <li>Un ordenador desde el que programar la Pi Pico con el software (usaremos Thonny) que vamos a utilizar instalado.</li> </ul>"},{"location":"inicio/inicio_pi_pico/#soldar-las-tiras-de-pines","title":"Soldar las tiras de pines","text":"<p>Aunque vamos a dar unos consejos pr\u00e1cticos de soldadura y partienfdo de la base de que las PCB actuales son f\u00e1ciles de soldar, si no tenemos herramientas adecuadas y una m\u00ednima experiencia es aconsejable adquirir la Pi Pico con las tiras de pines ya soldadas.</p>"},{"location":"inicio/inicio_pi_pico/#equipo-basico-de-soldadura","title":"Equipo b\u00e1sico de soldadura","text":"<p>Es relativamente sencillo localizar en la web informaci\u00f3n de como realizar soldaduras electr\u00f3nicas para ver como se hace, pero omitimos recomendar ninguno concreto, pues sobre todo, el \u00e9xito o fracaso va a depender del equipamiento que tengamos para soldar, y si no tenemos previsto utilizarlo con cierta frecuencia casi mejor no adquirir ninguno y solicitar a alguien que nos suelde las tiras.</p> <p>En mi caso voy a enumerar y describir brevemente el equipo que yo utilizo con el que llevo trabajando muchos a\u00f1os.</p> <p>1.- Alfombrilla o tapete de silicona. Permite tener el material ordenado y evita quemaduras o rayaduras accidentales sobre la superficie de trabajo.</p> <p> <p> Alfombrilla de silicona de 45x30</p> <p></p> <p>2.- Soldador. Es la herramienta principal para esta tarea y no puede sere de baja calidad. Hay que huir de los t\u00edpicos que encontramos muy econ\u00f3micos. En mi caso dispongo de dos tipos, ambos de bastante calidad.</p> <p> <p> Soldadores</p> <p></p> <p>3.- Esta\u00f1o de 0.5 a 1mm de di\u00e1metro. Se recomienda el uso de esta\u00f1o libre de plomo. En la imagen vemos un carrete de Sn99.3-Cu0.7.</p> <p> <p> Esta\u00f1o</p> <p></p> <p>4.- Soporte para soldador. Imprescindible si queremos evitar quemaduras accidentales.</p> <p> <p> Soporte para soldador</p> <p></p> <p>5.- Limpiador de puntas de soldador. Permite eliminar en caliente los restos de esta\u00f1o y resina de la punta del soldador manteniendola en perfectas condiciones de uso.</p> <p> <p> Limpiador de puntas de soldador</p> <p></p> <p>6.- Algunas herramientas de uso b\u00e1sico en electr\u00f3nica como pinzas, alicates de corte, tijeras, destornilladores, etc.</p>"},{"location":"inicio/inicio_pi_pico/#teoria-de-soldadura","title":"Teor\u00eda de soldadura","text":"<p>Una vez pertrechados con el equipamiento vamos a recomendar unos tutoriales b\u00e1sicos de soldadura:</p> <ul> <li>El primero es en forma de comic realizado por Mitch Altman (conocimientos de soldadura), Andie Nordgren (adaptaci\u00f3n a comic) y Jeff Keyzer (dise\u00f1o y edici\u00f3n) titulado Soldar es f\u00e1cil, aqu\u00ed est\u00e1 como hacerlo. El comic data de 2001 y recomienda el uso del esta\u00f1o tradicional con aleaci\u00f3n de Esta\u00f1o/Plomo al 60/40 con n\u00facleo de resina. Actualmente este tipo de esta\u00f1o no se usa habitualmente debido a la alta toxicidad del plomo aunque es f\u00e1cil de encontrar en el mercado. Existen directivas comunitarias europeas que prohiben su uso. Se recomienda encarecidamente la lectura de este comic, resulta instructivo y entretenido.</li> <li>El segundo son dos infografias de Adafruit que aunque est\u00e1n en ingl\u00e9s se entienden perfectamente. Estas las podemos encontrar en la colecci\u00f3n de tarjetas que tiene en Github y son Card 4 Back.pdf y Card 4 Front.pdf que reproducimos como im\u00e1genes a continuaci\u00f3n.</li> </ul> <p> <p> Card 4 Front</p> <p> Card 4 Back</p> <p></p>"},{"location":"inicio/inicio_pi_pico/#soldar-las-tiras-de-pines_1","title":"Soldar las tiras de pines","text":"<p>Las tiras de pines debemos soldarlas de manera que queden perpendiculares a la base de la Pi Pico y, para ello, lo m\u00e1s f\u00e1cil y comodo es pincharlas a la distancia apropiada sobre una placa protoboard. La parte que pinchamos en la protoboard es la parte mas larga de los pines.</p> <p> <p> Colocaci\u00f3n de las tiras en una protoboard</p> <p></p> <p>Colocamos encima de las tiras la Pi Pico con la frambuesa mirando hacia arriba.</p> <p> <p> Colocaci\u00f3n de la Pi Pico sobre las tiras de pines</p> <p></p> <p>Procedemos a soldar cada uno de los pines. Para ello se recomienda soldar los pines de las cuatro esquinas asegr\u00e1ndonos de que la placa est\u00e1 apoyada correctamente. Si no est\u00e1 todo correcto ahora es el momento de realizar las correcciones oportunas porque m\u00e1s adelante ya no podremos. Sobre todo comprobar que est\u00e1n a 90\u00ba y podemos continuar con el resto de pines. Se recomienda no soldar los pines uno al lado del otro para evitar sobrecalentamientos de la placa, siendo una buena t\u00e9cnica ir cambiando de una tira a otra hasta completar todas las soldaduras.</p> <p> <p> Tiras de pines soldadas</p> <p></p> <p>Ya podemos retirar la Pi Pico de la protoboard y colocarla en su lugar en la Pico Explorer. Se recomienda para hacerlo sujetar la placa por los bordes largos y balancearla suavemente o incluso ayudarno de un peque\u00f1o destornillador que nos permita hacer palanca, pero debemos hacerlo con cuidado para no doblar ning\u00fan pin.</p>"},{"location":"inicio/pi_pico_picoW/","title":"La Pi Pico y Pico W","text":"<p>Realizaremos una breve descripci\u00f3n de los modelos lanzados de la Pi Pico, describiendo sus principales caracter\u00edsticas. El modelo Pico W es totalmente similar con la salvedad de que integra conectividad WiFi.</p> <ul> <li>La Raspberry Pi Pico se lanz\u00f3 al mercado el 21 de enero de 2021.</li> <li>La Pico W se lanz\u00f3 el 30 de junio de 2022 como reemplazo directo de la Pi Pico para trabajar IoT.</li> </ul> <p> <p> Partes principales en la Pi Pico</p> <p></p> <p> <p> Partes principales en la Pi Pico W</p> <p></p> <p>En la tabla siguiente vemos las principales caracter\u00edsticas de la Pi Pico.</p> <p> caracteristicas y especificaciones Valores Microntrolador RP2040 N\u00facleos Dos (dual core) Arquitectura de nucleo 32-bits ARM Cortex-M0+ Reloj de la CPU Configurable hasta 133MHz Memoria RAM 264 KBytes de SRAM Memoria Flash 2 MBytes Q-SPI Lenguajes soportados MicroPython, C y C++ Alimentaci\u00f3n 5V DC por micro USB Alimentaci\u00f3n alternativa 2 a 5V DC por VSYS (pin 39) Tensi\u00f3n MCU 3.3V DC Tensi\u00f3n GPIO 3.3V DC Interface USB USB 1.1 GPIO 26 entradas/salidas digitales ADC 3x12 bits a 500ksps Sensor de temperatura integrado de 12 bits UART 2 I2C 2 SPI 2 PWM 16 Timer Un timer con 4 alarmas RTC Un contador en tiempo real PIO 2 IO programables de alta velocidad LED en placa Un LED programable (GP25) Bot\u00f3n en placa Un bot\u00f3n BOOTSEL Puerto de depuraci\u00f3n Puerto de 3 pines ARM Serial Wire Debug Inal\u00e1mbrico IEEE 802.11 b/n/g de 2.4 GHz. Bluetooth 5.2 Antena Incorporada en la propia placa <p></p> <p>La Pi Pico est\u00e1 dise\u00f1ada para integrarse en otros productos, bien a partir de SMT (Surface Mount Technology) gracias al dise\u00f1o de borde de los pines, o bien a trav\u00e9s de tiras de pines.</p> <p> <p> Pi Pico para SMT y tiras de pines</p> <p></p> <p>Entre los 26 pines GPIO se pueden configurar como:</p> <ul> <li>3 como ADC de 12 bits a 500 ksps (kilo muestras por segundo)</li> <li>2 como UART</li> <li>2 como SPI</li> <li>2 como I2C</li> <li>Hasta 16 como pines PWM</li> </ul> <p>Internamente viene con un temporizador con 4 alarmas, y un contador en tiempo real y los perif\u00e9ricos duales de E/S programables (PIO) que son E/S de alta velocidad flexibles y programables por el usuario. Puede emular interfaces como tarjetas SD y VGA.</p> <p>En la imagen siguiente vemos la posible configuraci\u00f3n de pines PWM en la Raspberry Pi Pico.</p> <p> <p> Pines PWM en la Pi Pico</p> <p></p> <p>IMPORTANTE: Los pines GPIO de la Pi Pico trabajan a 3,3V como voltaje m\u00e1ximo de entrada y/o salida. Si aplicamos tensiones superiores a cualquiera de ellos podemos da\u00f1ar la placa de manera irreversible.</p>"},{"location":"inicio/pi_pico_picoW/#la-familia-pi-pico","title":"La familia Pi Pico","text":"<p>La familia de Raspberry Pi Pico est\u00e1 formada por la cuatro placas que vemos en la imagen siguiente:</p> <p> <p> La familia Pi Pico Imagen obtenida de aqu\u00ed</p> <p></p>"},{"location":"inicio/pi_pico_picoW/#pi-pico-y-pico-h","title":"Pi Pico y Pico H","text":"<p>La Raspberry Pi Pico viene con medios agujeros en el borde que permiten soldarla directamente a otras placas base, mientras que la Pico H viene con terminales pre-soldados.</p> <p>Ambas placas tienen tres pines Serial Wire Debug (SWD). En la Pico H viene soldado un peque\u00f1o conector de 3 vias con retenci\u00f3n tipo JST, mientras que la Pico tiene tres agujeros pasantes junto a los medios agujeros del borde de la placa.</p> <p>A continuaci\u00f3n tenemos diferentes archivos sobre informaci\u00f3n de las placas.</p> <ul> <li>Enlace al pinout en pdf</li> <li>Enlace al esquema p\u00fablico en pdf</li> <li>En la imagen siguiente vemos los modelos Fritzing de la Pico y de la Pico H en el IDE del mismo.</li> </ul> <p> <p> Pi Pico y Pico H en Fritzing</p> <p></p> <ul> <li>En la imagen podemos ver el modelo .STEP en FreeCAD en el IDE del mismo.</li> </ul> <p> <p> Pi Pico en FreeCAD</p> <p></p> <ul> <li>Hoja de datos de la Pi Pico</li> </ul>"},{"location":"inicio/pi_pico_picoW/#pi-pico-w-y-pico-wh","title":"Pi Pico W y Pico WH","text":"<p>Raspberry Pi Pico W a\u00f1ade interfaces inal\u00e1mbricas integradas de banda \u00fanica de 2,4 GHz (802.11n) utilizando el chip Infineon CYW43439, manteniendo el factor de forma Pico. La interfaz inal\u00e1mbrica integrada de 2,4 GHz tiene las siguientes caracter\u00edsticas:</p> <ul> <li>WPA3</li> <li>Punto de acceso compatible con hasta cuatro clientes</li> <li>Bluetooth 5.2. Compatibilidad con Bluetooth BLE y Bluetooth Classic</li> </ul> <p>La antena es una antena integrada con licencia de ABRACON (anteriormente ProAnt). La interfaz inal\u00e1mbrica est\u00e1 conectada mediante SPI al microcontrolador RP2040.</p> <p>Debido a las limitaciones de pines, algunos de los pines de la interfaz inal\u00e1mbrica son compartidos. El CLK se comparte con el monitor VSYS, por lo que s\u00f3lo cuando no hay una transacci\u00f3n SPI en curso puede leerse VSYS a trav\u00e9s del ADC. El Infineon CYW43439 DIN/DOUT e IRQ comparten un pin en el RP2040. S\u00f3lo cuando una transacci\u00f3n SPI no est\u00e1 en progreso es adecuado comprobar si hay IRQs. La interfaz funciona t\u00edpicamente a 33MHz.</p> <p>Para un mejor rendimiento inal\u00e1mbrico, la antena debe estar en un espacio libre. Por ejemplo, poner metal debajo o cerca de la antena puede reducir su rendimiento tanto en t\u00e9rminos de ganancia como de ancho de banda. A\u00f1adir partes met\u00e1licas conectadas a tierra a los lados de la antena puede mejorar su ancho de banda.</p> <p>A continuaci\u00f3n tenemos diferentes archivos sobre informaci\u00f3n de las placas.</p> <ul> <li>Enlace al pinout en pdf</li> <li>En la imagen siguiente vemos el modelo Fritzing de la Pico W en el IDE del mismo.</li> </ul> <p> <p> Pi Pico W en Fritzing</p> <p></p> <ul> <li>En la imagen podemos ver el modelo .STEP en FreeCAD en el IDE del mismo.</li> </ul> <p> <p> Pi Pico W en FreeCAD</p> <p></p> <ul> <li>Hoja de datos de la Pi Pico W</li> </ul>"},{"location":"up/firm/","title":"Firmware","text":"<p>Para programar la Pi Pico se pueden utilizar herramientas basadas en los est\u00e1ndares MicroPython y CircuitPython as\u00ed como el IDE de Arduino. Por otra parte, existe una herramienta de programaci\u00f3n basada en Snap! que se denomina MicroBlocks que ofrece una forma sencilla de iniciarse en la programaci\u00f3n de forma grafica. Thonny es otra plataforma de software libre y de c\u00f3digo abierto de tama\u00f1o compacto, interfaz sencilla, por lo que es un IDE de Python ideal para principiantes. El sitio oficial de Thonny y sus repositorios de c\u00f3digo abierto nos ofrecen tanto el programa como la informaci\u00f3n del mismo. En estas notas vamos a trabajar fundamentalmente con Thonny y con MicroBlocks.</p> <p>Para terminar con la preparaci\u00f3n de nuestra placa y comenzar a trabajar con la misma vamos a ver como grabar el firmware en la Pi Pico y como instalar y usar el compilador Thonny que usaremos para programar la Pi Pico.</p>"},{"location":"up/firm/#instalacion-del-firmware","title":"Instalaci\u00f3n del firmware","text":"<p>Ya hemos indicado que vamos a utilizar la versi\u00f3n de MicrPython de Pimorini. Podemos obtener la versi\u00f3n en: https://github.com/pimoroni/pimoroni-pico/releases/latest/. Para instalar MicroPython, tenemos que copiar el archivo .uf2 apropiado de la p\u00e1gina de versiones al dispositivo PI Pico mientras est\u00e1 en modo DFU/bootloader.</p>"},{"location":"up/firm/#que-archivo-descargar","title":"\u00bfQue archivo descargar?","text":"<p>En la [p\u00e1gina de versiones] tenemos todos los archivos disponibles de los que a nosotros nos van a interesar uno de los dos que se describen en la tabla e imagen siguientes:</p> <p> Placa Que archivo uf2 utilizo Raspberry Pi Pico y otras  placas con RP22040 inal\u00e1mbricas (Plasma 2040, Interstate 75, Servo 2040, Motor 2040, Tiny 2040 2MB) pimoroni-pico-vx.x.x-micropython.uf2 Raspberry Pi Pico W y otras  placas Pico W (Automation 2040 W, Inventor 2040 W, Plasma Stick, Interstate 75 W) pimoroni-picow-vx.x.x-micropython.uf2 <p></p> <p> <p> Archivos a descargar para la Pi Pico</p> <p></p>"},{"location":"up/firm/#grabar-firmware-uf2-en-la-pi-pico","title":"Grabar firmware .uf2 en la Pi Pico","text":"<p>Para copiar el archivo a la Pico, debemos ponerla en modo de gestor de arranque. Para hacer esto, mantenemos presionado el bot\u00f3n BOOTSEL mientras conectamos el cable USB al ordenador; ahora deber\u00eda aparecer como una unidad llamada RPI-RP2.</p> <p> <p> Localizaci\u00f3n del bot\u00f3n BOOTSEL</p> <p></p> <p>As\u00ed es como se ve en Ubuntu:</p> <p> <p> Unidad RPI-RP2 montada</p> <p></p> <p>Copiamos el archivo descargado en la unidad. La Pico se reinicia y, transcurridos unos segundos, ejecutar\u00e1 MicroPython. Es muy probable que no notemos ninguna diferencia pero ahora la Pico est\u00e1 cantando canciones piratas para si misma en voz baja.</p> <p>A partir de ahora, la Pico ya no aparecer\u00e1 como una unidad cuando la conectamos y ser\u00e1 necesario usar un interprete para comunicarnos con ella. Este interprete se llama Thonny, MicroBlocks, etc.</p>"},{"location":"up/soft/","title":"Software Thonny","text":"<p>Thonny es un sencillo editor gr\u00e1fico para aprender Python siendo un principiante en el tema.</p>"},{"location":"up/soft/#instalar-thonny","title":"Instalar Thonny","text":"<p>Thonny es un IDE (Integrated Development Environment o entorno de desarrollo integrado) de Python y es el software que utilizaremos para programar la Pico.</p> <p>Si trabajamos desde un Raspberry Pi es muy probable que ya tengamos Thonny instalado y tan solo tengamos que actualizar a la versi\u00f3n mas reciente para disponer de las opciones espec\u00edficas de Pico. Abrimos una terminal, por ejemplo con Ctrl+Alt+T y escribimos:</p> <p><code>sudo apt update &amp;&amp; sudo apt upgrade -y</code></p> <p>y presionamos Enter para que se ejecute.</p> <p>Si estamos trabajando en un ordenador, las versiones disponibles para Linux, Mac o Windows est\u00e1n aqu\u00ed listas para descargar e instalar.</p> <p>En el caso de Ubunto lo tenemos disponible en la tienda Snap a trav\u00e9s de Ubuntu Software.</p> <p> <p> Thonny en la tienda Snap</p> <p></p> <p>Una vez instalado lo ejecutamos y veremos la ventana siguiente:</p> <p> <p> IDE de Thonny</p> <p></p> <p>Pero seguro que instalando desde las distribuciones de paquetes o tienda Snap no obtenemos la \u00faltima versi\u00f3n. Si queremos instalar esta \u00faltima versi\u00f3n en Ubuntu 22.04 debemos visitar el repositorio de versiones de Thonny y descargar el archivo .bash de la versi\u00f3n que queramos.</p> <p> <p> Repo de versiones de Thonny</p> <p></p> <p>Abrimos una terminal en el directorio donde tengamos el archivo descargado, thonny-4.1.3.bash en este caso, y tecleamos:</p> <p> <p> Ejecutamos thonny-4.1.3.bash</p> <p></p> <p>Una vez finalizadas todas las tareas tenemos Thonny listo para ejecutar.</p> <p> <p> Thonny-4.1.3.bash instalado</p> <p></p> <p>Ya estamos listos para ejecutar la versi\u00f3n de Thonny, que en este caso se distingue porque aparece una banderita de Ucrania que permite solidarizarse con el pais.</p> <p> <p> IDE Thonny-4.1.3</p> <p></p>"},{"location":"up/soft/#descripcion-del-ide-de-thonny","title":"Descripci\u00f3n del IDE de Thonny","text":"<p>Una vez instalado, la primera vez que abrimos el programa se muestra la ventana que vemos a continuaci\u00f3n.</p> <p> <p> Partes del IDE Thonny-4.1.3</p> <p></p> <p>A continuaci\u00f3n realizamos una breve descripci\u00f3n de las partes numeradas:</p> <ol> <li>Barra de t\u00edtulo, donde vemos el nombre del programa y el nombre del archivo actual que por defecto es . <li>Barra de men\u00fas, que nos da acceso a todas las partes de Thonny.</li> <li>Barra de herramientas, con accesos r\u00e1pidos a las tareas habituales.</li> <li>Editor, donde se escribe el c\u00f3digo de nuestra aplicaci\u00f3n. Es una pesta\u00f1a con el nombre del archivo y pueden coexistir varias pesta\u00f1as, lo que permite tener varios archivos abiertos y cambiar rapidamente de uno a otro con tan solo hacer clic en la pesta\u00f1a.</li> <li>Int\u00e9rprete de comandos o consola, desde donde interactuar con nuestro ordenador. En realidad esta zona se denomina REPL (Read, Evaluate, Print y Loop) que traducido ser\u00eda bucle Lectura-Evaluaci\u00f3n-Impresi\u00f3n. Esto viene a significar algo as\u00ed como \"lee lo escrito, eval\u00faa el c\u00f3digo escrito, imprime los resultados y vuelve a empezar\".</li> <li>Barra de estado, donde indica con que Python est\u00e1 trabajando y nos da acceso a la configuraci\u00f3n del int\u00e9rprete.</li> <p>Desde el men\u00fa \"Visualizar\" se pueden activar y desactivar las herramientas de Thonny. A Continuaci\u00f3n vemos este men\u00fa desplegado. Activar (o desactivar si ya est\u00e1 activa) una herramienta es hacer clic sobre su nombre en este men\u00fa.</p> <p> <p> Men\u00fa Visualizar</p> <p></p> <p>Describimos brevemente estas herramientas.</p> <ul> <li>Archivos (\u00c1rbol de archivos). Especialmente \u00fatil cuando trabajamos en proyectos con varios archivos.</li> <li>Asistente. Un ayudante del editor Python que nos guiar\u00e1 en los problemas en la ejecuci\u00f3n o al implementar la aplicaci\u00f3n.</li> <li>Ayuda. Ayuda sobre el uso de la aplicaci\u00f3n, del depurador, etc.</li> <li>Esquema. Es un \u00e1rbol con todas las funciones, objetos y m\u00e9todos definidos en nuestra aplicaci\u00f3n. Es como un vistazo general a la aplicaci\u00f3n que nos permite movernos con rapidez por la misma. Simplemente cuando hacemos clic en un m\u00e9todo, funci\u00f3n o clase, nos desplazamos a ella.</li> <li>Excepci\u00f3n. Es donde se muestran los errores, cuando los hay.</li> <li>Inspector de objetos. Permite examinar las variables que se muestran tanto en heap como en Variables.</li> <li>Mont\u00edculo (heap). Cuando lo activamos podemos ver el valor de las variables.</li> <li>Notas. Para tener un lugar donde hacer anotaciones y tenerlas siempre a mano. Lo que escribamos aqu\u00ed se guar de manera autom\u00e1tica y se carga en el siguiente arranque de Thonny.</li> <li>PORHACER. Visualiza las etiquetas #TODO que hemos puesto como aviso de que la tarea est\u00e1 pendiente.</li> <li>Pila (stack). Nos da una visi\u00f3n de la parte de la aplicaci\u00f3n en la que nos encontramos en tiempo de ejecuci\u00f3n.</li> <li>Variables. Nos permite identificar, en tiempo de ejecuci\u00f3n, cada una de las variables de nuestra aplicaci\u00f3n. Si tenemos activado el heap lo que se muestra es el identificador de la variable, mientras que si no est\u00e1 activado heap veremos el valor de la variable.</li> <li>\u00c1rbol del programa. Es otra visi\u00f3n o punto de vista del programa que permite analizar el funcionamiento del mismo de una manera totalmente diferente.</li> </ul>"},{"location":"up/soft/#configuracion-basica-de-thonny","title":"Configuraci\u00f3n b\u00e1sica de Thonny","text":"<p>Thonny es f\u00e1cil de configurar dada lo b\u00e1sica que es la misma. Podemos acceder a la configuraci\u00f3n o bien desde el men\u00fa Herramientas o bien desde la parte inferior derecha de la ventana. En este \u00faltimo caso se abrir\u00e1 la ventana en la pesta\u00f1a Interprete.</p> <p> <p> Acceso a la ventana de configuraci\u00f3n</p> <p></p>"},{"location":"up/soft/#general","title":"General","text":"<p>En esta pesta\u00f1a se configuran aspecto generales de la aplicaci\u00f3n, como la posibilidad de lanzar varias instancias de Thonny, reabrir todos los archivos de la \u00faltima sesi\u00f3n o configurar el idioma.</p> <p> <p> Pesta\u00f1a General</p> <p></p>"},{"location":"up/soft/#interprete","title":"Int\u00e9rprete","text":"<p>Thonny permite seleccionar diferentes int\u00e9rpretes, es decir, diferentes versiones de Python. Como regla regla general, se utiliza el mismo int\u00e9rprete que el que ejecuta Thonny. Sin embargo, en nuestro caso, usaremos un int\u00e9rprete concreto. Necesitamos tener seleccionado 'MicroPython (Raspberry Pi Pico)' como int\u00e9rprete de Python; esto se puede hacer clicando en el cuadro en la parte inferior derecha. Thonny puede ofrecernos instalar MicroPython, pero no necesitamos hacerlo ya que ya tenemos la variante de MicroPython que necesitamos instalada. Teniendo las Pi Pico conectada a un puerto USB esta acci\u00f3n nos devolver\u00e1 algo similar a la imagen siguiente:</p> <p> <p> Selecci\u00f3n del Int\u00e9rprete</p> <p></p> <p>Tras la selecci\u00f3n Thonny muestra el siguiente aspecto:</p> <p> <p> Thonny tras la selecci\u00f3n del Int\u00e9rprete</p> <p></p> <p>Si no vemos la ventana como la de arriba, podemos probar a hacer clic en el bot\u00f3n rojo de detener para interrumpir cualquier proceso que se est\u00e9 ejecutando.</p> <p>Si Thonny tiene problemas para la detecci\u00f3n autom\u00e1tica la podemos seleccionar manualmente desde la pesta\u00f1a de configuraci\u00f3n Int\u00e9rprete, desde donde podremos seleccionar la placa y el puerto de forma correcta.</p> <p> <p> Pesta\u00f1a Int\u00e9rprete</p> <p></p>"},{"location":"up/soft/#editor","title":"Editor","text":"<p>En esta pesta\u00f1a podemos seleccionar diferentes opciones que nos ayudar\u00e1n en nuestro d\u00eda a d\u00eda programando.</p> <p> <p> Pesta\u00f1a Editor</p> <p></p>"},{"location":"up/soft/#temas-y-fuentes","title":"Temas y fuentes","text":"<p>Esta pesta\u00f1a est\u00e1 orientada a cambiar el aspecto est\u00e9tico de la aplicaci\u00f3n seg\u00fan nuestras preferencias.</p> <p> <p> Pesta\u00f1a Temas y fuentes</p> <p></p>"},{"location":"up/soft/#ejecutar-y-depurar","title":"Ejecutar y depurar","text":"<p>Para configurar una serie de ayudas que mejorean el funcionamiento y permiten trabajar mas comodamente, como por ejemplo la de abrir y cerrar el Stack autom\u00e1ticamente.</p> <p> <p> Pesta\u00f1a Ejecutar y depurar</p> <p></p>"},{"location":"up/soft/#terminal","title":"Terminal","text":"<p>En esta pesta\u00f1a podemos configurar las opciones del terminal.</p> <p> <p> Pesta\u00f1a Terminal</p> <p></p>"},{"location":"up/soft/#consola","title":"Consola","text":"<p>En esta pesta\u00f1a podemos configurar las opciones referentes al comportamiento al terminar un proceso o una aplicaci\u00f3n.</p> <p> <p> Pesta\u00f1a Consola</p> <p></p>"},{"location":"up/soft/#asistente","title":"Asistente","text":"<p>En esta pesta\u00f1a quiz\u00e1 la opci\u00f3n mas interesante sea la de habilitar o deshabilitar la apertura del asistente, de forma autom\u00e1tica, cuando se produce un error en el programa. Tambi\u00e9n es interesante activar este comportamiento para los warning.  <p> Pesta\u00f1a Asistente</p> <p></p>"},{"location":"up/soft/#primeros-pasos-con-thonny","title":"Primeros pasos con Thonny","text":"<p>Conectamos la Pi Pico con el firmware grabado al ordenador mediante un cable USB, arrancamos Thonny y hacemos clic en el 'Shell' o consola, obtendremos un cursor parpadeante. Escribiendo instrucciones en este cuadro damos \u00f3rdenes a la Pico directamente, una orden cada vez (esto se llama REPL, o Read-Eval-Print Loop). En la animaci\u00f3n siguiente vemos su funcionamiento.</p> <p> <p> Ordenes en la consola (REPL)</p> <p></p> <p>Pero tal vez lo que queramos sea poner mas de una l\u00ednea de instrucciones para componer un programa y que al ejecutarlo se realicen las acciones programadas. Esto lo hacemos en la ventana de programa, como por ejemplo en la animaci\u00f3n siguiente:</p> <p> <p> Programa b\u00e1sico</p> <p></p>"},{"location":"up/soft/#funcionamiento-en-linea","title":"Funcionamiento en l\u00ednea","text":"<p>Podemos trabajar con la Raspberry Pi Pico en l\u00ednea o conectada para compilar o depurar programas, pero es necesario tenerla conectada al ordenador.</p> <p>Las ventajas que esto no ofrece son:</p> <ul> <li>Podemos utilizar Thonny para compilar o depurar programas.</li> <li>A trav\u00e9s de la ventana \"Shell\", obtenemos la informaci\u00f3n de errores y los resultados de salida generados durante la ejecuci\u00f3n del programa. Tambi\u00e9n es posible consultar informaci\u00f3n de funciones para ayudar a mejorar el programa.</li> </ul> <p>Las desventajas son:</p> <ul> <li>Para trabajar en l\u00ednea la Raspberry Pi Pico tiene que estar conectada a un ordenador y ejecutar con Thonny.</li> <li>Si la Raspberry Pi Pico se desconecta del ordenador, el programa no se ejecutar\u00e1 de nuevo cuando se vuelve a conectar la Pi Pico.</li> </ul> <p>Partimos de Thonny reciente abierto y lo primero que hacemos es localizar un proyecto para abrirlo o bien crear uno nuevo. El proceso de apertura es el de la animaci\u00f3n siguiente:</p> <p> <p> Abrir un programa desde Thonny</p> <p></p> <p>En la animaci\u00f3n observamos lo f\u00e1cil que es abrir el archivo y ejecutarlo haciendo clic en el bot\u00f3n Ejecutar el script actual o pulsando F5. Cuando estamos en modo de ejecute en l\u00ednea, podemos hacer clic en Detener/Reiniciar el backend en Thonny o pulsar Ctrl+C para salir del programa. Esta acci\u00f3n l\u00edmpia el contenido de la consola al igual que la combinaci\u00f3n de teclas Ctrl+L.</p>"},{"location":"up/soft/#funcionamiento-sin-conexion","title":"Funcionamiento sin conexi\u00f3n","text":"<p>La Raspberry Pi Pico no necesita estar conectada al ordenador y a Thonny para ejecutar los programas almacenados en main.py en el dispositivo una vez que lo alimentemos.</p> <p>La ventaja es que se pueden ejecutar programas cuando se enciende sin conectarse a la computadora y Thonny.</p> <p>La desventaja es que el programa se detendr\u00e1 autom\u00e1ticamente cuando se produzca un error o la Raspberry Pi Pico se quede sin energ\u00eda. En esta situaci\u00f3n el c\u00f3digo no se puede cambiar f\u00e1cilmente.</p> <p>Cuando se alimenta, la Raspberry Pi Pico comprobar\u00e1 autom\u00e1ticamente si existe main.py en el dispositivo. Si est\u00e1 presente, ejecuta los programas en main.py y luego entra en el modo de comandos del shell. Es decir, si queremos que nuestro programa se ejecute offline basta con guardarlo con el nombre main.py. Si main.py no existe, el sistema entrar\u00e1 en el modo de comandos shell directamente.</p> <p></p>"},{"location":"up/soft/#ejecutando-codigo","title":"Ejecutando c\u00f3digo","text":"<p>Con la Pi Pico conectada al ordenador podemos hacer clic sobre el bot\u00f3n ejecutar y ver como parpadea el LED en la placa y la informaci\u00f3n que se muestra en la consola.</p> <p> <p> Ejecutar un programa desde Thonny</p> <p></p> <p>Si ahora hacemos clic en el bot\u00f3n de parada/reinicio el programa se detiene, el LED se apaga y se muestra informaci\u00f3n en la consola.</p> <p> <p> Detener un programa desde Thonny</p> <p></p> <p>De esta forma estamos ejecutando c\u00f3digo online o en conexi\u00f3n. Si ahora desconectamos el cable USB del ordenador, Thonny nos va a mostrar el siguiente mensaje:</p> <p> <p> Conexi\u00f3n perdida</p> <p></p> <p>Ahora volvemos a conectar el cable USB y recuperamos la conexi\u00f3n haciendo clic en el bot\u00f3n STOP. En esta situaci\u00f3n hacemos clic derecho sobre el nombre del archivo A01.py y escogemos la opci\u00f3n Subir a / para grabar el programa en la Pi Pico.</p> <p> <p> Subir a /</p> <p></p> <p>Podemos observar como ahora hay un archivo en la Pi Pico con el mismo nombre que el que teniamos en el IDE de Thonny.</p> <p> <p> Archivo subido a la Pi Pico</p> <p></p> <p>Pero este archivo por si solo no puede ejecutarse en la Pi Pico ya que el interprete MicroPython que contiene espera un archivo <code>main.py</code>. Lo que vamos a hacer es descargar el archivo main.py, que est\u00e1 en un directorio del mismo nombre, y lo copiamos en el directorio de A01. Simplemente indicar por ahora que desde MicroPython se invoca la ejecuci\u00f3n de este archivo main.py. Una vez copiado el archivo al directorio lo llevamos a la Pico de la misma forma que antes. Tendremos la siguiente situaci\u00f3n:</p> <p> <p> Archivo main.py subido a la Pi Pico</p> <p></p> <p>Desconectamos el cable USB y lo volvemos a conectar. El LED en la pico parpadea seg\u00fan el programa A01.py mientras que Thonny se muestra como vemos a continuaci\u00f3n:</p> <p> <p> Ejecuci\u00f3n desde la Raspberry Pi Pico</p> <p></p> <p>El c\u00f3digo se est\u00e1 ejecutando sin conexi\u00f3n (offline) entre Thonny y la Pico. Si queremos volver a tomar el control desde Thonny basta con hacer clic en el bot\u00f3n STOP y se mostrar\u00e1 la ventana siguiente:</p> <p> <p> Vuelta al modo online</p> <p></p>"},{"location":"upy/func_ref/","title":"Funciones de referencia de la placa Pico Explorer","text":"<p>La Pico Explorer Base incorpora:</p> <ul> <li>Una pantalla LCD IPS (In Plane Switching) de 1,14\" (240 x 240 pixels)</li> <li>Cuatro pulsadores</li> <li>Un zumbador/altavoz piezoel\u00e9ctrico</li> <li>Un controlador de motores DRV8833.</li> <li>Conectores tipo dupont de uso general.</li> <li>Placa prooboard peque\u00f1a.</li> <li>Conectores tipo jardinera.</li> </ul>"},{"location":"upy/func_ref/#funciones","title":"Funciones","text":""},{"location":"upy/func_ref/#pantalla","title":"Pantalla","text":"<p>Pico Explorer utiliza la biblioteca Pico Graphics para dibujar gr\u00e1ficos y escribir texto en la pantalla. En el enlace Referencia de la funci\u00f3n PicoGraphics MicroPython podemos encontrar toda la informaci\u00f3n de esta biblioteca y en este otro enlace, La libreria PicoGraphics en esta misma web informaci\u00f3n en castellano obtenida del primer enlace.</p> <p>En la placa Pico Explorer no es posible (por ahorro de pines para usar en otras funciones) regular la iluminaci\u00f3n de fondo de la pantalla por lo que <code>set_backlight</code> no tiene ning\u00fan efecto en este caso.</p> <p>Un ejemplo comentado nos ayudar\u00e1 a empezar a comprendrer el funcionamiento de la librer\u00eda:</p> <pre><code>from picographics import PicoGraphics, DISPLAY_PICO_EXPLORER\n\n# Configura pantalla\ndisplay = PicoGraphics(display=DISPLAY_PICO_EXPLORER)\n# Crea colores de pluma para escribir con ella\nBLANCO = display.create_pen(255, 255, 255)\nROJO = display.create_pen(255,0,0)\n# Establece fuente y cambia el pluma a blanco\ndisplay.set_font(\"bitmap8\")\ndisplay.set_pen(BLANCO)\n# Muestra un texto\ndisplay.text(\"Hola Mundo desde:\", 0, 0, scale=3)\n# cambia pluma a rojo\ndisplay.set_pen(ROJO)\n# Muestra un texto\ndisplay.text(\"Pico Explorer\", 0, 40, scale=4)\n\n# Actualiza la pantalla\ndisplay.update()\n</code></pre> <p>El resultado lo vemos en la imagen siguiente:</p> <p> <p> </p> <p></p> <p>El programa lo podemos descargar desde este enlace</p>"},{"location":"upy/func_ref/#botones","title":"Botones","text":"<p>En Pico Explorer tenemos disponibles cuatro botones, A, B, X e Y que est\u00e1n conectados a los GPIO 12, 13, 14 y 15 respectivamente. El m\u00f3dulo <code>pimoroni</code> tiene una clase de nombre <code>Button</code> para manejar los botones incluyendo la eliminaci\u00f3n de rebotes y la repetici\u00f3n autom\u00e1tica.</p> <p>La forma de trabajar con los botones es sencilla, tenemos que importar la  clase desde el m\u00f3dulo:</p> <pre><code>from pimoroni import Button\n</code></pre> <p>Y despu\u00e9s crear instancias de <code>button</code> con los GPIO correspondiente:</p> <pre><code>botonA = Button(12)\nbotonB = Button(13)\nbotonX = Button(14)\nbotonY = Button(15)\n</code></pre> <p>La clase tiene la forma:</p> <p> <pre><code>Button(button, invert=True, repeat_time=200, hold_time=1000)\n</code></pre> <p></p> <p>Si se mantiene presionado el bot\u00f3n, la clase devolver\u00e1 <code>True</code> en el intervalo de tiempo comprendido entre <code>repeat_time</code> y <code>hold_time</code> y cuando se alcance <code>hold_time</code> regresar\u00e1 <code>True</code> cada <code>repeat_time</code>/3 milisegundos.</p> <p>Tenemos disponibles dos m\u00e9todos para leer el estado del bot\u00f3n:</p> <ul> <li>Con funci\u00f3n de repetici\u00f3n: <code>estado = botonA.read()</code></li> <li>Sin la funci\u00f3n de repetici\u00f3n: <code>estado = botonA.raw()</code></li> </ul>"},{"location":"upy/func_ref/#adc-conversion-analogica-a-digital","title":"ADC (conversi\u00f3n anal\u00f3gica a digital)","text":"<p>La Pico Explorer dispone de tres canales ADC conectados a los pines 26, 27 y 28 de la Pi Pico. El m\u00f3dulo <code>pimoroni</code> implementa la clase <code>Analog</code> que permite leer los valores de tensi\u00f3n de esos pines.</p> <p>Para trabajar con esta clase hay que importarla desde el m\u00f3dulo:</p> <pre><code>from pimoroni import Analog\n</code></pre> <p>Y despu\u00e9s crear instancias de <code>Analog</code> con los pines correspondiente:</p> <pre><code>adc0 = Analog(26)\nadc1 = Analog(27)\nadc2 = Analog(28)\n</code></pre> <p>El valor de los pines se lee haciendo:</p> <pre><code>leer_analogica = adc0.read_voltage()\n</code></pre>"},{"location":"upy/func_ref/#motores","title":"Motores","text":"<p>Los pines dedicados a motores en la Pico Explorer son controlados por PWM mediante el driver DRV8833 que integra la placa y que contiene un puente en H doble. Lo mas aconsejable es utilizar la clase <code>Motor</code> del m\u00f3dulo <code>pimoroni</code> para el manejo de estos pines.</p> <p>Para comenzar a usar motores lo primero es importar la clase <code>Motor</code>.</p> <pre><code>from motor import Motor\n</code></pre> <p>Ahora instaciamos la clase para crear un objeto motor as\u00ed:</p> <pre><code>motor1 = Motor((8,9))\n</code></pre> <p>Y ya podemos comenzar a utilizar las funciones disponibles para la clase <code>Motor</code></p> <pre><code>Motor(pins, direction=NORMAL_DIR, speed_scale=1.0, zeropoint=0.0, deadzone=0.05, freq=25000, mode=SLOW_DECAY, ph_en_driver=False)\npins()\nenable()\ndisable()\nis_enabled()\nduty()\nduty(duty)\nspeed()\nspeed(speed)\nfrequency()\nfrequency(freq)\nstop()\ncoast()\nbrake()\nfull_negative()\nfull_positive()\nto_percent(in)\nto_percent(in, in_min, in_max)\nto_percent(in, in_min, in_max, speed_min, speed_max)\ndirection()\ndirection(direction)\nspeed_scale()\nspeed_scale(speed_scale)\nzeropoint()\nzeropoint(zeropoint)\ndeadzone()\ndeadzone(deadzone)\ndecay_mode()\ndecay_mode(mode)\n</code></pre> <p>Con <code>motor1.enable()</code> activamos el motor con su \u00faltima velocidad conocida. Si es la primera vez esta velocidad ser\u00e1 cero. Cuando hayamos terminado con el motor, lo desactivamos con <code>motor1.disable()</code>. Existen diversas maneras de controlar un motor que vamos a ver a continuaci\u00f3n.</p>"},{"location":"upy/func_ref/#control-por-velocidad","title":"Control por velocidad","text":"<p>La velocidad es una forma intuitiva de controlar un motor y se expresa como un n\u00famero que puede representar revoluciones por minuto o una velocidad angular o lineal. De forma predeterminada la velocidad puede tomar valores entre -1.0 y +1.0 pero se pueden establecer valores diferentes con <code>speed_scale</code>.</p> <p>La velocidad la podemos configurar llamando a <code>.speed(vel)</code> siendo <code>vel</code> un n\u00famero fraccionario o de coma flotante. Si el motor esta deshabilitado esto lo habilita y se almacena el ciclo de trabajo resultante.</p> <p>Para saber la velocidad actual del motor invocamos <code>.speed()</code> sin par\u00e1metros. Si el motor est\u00e1 deshabilitado devuelve la \u00faltima velocidad que se proporcion\u00f3 cuando se habilit\u00f3.</p> <p>Con el m\u00e9todo <code>.full_negative()</code> ordenamos al motor que alcance su velocidad m\u00e1xima negativa y con <code>.full_positive()</code> la positiva. En ambos casos se habilta el motor si no lo estaba.</p> <p>Para detener el motor usamos <code>.stop()</code>. El motor tambi\u00e9n se puede detener por inercia con <code>.coast()</code> o frenando con <code>.brake()</code>.</p>"},{"location":"upy/func_ref/#control-por-porcentaje","title":"Control por porcentaje","text":"<p>Si necesitamos que el motor funcione dependiendo de alg\u00fan sensor o dispositivo que entrega valores que nos son facilmente convertibles a velocidades del motor. Para solucionar esto disponemos del m\u00e9todo <code>.to_percent(in)</code> en la biblioteca. Tambi\u00e9n disponemos de <code>.to_percent(in, in_min, in_max)</code> que configura un porcentaje entre los valores m\u00ednimo y m\u00e1ximo proporcionados y tambi\u00e9n de <code>.to_percent(in, in_min, value_min, value_max)</code> que configura un porcentaje entre dos velocidades proporcionadas con una entrada entre un m\u00ednimo y un m\u00e1ximo.</p> <p>Si  el motor est\u00e1 desabilitado estos m\u00e9todos lo habilitan.</p>"},{"location":"upy/func_ref/#control-por-ciclo-de-trabajo","title":"Control por ciclo de trabajo","text":"<p>Es el control PWM de velocidad y sentido de giro de los motores en el que el porcentaje de tiempo que las se\u00f1ales est\u00e1n activas es lo que se conoce como ciclo de trabajo.</p> <p>El ciclo de trabajo se puede configurar con <code>.duty(duty)</code>, que toma un valor entre -1.0 y +1.0 como entrada <code>duty</code>. Esto habilita al motor si no lo est\u00e1 y recalcula la velocidad.</p> <p>Para obtener el ciclo de trabajo actual invocamos a <code>.duty()</code> sin ninguna entrada.</p> <p>La mayor\u00eda de los motores tienen un valor de ciclo de trabajo por debajo del cual hay demasiada fricci\u00f3n para moverse, produciendo un zumbido audible al intentarlo. Para evitar esto se puede establecer una zona muerta del ciclo de trabajo invocando a <code>.deadzone(deadzone)</code> que es un n\u00famero real entre 0.0 y 1.0. Cuando establezcamos un ciclo de trabajo para un motor, este solamente ser\u00e1 enviado al motor si es igual o mayor a la zona muerta enviada. Si est\u00e1 por debajo, el motor se detendr\u00e1. El valor por defecto de <code>deadzone</code> es 0.05.</p> <p>Podemos leer el valor de zona muerta invocando <code>.deadzone()</code>.</p>"},{"location":"upy/func_ref/#audio","title":"Audio","text":"<p>Los pines para PWM con audio son GP0 a GP7 en Pico Explorer. El pin que seleccionemos como salida PWM de audio tenemos que conectarlo mediante un puente con el pin nombrado AUDIO que es el pin que conecta con el zumbador piezoel\u00e9ctrico.</p> <p>Para configurar el altavoz lo primero es importar <code>Buzzer</code> desde el m\u00f3dulo <code>pimoroni</code>, para ello:</p> <pre><code>from pimoroni import Buzzer\n</code></pre> <p>Una vez importado podemos crear una instancia del mismo haciendo:</p> <pre><code>altavoz = Buzzer(0) # usando GP0\n</code></pre> <p>Ya podemos reproducir tonos de audio con:</p> <pre><code>altavoz.set_tone(frecuencia)\n</code></pre> <p>El par\u00e1metro frecuencia debe estar comprendido entre 1 y 5000 para frecuencias humanas audibles.</p> <p>El altavozse puede silenciar con:</p> <pre><code>altavoz.set_tone(0)\n</code></pre> <p>El siguiente c\u00f3digo hace sonar un tono de 440 Hz durante 2 segundos en el altavoz.</p> <pre><code>from pimoroni import Buzzer\nimport time\naltavoz = Buzzer(0)\naltavoz.set_tone(440)\ntime.sleep(2)\naltavoz.set_tone(0)\n</code></pre>"},{"location":"upy/func_ref/#pines-gpio","title":"Pines GPIO","text":"<p>Los 8 pines de entrada/salida de prop\u00f3sito general de la Pico Explorer est\u00e1n conectados de GP0 a GP7 y se puede utilizar <code>machine</code> de la misma forma que se utiliza en la Pi Pico.</p> <pre><code>import machine\nGP0 = machine.Pin(0, machine.Pin.IN, machine.Pin.PULL_DOWN) # pin como entrada\nGP1 = machine.Pin(1, machine.Pin.OUT) # pin como salida\n</code></pre> <p>Cuando conectamos diodos LED externos a la placa Pico Explorer, debemos tener en cuenta que GP0-GP7 ya tienen integradas una resistencia de 100 ohmios cada pin, que se realiza a trav\u00e9s de dos arrays de cuatro resistencias de 100 ohmios. Esto hace que no sea necesario incluir resistencias externas para evitar que el LED externo demande una corriente excesiva de esos pines.</p>"},{"location":"upy/func_ref/#ranuras-jardinera-i2c","title":"Ranuras jardinera / I2C","text":"<p>Estas ranuras permiten conectar dispositivos I2C a Pico Explorer:</p> <ul> <li>Lista de brotes disponibles en la tienda oficial</li> </ul> <p>En Pico Explores los pines GP20 (SDA) y GP21 (SCL) son los utilizados para interfaces tipo I2C y son diferentes de los pines predeterminados de tipo jardinera que utiliza Pimoroni, por lo que siempre que usemos estos conectores tenemos que especificar que estamos utilizando la placa Pico Explorer. Tenemos dos formas de hacer esto:</p> <ol> <li>Utilizando las constantes del m\u00f3dulo <code>pimoroni</code>.</li> </ol> <pre><code>from pimoroni_i2c import PimoroniI2C\nfrom pimoroni import PICO_EXPLORER_I2C_PINS\n\ni2c = PimoroniI2C(**PICO_EXPLORER_I2C_PINS)\n</code></pre> <ol> <li>Especificando los n\u00fameros de pines.</li> </ol> <pre><code>from pimoroni_i2c import PimoroniI2C\n\ni2c = PimoroniI2C(sda=(20), scl=(21))\n</code></pre>"},{"location":"upy/func_ref/#pines","title":"Pines","text":"<p>A continuaci\u00f3n damos un listado de pines de la Pico Explorer agrupados por funciones. Esta lista de pines la podemos encontrar tambi\u00e9n en la parte posterior de la placa Pico Explorer.</p>"},{"location":"upy/func_ref/#gpio","title":"GPIO","text":"<p>Los pines GPIO (General Purpose Input Output) o pines de entrada/salida de prop\u00f3sito general son:</p> <ul> <li>GP0 = 0</li> <li>GP1 = 1</li> <li>GP2 = 2</li> <li>GP3 = 3</li> <li>GP4 = 4</li> <li>GP5 = 5</li> <li>GP6 = 6</li> <li>GP7 = 7</li> </ul>"},{"location":"upy/func_ref/#botones_1","title":"Botones","text":"<ul> <li>Bot\u00f3n A = 12</li> <li>Bot\u00f3n B = 13</li> <li>Bot\u00f3n X = 14</li> <li>Bot\u00f3n Y = 15</li> </ul>"},{"location":"upy/func_ref/#motores_1","title":"Motores","text":"<ul> <li>Motor 1 (-) = 8</li> <li>Motor 1 (+) = 9</li> <li>Motor 2 (-) = 10</li> <li>Motor 2 (+) = 11</li> </ul>"},{"location":"upy/func_ref/#spi","title":"SPI","text":"<p>Utilizados para la pantalla son:</p> <ul> <li>SPI MISO - 16</li> <li>LCD CS - 17</li> <li>SPI SCK - 18</li> <li>SPI MOSI - 19</li> </ul>"},{"location":"upy/func_ref/#i2c","title":"I2C","text":"<ul> <li>I2C SDA - 20</li> <li>I2C SCL - 21</li> <li>I2C INT - 22</li> </ul>"},{"location":"upy/func_ref/#pines-analogicos","title":"Pines anal\u00f3gicos","text":"<ul> <li>ADC0 = 26</li> <li>ADC1 = 27</li> <li>ADC2 = 28</li> </ul>"},{"location":"upy/picographics/","title":"La libreria PicoGrphics","text":"<p>Pico Graphics es la biblioteca de visualizaci\u00f3n y gr\u00e1ficos para controlar pantallas desde la Pico en MicroPython.</p>"},{"location":"upy/picographics/#configuracion-de-pico-grphics","title":"Configuraci\u00f3n de Pico Grphics","text":"<p>Para utilizar las funciones de la biblioteca tenemos que crear una instancia de PicoGrphics:</p> <pre><code>from picographics import PicoGraphics, DISPLAY_LCD_160X80\n\npantalla = PicoGraphics(display=DISPLAY_LCD_160X80)\n</code></pre> <p>La precauci\u00f3n a tener en cuenta es que MicroPython solamente dispone de 192 KB de RAM y una pantalla RGB de 320x240 utiliza 150 KB.</p>"},{"location":"upy/picographics/#pantallas-compatibles","title":"Pantallas compatibles","text":"<ul> <li>Pantalla Pico - LCD SPI de 240x135 -<code>DISPLAY_PICO_DISPLAY</code></li> <li>Pantalla Pico 2 - LCD SPI de 320x240 -<code>DISPLAY_PICO_DISPLAY_2</code></li> <li>Tufty 2040 - LCD paralelo 320x240 -<code>DISPLAY_TUFTY_2040</code></li> <li>Pico Explorer - LCD SPI de 240x240 -<code>DISPLAY_PICO_EXPLORER</code></li> <li>Enviro Plus - LCD SPI de 240x240 -<code>DISPLAY_ENVIRO_PLUS</code></li> <li>Conexi\u00f3n LCD SPI redonda de 240x240 -<code>DISPLAY_ROUND_LCD_240X240</code></li> <li>Conexi\u00f3n LCD SPI cuadrada de 240x240 -<code>DISPLAY_LCD_240X240</code></li> <li>Conexi\u00f3n LCD SPI de 160x80 -<code>DISPLAY_LCD_160X80</code></li> <li>OLED 128x128 I2C -<code>DISPLAY_I2C_OLED_128X128</code></li> <li>Pico Inky Pack / Badger 2040 / Badger 2040 W - Tinta E monocrom\u00e1tica 296x128 -<code>DISPLAY_INKY_PACK</code></li> <li>Inky Frame 5.7\" - 600x448 Tinta electr\u00f3nica de 7 colores -<code>DISPLAY_INKY_FRAME</code></li> <li>Inky Frame 4.0\" - 640x400 Tinta electr\u00f3nica de 7 colores -<code>DISPLAY_INKY_FRAME_4</code></li> <li>Inky Frame 7.3\" - 800x480 Tinta electr\u00f3nica de 7 colores -<code>DISPLAY_INKY_FRAME_7</code></li> <li>Paquete Pico GFX - Matriz LCD mono 128x64 -<code>DISPLAY_GFX_PACK</code></li> <li>Unicornio Gal\u00e1ctico - Matriz LED 53x11 \u200b\u200b-<code>DISPLAY_GALACTIC_UNICORN</code></li> <li>Interstate75 y 75W - Controlador Matrix HUB75 - <code>DISPLAY_INTERSTATE75_SIZEOFMATRIX</code></li> <li>Unicornio C\u00f3smico - Matriz LED 32x32 -<code>DISPLAY_COSMIC_UNICORN</code></li> <li>Unicornio Estelar - Matriz LED 16x16 -<code>DISPLAY_STELLAR_UNICORN</code></li> <li>Pack Pico Unicornio - Matriz LED 16x7 -<code>DISPLAY_UNICORN_PACK</code></li> </ul>"},{"location":"upy/picographics/#configuraciones-disponibles","title":"Configuraciones disponibles","text":"<ul> <li>Matriz 32 x 32 -<code>DISPLAY_INTERSTATE75_32X32</code></li> <li>Matriz 64 x 32 -<code>DISPLAY_INTERSTATE75_64X32</code></li> <li>Matriz 96 x 32 -<code>DISPLAY_INTERSTATE75_96X32</code></li> <li>Matriz 128 x 32 -<code>DISPLAY_INTERSTATE75_128X32</code></li> <li>Matriz 64 x 64 -<code>DISPLAY_INTERSTATE75_64X64</code></li> <li>Matriz de 128 x 64 -<code>DISPLAY_INTERSTATE75_128X64</code></li> <li>Matriz de 192 x 64 -<code>DISPLAY_INTERSTATE75_192X64</code></li> <li>Matriz de 256 x 64 -<code>DISPLAY_INTERSTATE75_256X64</code></li> </ul>"},{"location":"upy/picographics/#modos-graficos-soportados-tipo-de-pluma","title":"Modos gr\u00e1ficos soportados (tipo de pluma)","text":"<ul> <li>1 bit - <code>PEN_1BIT</code>- mono, utilizado para Pico Inky Pack y OLED I2C</li> <li>3 bits - <code>PEN_3BIT</code>- 8 colores, utilizado para Inky Frame</li> <li>4 bits - <code>PEN_P4</code>- Paleta de 16 colores</li> <li>8 bits - <code>PEN_P8</code>- Paleta de 256 colores</li> <li>RGB332 de 8 bits - <code>PEN_RGB332</code>- 256 colores fijos (3 bits de rojo, 3 bits de verde, 2 bits de azul)</li> <li>RGB565 de 16 bits - <code>PEN_RGB565</code>- 64K colores a costa de RAM. (5 bits rojos, 6 bits verdes, 5 bits azules)</li> <li>RGB888 de 24 bits: <code>PEN_RGB88816</code> 16 millones de colores a costa de mucha RAM. (8 bits rojos, 8 bits verdes, 8 bits azules)</li> </ul> <p>En la mayor\u00eda de los casos  es suficiente con utilizar <code>RGB332</code> que ofrece un buen equilibrio entre RAM y colores disponibles y adem\u00e1s es el valor por defecto de las pantallas LCD a color. En el ejemplo vemos la manera por defecto de configuraci\u00f3n y la manera explicita, que en este caso son id\u00e9nticas.</p> <pre><code>display = PicoGraphics(display=PICO_DISPLAY) # por defecto\ndisplay = PicoGraphics(display=PICO_DISPLAY, pen_type=PEN_RGB332) #explicita\n</code></pre>"},{"location":"upy/picographics/#rotaciones","title":"Rotaciones","text":"<p>Las pantallas LED SPI admiten rotaciones de 0, 90, 180 y 270 grados y se realizan comovemos en el ejemplo:</p> <pre><code>display = PicoGraphics(display=PICO_DISPLAY, rotate=180)\n</code></pre>"},{"location":"upy/picographics/#pines-personalizados","title":"Pines personalizados","text":""},{"location":"upy/picographics/#spiparalelo","title":"SPI/paralelo","text":"<p>La biblioteca <code>pimoroni_bus</code> incluye <code>SPIBus</code> LCD SPI y <code>ParallelBus</code> LCD paralelo. Normalmente solamente tendremos que recurrir a usarlos si conectamos varias pantallas LCD. En el ejemplo vemos un bus SPI personalizado:</p> <pre><code>from pimoroni_bus import SPIBus\nfrom picographics import PicoGraphics, DISPLAY_PICO_EXPLORER, PEN_RGB332\n\nbusspi = SPIBus(cs=17, dc=16, sck=18, mosi=19)\n\npantalla = PicoGraphics(display=DISPLAY_PICO_EXPLORER, bus=busspi, pen_type=PEN_RGB332)\n</code></pre>"},{"location":"upy/picographics/#i2c","title":"I2C","text":"<p>La biblioteca <code>pimoroni_i2c</code> incluye <code>PimoroniI2C</code> lo que se puede utilizar para cambiar los pines utilizados por una OLED mono:</p> <pre><code>from pimoroni_i2c import PimoroniI2C\nfrom picographics import PicoGraphics, DISPLAY_I2C_OLED_128X128\n\nbusi2c = PimoroniI2C(4, 5)\n\npantalla = PicoGraphics(display=DISPLAY_I2C_OLED_128X128, bus=busi2c)\n</code></pre>"},{"location":"upy/picographics/#funciones","title":"Funciones","text":""},{"location":"upy/picographics/#generales","title":"Generales","text":""},{"location":"upy/picographics/#crear-y-configurar-plumas","title":"Crear y configurar plumas","text":"<p>Para crear una pluma para los modos RGB888, RGB565, RGB332, P8 y P4 creamos una instancia de pluma as\u00ed:</p> <pre><code>mi_pluma = display.create_pen(R, G, B)\n</code></pre> <p>Para los modos RGB565 y RGB332 se indican los valores mediante RGB mediante n\u00fameros enteros que representan un color y retorna el resultado.</p> <p>Para los modos P4 y P8 se consume una entrada de paleta o retorna error si la paleta est\u00e1 llena. Los colores se almacenan como RGB y se convierten al mostrarse en pantalla.</p> <p>Tambi\u00e9n es posible especificar un pluma a partir de valores HSV (Hue = Tono, Saturation = Saturaci\u00f3n, Value = Valor) entre 0.0 y 1.0. Esto evita la necesidad de calcular el resultado RGB en Python.</p> <pre><code>display.create_pen_hsv(H,S,V)\ndisplay.set_pen(mi_pluma) # para indicar a PicoGrphics que pluma usar\n</code></pre> <p>Para los modos monocrom\u00e1ticos las plumas se manejan de forma un poco diferente dado que especificar un color RGB no tiene sentido. En lugar de esto se pueden indicar 16 tonos de gris que van desde 0 para el negro (o gris mas oscuro) hasta el 15 (o gris mas claro) para el blanco. Simplemente tenemos que invocar <code>set_pen</code> indicando el tono deseado:</p> <pre><code>display.set_pen(0)   # negro\ndisplay.set_pen(5)   # gris oscuro\ndisplay.set_pen(10)  # gris claro\ndisplay.set_pen(15)  # Blanco\n</code></pre> <p>Debemos tener presente que los grises funcionan mezclando pixeles blancos y negros para simularlos por lo que detalles peque\u00f1os, texto, lineas o pixeles sueltos se ver\u00e1n como blancos o negros.</p> <p>Las pantallas Inky Frame admiten los siguientes:</p> <ul> <li>BLACK= 0</li> <li>WHITE= 1</li> <li>GREEN= 2</li> <li>BLUE= 3</li> <li>RED= 4</li> <li>YELLOW= 5</li> <li>ORANGE= 6</li> <li>TAUPE= 7 (limpieza de la pantalla)</li> </ul>"},{"location":"upy/picographics/#luz-de-fondo","title":"Luz de fondo","text":"<p>Es posible configurar el brillo de la retroiluminaci\u00f3n de la pantalla entre 0.0 y 1.0:</p> <pre><code>display.set_backlight(0.5)\n</code></pre> <p>Recordemos que esto no est\u00e1 disponible para la  pantalla montada en la placa Pico Explorer.</p>"},{"location":"upy/picographics/#limites-de-dibujo","title":"L\u00edmites de dibujo","text":"<p>Se trata de establecer los l\u00edmites o recorte para dibujar:</p> <pre><code>display.set_clip(x, y, w, h) # coordenadas origen x,y y ancho y alto\n</code></pre> <p>Eliminar los l\u00edmites de recorte:</p> <pre><code>display.remove_clip()\n</code></pre>"},{"location":"upy/picographics/#limpiar","title":"Limpiar","text":"<p>Borra la pantalla al color de la pluma actual:</p> <pre><code>display.clear()\n</code></pre> <p>Esto equivale a:</p> <pre><code>w, h = display.get_bounds()\ndisplay.rectangle(0, 0, w, h)\n</code></pre> <p>Indicando que se pueden borrar partes de la pantalla con rect\u00e1ngulos para ahorrar tiempo y no tener que volver a dibujar elementos como archivos JPEG o gr\u00e1ficos.</p>"},{"location":"upy/picographics/#actualizar","title":"Actualizar","text":"<p>Env\u00eda el contenido del buffer de Pico Grphics a la pantalla:</p> <pre><code>display.update()\n</code></pre>"},{"location":"upy/picographics/#limites","title":"L\u00edmites","text":"<p>Podemos utilizar <code>get_bounds()</code> para determinar el ancho y el alto de la pantalla.</p> <pre><code>WIDTH, HEIGHT = display.get_bounds()\n</code></pre>"},{"location":"upy/picographics/#texto","title":"Texto","text":""},{"location":"upy/picographics/#cambiar-fuente","title":"Cambiar fuente","text":"<p>La sintaxis gen\u00e9rica es:</p> <pre><code>display.set_font(fuente)\n</code></pre> <p>Las fuentes disponibles est\u00e1n divididas en dos grupos, las de mapa de bits y las vectoriales:</p> <p>1.- Mapa de bits. Se alinean desde su esquina superior izquierda.</p> <ul> <li>bitmap6</li> <li>bitmap8</li> <li>bitmap14_outline</li> </ul> <p>2.- Vectoriales. Se alinean horizontalmente respecto a su borde izquierdo y verticalmente respecto a su l\u00ednea media. Cuando <code>scale=1</code>el borde superior de las letras may\u00fasculas est\u00e1 10 pixeles mas arriba del <code>y</code> especificado y la l\u00ednea base 10 pixeles por debajo.</p> <ul> <li>sans</li> <li>gothic</li> <li>cursive</li> <li>serif_italic</li> <li>serif</li> </ul>"},{"location":"upy/picographics/#espesor","title":"Espesor","text":"<p>De manera predeterminada las fuentes vectoriales tienen un grosor de un pixel, lo que genera texto muy fino y a veces ilegible. En la libreria tenemos el m\u00e9todo <code>set_thickness</code> que permite cambiar el grosor de las l\u00edneas que configuran cada caracter de la fuente.</p> <pre><code>display.set_thickness(n)\n</code></pre> <p>Dibujar textos muy gruesos ralentiza mucho el dibujo de los caracteres.</p>"},{"location":"upy/picographics/#dibujando-texto","title":"Dibujando texto","text":"<p>Para escribir un texto hacemos:</p> <pre><code>display.text(text, x, y, wordwrap, scale, angle, spacing)\n</code></pre> <p>Donde:</p> <ul> <li><code>text</code>- cadena de texto para dibujar</li> <li><code>x</code>- coordenada X</li> <li><code>y</code>- coordenada Y</li> <li><code>wordwrap</code>- n\u00famero de p\u00edxeles de ancho antes de intentar dividir el texto en varias l\u00edneas</li> <li><code>scale</code>- tama\u00f1o</li> <li><code>angle</code>- \u00e1ngulo de rotaci\u00f3n (solo para vectoriales)</li> <li><code>spacing</code>- espaciado entre letras</li> <li><code>fixed_width</code>- espaciar todos los caracteres a la misma distancia (monoespaciado)</li> </ul> <p>La escala del texto puede ser un n\u00famero entero (int) para fuentes de mapa de bits o un decimal (float) para fuentes vectoriales.</p> <p>El ejemplo:</p> <pre><code>display.set_font(\"bitmap8\")\ndisplay.text(\"Hello World\", 0, 0, scale=2)\n</code></pre> <p>Dibuja \"Hello World\" con la fuente bitmap8 de 16 p\u00edxeles de alto y escala 2x.</p> <p>A veces es posible que necesitemos medir la longitud de una cadena de texto para centrarla o alinearla en la pantalla; se puede hacer con:</p> <pre><code>width = display.measure_text(text, scale, spacing, fixed_width)\n</code></pre> <p>La altura de cada fuente Bitmap est\u00e1 expl\u00edcita en su nombre.</p> <p>Para escribir un solo car\u00e1cter:</p> <pre><code>display.character(char, x, y, scale)\n</code></pre> <p>Se utiliza un <code>char</code> del c\u00f3digo ASCII decimal. Tenemos que tener en cuenta que no todos los caracteres son compatibles.</p> <p>Por ejemplo:</p> <pre><code>display.set_font(\"bitmap8\")\ndisplay.character(38, 0, 0, scale=2)\n</code></pre> <p>Dibuja un signo ampersand (&amp;) en una versi\u00f3n escalada 2x de 16 p\u00edxeles de alto de la fuente 'bitmap8'.</p>"},{"location":"upy/picographics/#formas-basicas","title":"Formas b\u00e1sicas","text":""},{"location":"upy/picographics/#linea","title":"L\u00ednea","text":"<p>Para dibujar una recta entre dos puntos dados usamos:</p> <pre><code>display.line(x1, y1, x2, y2)\n</code></pre> <p>Las coordenadas x1,y1 definen el punto de inicio y x2,y2 el punto final de la recta.</p> <p>Si necesitamos grosor en la l\u00ednea mayor que el que tiene por defecto podemos hacer:</p> <pre><code>display.line(x1, y1, x2, y2, thickness)\n</code></pre>"},{"location":"upy/picographics/#circulo","title":"C\u00edrculo","text":"<p>Para dibujar un c\u00edrculo hacemos:</p> <pre><code>display.circle(x, y, r)\n</code></pre> <p>Siendo el punto x,y el centro del c\u00edrculo y 'r' su radio.</p>"},{"location":"upy/picographics/#rectangulo","title":"Rect\u00e1ngulo","text":"<p>Dibujamos un rect\u00e1ngulo haciendo:</p> <pre><code>display.rectangle(x, y, w, h)\n</code></pre> <p>El rect\u00e1ngulo tiene un v\u00e9rtice en X,y a partir del cual se establecen el ancho (w) y el alto (h).</p>"},{"location":"upy/picographics/#triangulo","title":"Tri\u00e1ngulo","text":"<p>Se dibuja as\u00ed:</p> <pre><code>display.triangle(x1, y1, x2, y2, x3, y3)\n</code></pre> <p>Cada par de coordenadas definen un v\u00e9rtice del tri\u00e1ngulo.</p>"},{"location":"upy/picographics/#poligono","title":"Pol\u00edgono","text":"<p>Para dibujar otras formas, podemos proporcionar una lista de puntos a <code>polygon</code>:</p> <pre><code>display.polygon([\n  (0, 10),\n  (20, 10),\n  (20, 0),\n  (30, 20),\n  (20, 30),\n  (20, 20),\n  (0, 20),\n])\n</code></pre>"},{"location":"upy/picographics/#ejemplo-de-dibujo","title":"Ejemplo de dibujo","text":"<pre><code>from picographics import PicoGraphics, DISPLAY_PICO_EXPLORER\n\ndisplay = PicoGraphics(display=DISPLAY_PICO_EXPLORER)\nBLANCO = display.create_pen(255, 255, 255)\ndisplay.set_pen(BLANCO)\ndisplay.line(50,5,150,60)\ndisplay.line(80,5,180,60,3)\ndisplay.circle(50,100,20)\ndisplay.rectangle(100,80,50,40)\ndisplay.triangle(230,10,180,80,240,60)\ndisplay.polygon([\n  (0, 10),\n  (20, 10),\n  (20, 0),\n  (30, 15),\n  (20, 30),\n  (20, 20),\n  (0, 20),\n])\n# Actualiza la pantalla\ndisplay.update()\n</code></pre> <p>El programa lo podemos descargar desde este enlace</p>"},{"location":"upy/picographics/#pixeles","title":"Pixeles","text":"<p>Hacer tareas de dibujar o escribir pixel a pixel es lento y tedioso, pero a veces hay que utilizarlo y para ello tenemos dos opciones:</p> <ul> <li>Pixel a pixel: <code>display.pixel(x,y)</code></li> <li>Tramo horizontal de pixeles: display.pixel_span(x,y,longitud)</li> </ul> <p>En el ejemplo siguiente se utilizan ambas sentencias.</p> <pre><code>from picographics import PicoGraphics, DISPLAY_PICO_EXPLORER\n\ndisplay = PicoGraphics(display=DISPLAY_PICO_EXPLORER)\nBLANCO = display.create_pen(255, 255, 255)\ndisplay.set_pen(BLANCO)\n# dibujo de 4 pixeles contiguos para que se aprecien bien\ndisplay.pixel(20,30)\ndisplay.pixel(20,31)\ndisplay.pixel(21,30)\ndisplay.pixel(21,31)\ndisplay.pixel_span(20,50,80)\ndisplay.update()\n</code></pre>"},{"location":"upy/picographics/#gestion-de-paletas","title":"Gestion de paletas","text":"<p>Los modos P4 y P8 tienen paletas de 16 y 256 colores respectivamente. Se definen colores en la paleta a partir de una lista de tuplas RGB.</p> <pre><code>display.set_palette([\n  (r, g, b),\n  (r, g, b),\n  (r, g, b)\n])\n</code></pre> <p>Es posible modificar la paleta en un color dado redifiniendo el RGB por su \u00edndice:</p> <pre><code>display.update_pen(index, r, g, b)\n</code></pre> <p>Para restablecer una pluma a su valor predeterminado hacemos:</p> <pre><code>display.reset_pen(index)\n</code></pre> <p>Para convertir entre formatos de color tenemos:</p> <ul> <li><code>RGB332_to_RGB</code></li> <li><code>RGB_to_RGB332</code></li> <li><code>RGB565_to_RGB</code></li> <li><code>RGB_to_RGB565</code></li> </ul>"},{"location":"upy/rapida/","title":"Gu\u00eda de refencia r\u00e1pida de RP2","text":"<p>RP2 hace referencia al microcontrolador RP2040.</p> <p>Es muy importante leerse, si a\u00fan no lo hemos hecho, los apartados de \"Introducci\u00f3n\" y \"Firmware y software\" antes de continuar con esta guia r\u00e1pida de MicroPython basada en los contenidos del enlace Quick reference for the RP2.</p>"},{"location":"upy/rapida/#control-general","title":"Control general","text":"<p>Se accede al REPL de MicroPython a trav\u00e9s del puerto serie USB. El tabulador es \u00fatil para averiguar qu\u00e9 m\u00e9todos tiene un objeto. El modo Pegar (ctrl-E) es \u00fatil para pegar una gran cantidad de c\u00f3digo Python en el REPL.</p>"},{"location":"upy/rapida/#el-modulo-machine","title":"El m\u00f3dulo <code>machine</code>","text":"<p>El m\u00f3dulo contiene funciones espec\u00edficas relacionadas con el hardware de una placa concreta. La mayor\u00eda de las funciones de este m\u00f3dulo permiten conseguir acceso directo y sin restricciones a los bloques de hardware de un sistema (como CPU, temporizadores, buses, etc.) y controlarlos.</p> <pre><code>import machine\n\nmachine.freq()          # Obtiene la frecuencia de la CPU\nmachine.freq(240000000) # Establece la frecuencia de la CPU a 240 MHz\n</code></pre> <p>El m\u00f3dulo <code>machine</code> contiene funciones espec\u00edficas relacionadas con el hardware de una placa. La mayor\u00eda de las funciones de este m\u00f3dulo permiten conseguir acceso directo y sin restricciones a los bloques de hardware de un sistema (como CPU, temporizadores, buses, etc.) y controlarlos. Usado incorrectamente, esto puede llevar a un mal funcionamiento, bloqueos o cuelgues, fallos de la placa, y en casos extremos, da\u00f1os en el hardware.</p> <p>Todos los detalles de las funciones est\u00e1n en el m\u00f3dulo <code>machine</code>. Aqu\u00ed solamente se citan.</p> <p>Acceso a memoria <p>El m\u00f3dulo expone tres objetos para el acceso a la memoria.</p> <ul> <li><code>machine.mem8</code>. Lee o escribe 8 bits de memoria.</li> <li><code>machine.mem16</code>. Lee o escribe 16 bits de memoria.</li> <li><code>machine.mem32</code>. Lee o escribe 32 bits de memoria.</li> </ul> <p>Se utiliza la notaci\u00f3n de sub\u00edndice [...] para indexar estos objetos con la direcci\u00f3n teniendo en cuenta que la direcci\u00f3n es la direcci\u00f3n en bytes, independientemente del tama\u00f1o de la memoria a la que se accede.</p> <p>Funciones de reset <ul> <li><code>machine.reset()</code></li> <li><code>machine.soft_reset()</code></li> <li><code>machine.reset_cause()</code></li> <li><code>machine.bootloader([value])</code></li> </ul> <p>Funciones relacionadas con las interrupciones <p>Las siguientes funciones permiten controlar las interrupciones. Algunos sistemas necesitan interrupciones para funcionar correctamente, por lo que desactivarlas durante largos periodos de tiempo puede comprometer la funcionalidad del n\u00facleo, por ejemplo, los temporizadores de vigilancia pueden dispararse inesperadamente. Las interrupciones s\u00f3lo deben desactivarse durante un tiempo m\u00ednimo y luego volver a activarse a su estado anterior. Por ejemplo:</p> <pre><code>import machine\n\n# Desactivar interrupciones\nstate = machine.disable_irq()\n\n# Hacer una peque\u00f1a cantidad de trabajo por tiempo cr\u00edtico\n\n# Habilitar interrupciones\nmachine.enable_irq(state)\n</code></pre> <ul> <li><code>machine.disable_irq()</code></li> <li><code>machine.enable_irq(state)</code></li> </ul> <p>Funciones relacionadas con la alimentaci\u00f3n <ul> <li><code>machine.freq([hz])</code></li> <li><code>machine.idle()</code></li> <li><code>machine.lightsleep([time_ms])</code> - <code>machine.deepsleep([time_ms])</code>.</li> <li><code>machine.wake_reason()</code></li> </ul> <p>Funciones varias <ul> <li><code>machine.unique_id()</code></li> <li><code>machine.time_pulse_us(pin, pulse_level, timeout_us=1000000, /)</code></li> <li><code>machine.bitstream(pin, encoding, timing, data, /)</code></li> <li><code>machine.rng()</code></li> </ul> <p>Constantes <ul> <li>Interrupciones: <code>machine.IDLE</code>, <code>machine.SLEEP</code>, <code>machine.DEEPSLEEP</code></li> <li>Causas de reinicio (reset): <code>machine.PWRON_RESET</code>, <code>machine.HARD_RESET</code>, <code>machine.WDT_RESET</code>, <code>machine.DEEPSLEEP_RESET</code>, <code>machine.SOFT_RESET</code></li> <li>Causas para despertar: <code>machine.WLAN_WAKE</code>, <code>machine.PIN_WAKE</code>, <code>machine.RTC_WAKE</code></li> </ul> <p>Clases <ul> <li> - class Pin</li> <li> - class Signal</li> <li> - class ADC</li> <li> - class ADCBlock</li> <li> - class PWM</li> <li> - class UART</li> <li> - class SPI</li> <li> - class I2C</li> <li> - class I2S</li> <li> - class RTC</li> <li> - class Timer</li> <li> - class WDT</li> <li> - class SD</li> <li> - class SDCard</li> </ul>"},{"location":"upy/rapida/#el-modulo-rp2","title":"El m\u00f3dulo <code>rp2</code>","text":"<p>El m\u00f3dulo <code>rp2</code> contiene funciones y clases espec\u00edficas para el RP2040, tal y como se utiliza en la Raspberry Pi Pico.</p> <pre><code>import rp2\n</code></pre> <p>Todos los detalles de las funciones est\u00e1n en el m\u00f3dulo rp2. Aqu\u00ed solamente se citan.</p> <p>Funciones relacionadas con PIO <ul> <li><code>rp2.asm_pio(*, out_init=None, set_init=None, sideset_init=None, in_shiftdir=0, out_shiftdir=0, autopush=False, autopull=False, push_thresh=32, pull_thresh=32, fifo_join=PIO.JOIN_NONE)</code></li> <li><code>rp2.asm_pio_encode(instr, sideset_count, sideset_opt=False)</code></li> <li><code>rp2.bootsel_button()</code></li> <li><code>classrp2.PIOASMError</code></li> </ul> <p>Instrucciones en lenguaje ensamblador PIO <p>Las m\u00e1quinas de estado PIO se programan en un lenguaje ensamblador personalizado con nueve instrucciones m\u00e1quina b\u00e1sicas. En MicroPython, las rutinas de ensamblado PIO se escriben como una funci\u00f3n de Python precedida del caracter <code>@rp2.asm_pio()</code>, y utilizan la sintaxis de Python. Dichas rutinas soportan variables y aritm\u00e9tica est\u00e1ndar de Python, as\u00ed como las siguientes funciones personalizadas que codifican instrucciones PIO.</p> <ul> <li><code>wrap_target()</code></li> <li><code>wrap()</code></li> <li><code>label(label)</code></li> <li><code>word(instr, label=None)</code></li> <li><code>jmp(label)</code>, <code>jmp(cond, label)</code></li> <li><code>wait(polarity, src, index)</code></li> <li><code>in_(src, bit_count)</code></li> <li><code>out(dest, bit_count)</code></li> <li><code>push()</code>, <code>push(block)</code>, <code>push(noblock)</code>, <code>push(iffull)</code>, <code>push(iffull, block)</code>, <code>push(iffull, noblock)</code></li> <li><code>pull()</code>, <code>pull(block)</code>, <code>pull(noblock)</code>, <code>pull(ifempty)</code>, <code>pull(ifempty, block)</code>, <code>pull(ifempty, noblock)</code></li> <li><code>mov(dest, src)</code></li> <li><code>irq(index)</code>, <code>irq(mode, index)</code></li> <li><code>set(dest, data)</code></li> <li><code>nop()</code></li> <li><code>.side(value)</code></li> <li><code>.delay(value)</code></li> </ul> <p>Clases <ul> <li> - class Flash</li> <li> - class PIO</li> <li> class StateMachine</li> </ul>"},{"location":"upy/rapida/#retardos-y-cronometrajes","title":"Retardos y cronometrajes","text":"<p>Este m\u00f3dulo implementa un subconjunto del m\u00f3dulo CPython correspondiente.</p> <p>El m\u00f3dulo time proporciona funciones para obtener la hora y fecha actuales, medir intervalos de tiempo, y para generar retardos.</p> <p>Unix utiliza la fecha est\u00e1ndar de 1970-01-01 00:00:00 UTC para los sistemas POSIX. Sin embargo, algunos puertos embebidos usan el a\u00f1o 2000-01-01 00:00:00 UTC.</p> <p>Mantener la fecha/hora real del calendario requiere un Reloj en Tiempo Real (RTC). En sistemas con sistema operativo (SO) subyacente (incluyendo algunos RTOS), un RTC puede estar impl\u00edcito. Establecer y mantener la hora real del calendario es responsabilidad del SO/RTOS y se realiza fuera de MicroPython, s\u00f3lo utiliza la API del SO para consultar la fecha/hora. La hora actual del calendario puede establecerse usando la funci\u00f3n machine.RTC().datetime(tuple), y mantenerse por los siguientes medios:</p> <ul> <li>Mediante una bater\u00eda de reserva.</li> <li>Mediante protocolo horario en red (requiere configuraci\u00f3n por parte de un puerto/usuario).</li> <li>Configurado manualmente por un usuario cada vez que se enciende.</li> </ul> <p>Si la hora real del calendario no se mantiene con un sistema/MicroPython RTC, las funciones que vamos a ver a continuaci\u00f3n requieren referencia a la hora absoluta actual y pueden no comportarse como se espera.</p> <p>Uso del m\u00f3dulo <code>time</code>:</p> <pre><code>import time\n\ntime.sleep(1)           # espera 1 segundo\ntime.sleep_ms(500)      # espera 500 milisegundos\ntime.sleep_us(100)       # espera 100 microsegundos\nstart = time.ticks_ms() # obtiene la cuenta en ms\ndelta = time.ticks_diff(time.ticks_ms(), start) # calcula la diferencia de tiempo\n</code></pre> <p>Todos los detalles de las funciones est\u00e1n en el m\u00f3dulo time. Aqu\u00ed solamente se citan.</p> <p>Funciones <ul> <li><code>time.gmtime([secs])</code></li> <li><code>time.localtime([secs])</code></li> <li><code>time.mktime()</code></li> <li><code>time.sleep(seconds)</code></li> <li><code>time.sleep_ms(ms)</code></li> <li><code>time.sleep_us(us)</code></li> <li><code>time.ticks_ms()</code></li> <li><code>time.ticks_us()</code></li> <li><code>time.ticks_cpu()</code></li> <li><code>time.ticks_add(ticks, delta)</code></li> <li><code>time.ticks_diff(ticks1, ticks2)</code></li> <li><code>time.time()</code></li> <li><code>time.time_ns()</code></li> </ul>"},{"location":"upy/rapida/#temporizadores","title":"Temporizadores","text":"<p>El temporizador del sistema del RP2040 proporciona una base de tiempo de microsegundos y genera interrupciones para ello. El temporizador por software est\u00e1 disponible en un n\u00famero ilimitado de ellos (si la memoria lo permite). No hay necesidad de especificar el id del temporizador aunque su valor por defecto (id=-1) es soportado por el momento.</p> <p>Los temporizadores de hardware se ocupan de la temporizaci\u00f3n de periodos y eventos. Los temporizadores son quiz\u00e1s la clase de hardware m\u00e1s flexible y heterog\u00e9nea en MCUs y SoCs, difiriendo enormemente de un modelo a otro. La clase <code>Timer</code> de MicroPython define la operaci\u00f3n base de ejecutar un callback con un periodo dado, y permite a placas espec\u00edficas definir un comportamiento no est\u00e1ndar (que por lo tanto no ser\u00e1 portable a otras placas).</p> <p>Todos los detalles de las funciones est\u00e1n en el m\u00f3dulo machine.Timer. Aqu\u00ed solamente se citan.</p> <p>Constructor <ul> <li><code>class machine.Timer(id, /, ...)</code>. Construye un nuevo objeto temporizador con el <code>id</code> indicado. Si <code>id</code> es -1 construye un temporizador virtual (si lo soporta la placa). <code>id</code> no debe pasarse como argumento.</li> </ul> <p>M\u00e9todos <ul> <li><code>Timer.init(*, mode=Timer.PERIODIC, freq=-1, period=-1, callback=None)</code>. Con</li> <li> - <code>mode</code> que puede ser <code>Timer.ONE_SHOT</code> para que el temporizador se ejecute una vez hasta que expire el periodo configurado del canal; o bien, <code>Timer.PERIODIC</code> para que el temporizador funcione peri\u00f3dicamente a la frecuencia configurada del canal.</li> <li> - <code>freq</code> es la frecuencia del temporizador medida en Hz. El l\u00edmite superior de la frecuencia depende del puerto. Cuando se dan los argumentos <code>freq</code> y <code>period</code>, <code>freq</code> tiene mayor prioridad y <code>period</code> se ignora.</li> <li> - <code>period</code> es el periodo del temporizador en milisegundos.</li> <li> - <code>callback</code>. La llamada de retorno o <code>callback</code> debe tomar un argumento, al que se le pasa el objeto <code>Timer</code>. De lo contrario, se producir\u00e1 una excepci\u00f3n al expirar el temporizador: <code>TypeError:'NoneType' object isn't callable</code></li> <li><code>Timer.deinit()</code></li> </ul> <p>Constantes <ul> <li><code>Timer.ONE_SHOT</code></li> <li><code>Timer.PERIODIC</code></li> </ul> <p>Uso de la clase <code>machine.Timer</code>:</p> <pre><code>from machine import Timer\n\ntemp = Timer(period=5000, mode=Timer.ONE_SHOT, callback=lambda t:print(1))\ntemp.init(period=2000, mode=Timer.PERIODIC, callback=lambda t:print(2))\n</code></pre>"},{"location":"upy/rapida/#pines-y-gpio","title":"Pines y GPIO","text":"<p>Un objeto pin se utiliza para controlar los pines de E/S (tambi\u00e9n conocidos como GPIO - entrada/salida de prop\u00f3sito general). Los objetos pin est\u00e1n com\u00fanmente asociados con un pin f\u00edsico que puede manejar una tensi\u00f3n de salida y leer tensiones de entrada. La clase <code>pin</code> tiene m\u00e9todos para establecer el modo del pin (IN, OUT, etc) y m\u00e9todos para obtener y establecer el nivel l\u00f3gico digital. Para el control anal\u00f3gico de un pin se utiliza la clase <code>ADC</code>.</p> <p>Un objeto pin se construye utilizando un identificador que especifica inequ\u00edvocamente un determinado pin de E/S. Las formas permitidas del identificador y el pin f\u00edsico al que se asigna el identificador son espec\u00edficas del puerto. Las posibilidades para el identificador son un entero, una cadena o una tupla con el puerto y el n\u00famero de pin.</p> <p>Uso de la clase <code>machine.Pin</code>:</p> <pre><code>from machine import Pin\n\np0 = Pin(0, Pin.OUT)    # crea un pin de salida en GPIO0\np0.on()                 # pone el pin p0 a \"on\" (nivel alto)\np0.off()                # pone el pin p0 a \"off\" (nivel bajo)\np0.value(1)             # pone el pin p0 a 1 (nivel alto)\n\np2 = Pin(2, Pin.IN)     # crea un pin de entrada en el pin GPIO2\nprint(p2.value())       # obtiene el valor del nivel del pin (0 o 1)\n\np4 = Pin(4, Pin.IN, Pin.PULL_UP) # habilita la resistencia interna de pull-up\np5 = Pin(5, Pin.OUT, value=1) # pone el pin p5 en estado alto cuando se crea\n</code></pre> <p>Todos los detalles de las funciones est\u00e1n en el m\u00f3dulo machine.Pin. Aqu\u00ed solamente se citan.</p> <p>Constructor <ul> <li> <p><code>class machine.Pin(id, mode=-1, pull=-1, *, value=None, drive=0, alt=-1)</code>, donde:</p> </li> <li> <p> <code>id</code> es la identificaci\u00f3n del pin.</p> </li> <li> <code>mode</code> puede ser <code>Pin.IN</code>, <code>Pin.OUT</code>, <code>Pin.OPEN_DRAIN</code>, <code>Pin.ALT</code>, <code>Pin.ALT_OPEN_DRAIN</code>, <code>Pin.ANALOG</code></li> <li> <code>pull</code> puede ser <code>None</code>, <code>Pin.PULL_UP</code>, <code>Pin.PUL_DOWN</code></li> <li> <code>value</code> es el valor inicial del pin para <code>Pin.OUT</code> o <code>Pin.OPEN_DRAIN</code></li> <li> <code>drive</code> especifica la potencia de salida de algunos puertos</li> <li> <code>alt</code> especifica un funci\u00f3n alternativa para el pin</li> </ul> <p>M\u00e9todos <ul> <li><code>Pin.init(mode=-1, pull=-1, *, value=None, drive=0, alt=-1)</code></li> <li><code>Pin.value([x])</code></li> <li><code>Pin.__call__([x])</code></li> <li><code>Pin.on()</code></li> <li><code>Pin.off()</code></li> <li><code>Pin.irq(handler=None, trigger=Pin.IRQ_FALLING | Pin.IRQ_RISING, *, priority=1, wake=None, hard=False)</code></li> <li><code>Pin.low()</code></li> <li><code>Pin.high()</code></li> <li><code>Pin.mode([mode])</code></li> <li><code>Pin.pull([pull])</code></li> <li><code>Pin.drive([drive])</code></li> </ul> <p>Constantes <ul> <li>Selecciona del modo del pin: <code>Pin.IN</code>, <code>Pin.OUT</code>, <code>Pin.OPEN_DRAIN</code>, <code>Pin.ALT</code>, <code>Pin.ALT_OPEN_DRAIN</code>, <code>Pin.ANALOG</code></li> <li>Selecciona si hay una resistencia pull up/down (None para no pull): <code>Pin.PULL_UP</code>, <code>Pin.PULL_DOWN</code>, <code>Pin.PULL_HOLD</code></li> <li>Selecciona la potencia de la patilla: <code>Pin.DRIVE_0</code>, <code>Pin.DRIVE_1</code>, <code>Pin.DRIVE_2</code></li> <li>Selecciona el tipo de activaci\u00f3n IRQ: <code>Pin.IRQ_FALLING</code>, <code>Pin.IRQ_RISING</code>, <code>Pin.IRQ_LOW_LEVEL</code>, <code>Pin.IRQ_HIGH_LEVEL</code></li> </ul>"},{"location":"upy/rapida/#entradassalidas-programables-pio","title":"Entradas/Salidas programables (PIO)","text":"<p>PIO es \u00fatil para construir interfaces IO de bajo nivel desde cero. En el m\u00f3dulo <code>rp2</code> se han explicado detalles del lenguaje ensamblador.</p> <p>Ejemplo usando PIO para hacer parpadear un LED a 1Hz:</p> <pre><code>from machine import Pin\nimport rp2\n\n@rp2.asm_pio(set_init=rp2.PIO.OUT_LOW)\ndef blink_1hz():\n    # Ciclos: 1 + 7 + 32 * (30 + 1) = 1000\n    set(pins, 1)\n    set(x, 31)                  [6]\n    label(\"delay_high\")\n    nop()                       [29]\n    jmp(x_dec, \"delay_high\")\n\n    # Ciclos: 1 + 7 + 32 * (30 + 1) = 1000\n    set(pins, 0)\n    set(x, 31)                  [6]\n    label(\"delay_low\")\n    nop()                       [29]\n    jmp(x_dec, \"delay_low\")\n\n# Crea e inicializa un StateMachine (maquina de estados) con blink_1hz, salida en Pin(25)\nsm = rp2.StateMachine(0, blink_1hz, freq=2000, set_base=Pin(25))\nsm.active(1)\n</code></pre>"},{"location":"upy/rapida/#uart-bus-serie","title":"UART (bus serie)","text":"<p>Hay dos UARTs, UART0 y UART1. UART0 puede asignarse a GPIO 0/1, 12/13 y 16/17, y UART1 a GPIO \u2158 y 8/9.</p> <pre><code>from machine import UART, Pin\nuart1 = UART(1, baudrate=9600, tx=Pin(4), rx=Pin(5))\nuart1.write('hola')  # escribe 5 bytes\nuart1.read(5) # lee hasta 5 bytes\n</code></pre> <p>Todos los detalles de las funciones est\u00e1n en el m\u00f3dulo machine.UART. Aqu\u00ed solamente se citan.</p> <p>UART implementa el protocolo est\u00e1ndar de comunicaciones serie UART/USART. A nivel f\u00edsico consta de 2 l\u00edneas: RX y TX. La unidad de comunicaci\u00f3n es un car\u00e1cter (no confundir con un car\u00e1cter de cadena) que puede ser de 8 o 9 bits de ancho.</p> <p>Los objetos UART pueden crearse e inicializarse utilizando:</p> <pre><code>from machine import UART\n\nuart = UART(1, 9600)                         # inicializa con la velocidad de transmisi\u00f3n dada\nuart.init(9600, bits=8, parity=None, stop=1) # inicializa con los parametros dados\n</code></pre> <p>Los par\u00e1metros soportados var\u00edan seg\u00fan la placa y para el caso de placas tipo Pyboard, los bits pueden ser 7, 8 o 9. La parada puede ser 1 \u00f3 2. Con <code>parity=None</code>, s\u00f3lo se soportan 8 y 9 bits. Con <code>parity enabled</code>, s\u00f3lo se soportan 7 y 8 bits.</p> <p>Un objeto UART act\u00faa como un objeto stream y la lectura y escritura se realiza utilizando los m\u00e9todos stream est\u00e1ndar:</p> <pre><code>uart.read(10)       # lee 10 caracteres, devuelve un byte\nuart.read()         # lee todos los caracteres disponibles\nuart.readline()     # lee una l\u00ednea\nuart.readinto(buf)  # lee y almacena en el buffer indicado\nuart.write('abc')   # escribe los 3 caracteres\n</code></pre> <p>Constructor <ul> <li><code>class machine.UART(id, ...)</code></li> </ul> <p>M\u00e9todos <ul> <li><code>UART.init(baudrate=9600, bits=8, parity=None, stop=1, *, ...)</code></li> <li><code>UART.deinit()</code></li> <li><code>UART.any()</code></li> <li><code>UART.read([nbytes])</code></li> <li><code>UART.readinto(buf[, nbytes])</code></li> <li><code>UART.readline()</code></li> <li><code>UART.write(buf)</code></li> <li><code>UART.sendbreak()</code></li> <li><code>UART.irq(trigger, priority=1, handler=None, wake=machine.IDLE)</code></li> <li><code>UART.flush()</code></li> <li><code>UART.txdone()</code></li> </ul> <p>Constantes <ul> <li>Fuentes de disparo IRQ: UART.RX_ANY</li> </ul> <p>Hay dos UARTs, UART0 y UART1. UART0 puede asignarse a GPIO 0/1, 12/13 y 16/17, y UART1 a GPIO \u2158 y 8/9.</p>"},{"location":"upy/rapida/#pwm","title":"PWM","text":"<p>Hay 8 generadores PWM independientes llamados slices, cada uno de los cuales tiene dos canales, lo que hace un total de 16 canales PWM que pueden ser sincronizados desde 8Hz hasta 62.5MHz a un <code>machine.freq()</code> de 125MHz. Los dos canales de un slice funcionan a la misma frecuencia, pero pueden tener una tasa de trabajo diferente. Los dos canales se asignan normalmente a pares de pines GPIO adyacentes con n\u00fameros pares/impares. As\u00ed GPIO0 y GPIO1 est\u00e1n en el slice 0, GPIO2 y GPIO3 est\u00e1n en el slice 1, y as\u00ed sucesivamente. Un determinado canal puede ser asignado a diferentes pines GPIO (ver Pinout). Por ejemplo, el canal A de la secci\u00f3n 0 puede asignarse tanto a GPIO0 como a GPIO16.</p> <p>Uso la clase <code>machine.PWM</code>:</p> <pre><code>from machine import Pin, PWM\n\n# crea un objeto PWM a partir de un pin y establece la frecuencia de\n# del slice 0 y el ciclo de trabajo para el canal A\npwm0 = PWM(Pin(0), freq=2000, duty_u16=32768)\npwm0.freq()             # obtiene la frecuencia actual del slice 0\npwm0.freq(1000)         # establece/cambia la frecuencia actual del slice 0\npwm0.duty_u16()         # obtiene el ciclo de trabajo actual del canal A, rango 0-65535\npwm0.duty_u16(200)      # establece el ciclo de trabajo del canal A, rango 0-65535\npwm0.duty_u16(0)        # detiene la salida en el canal A\nprint(pwm0)             # muestra las propiedades del objeto PWM\npwm0.deinit()           # apaga el PWM del slice 0, parando los canales A y B\n</code></pre>"},{"location":"upy/rapida/#adc","title":"ADC","text":"<p>El RP2040 tiene cinco canales ADC (conversi\u00f3n anal\u00f3gica a digital) en total, cuatro de los cuales son ADC basados en SAR (registro de aproximaci\u00f3n sucesiva) de 12 bits: GP26, GP27, GP28 y GP29. La se\u00f1al de entrada para ADC0, ADC1, ADC2 y ADC3 se puede conectar con GP26, GP27, GP28, GP29 respectivamente (en la placa Pico, GP29 est\u00e1 conectado a VSYS). El rango est\u00e1ndar del ADC es de 0-3,3 V. El quinto canal est\u00e1 conectado al sensor de temperatura incorporado y puede utilizarse para medir la temperatura.</p> <p>Uso de la clase machine.ADC:</p> <pre><code>from machine import ADC, Pin\nadc = ADC(Pin(26))     # crea un objeto adc en un pin ADC\nadc.read_u16()         # lee el valor (0-65535) a trav\u00e9s del rango de tensi\u00f3n 0.0v - 3.3v\n</code></pre> <p>La clase ADC proporciona una interfaz para los convertidores anal\u00f3gico-digitales, y representa finalmente que puede muestrear una tensi\u00f3n continua y convertirla en un valor discretizado.</p> <p>Ejemplo de uso:</p> <pre><code>from machine import ADC\n\nadc = ADC(pin)        # create un objeto adc en un pin\nval = adc.read_u16()  # lee un valor analogico en el rango 0-65535\nval = adc.read_uv()   # lee un valor analogico en microvoltios\n</code></pre> <p>Todos los detalles de las funciones est\u00e1n en el m\u00f3dulo machine.ADC. Aqu\u00ed solamente se citan.</p> <p>Constructor <ul> <li><code>class machine.ADC(id, *, sample_ns, atten)</code>, donde <code>sample_ns</code> es el tiempo de muestreo en nanosegundos y <code>atten</code> especifica la atenuaci\u00f3n de entrada.</li> </ul> <p>M\u00e9todos <ul> <li><code>ADC.init(*, sample_ns, atten)</code></li> <li><code>ADC.block()</code></li> <li><code>ADC.read_u16()</code></li> <li><code>ADC.read_uv()</code></li> </ul>"},{"location":"upy/rapida/#bus-spi","title":"Bus SPI","text":""},{"location":"upy/rapida/#software","title":"Software","text":"<p>El software SPI (usando bit-banging) funciona en todos los pines, y se accede a trav\u00e9s de la clase <code>machine.SoftSPI</code>:</p> <pre><code>from machine import Pin, SoftSPI\n\n# construye un bus SoftSPI en los pines indicados\n# polaridad en el estado de reposo de SCK\n# phase=0 indica el primer flanco de SCK, phase=1 significa el segundo\nspi = SoftSPI(baudrate=100_000, polarity=1, phase=0, sck=Pin(0), mosi=Pin(2), miso=Pin(4))\n\nspi.init(baudrate=200000) # establece la velocidad de transmision o baudrate\n\nspi.read(10)            # lee 10 bytes de MISO\nspi.read(10, 0xff)      # lee 10 bytes mientras emite 0xff en MOSI\n\nbuf = bytearray(50)     # crea un buffer\nspi.readinto(buf)       # lee en el buffer indicado (lee 50 bytes en este caso)\nspi.readinto(buf, 0xff) # lee en el buffer indicado mientras emite 0xff en MOSI\n\nspi.write(b'12345')     # escribe 5 bytes en MOSI\n\nbuf = bytearray(4)      # crea un buffer\nspi.write_readinto(b'1234', buf) # escribe en MOSI y lee de MISO en el buffer\nspi.write_readinto(buf, buf) # escribe buf en MOSI y lee MISO en buf\n</code></pre> <p>El bit-banging es un proceso en el que se emula un perif\u00e9rico no disponible utilizando comandos directos de manipulaci\u00f3n de puertos en los pines GPIO.</p> <p>SPI es un protocolo serie s\u00edncrono manejado por un controlador. A nivel f\u00edsico, un bus consta de 3 l\u00edneas: SCK, MOSI, MISO. Varios dispositivos pueden compartir el mismo bus. Cada dispositivo debe tener una se\u00f1al separada, CS (Chip Select), para seleccionar un dispositivo concreto en un bus con el que se produce la comunicaci\u00f3n. La gesti\u00f3n de una se\u00f1al CS debe realizarse en c\u00f3digo de usuario (a trav\u00e9s de la clase <code>machine.Pin</code>).</p> <p>Existen implementaciones de SPI tanto por hardware como por software a trav\u00e9s de las clases <code>machine.SPI</code> y <code>machine.SoftSPI</code>. El hardware SPI utiliza el soporte de hardware del sistema para realizar las lecturas/escrituras y es normalmente eficiente y r\u00e1pido pero puede tener restricciones en los pines que pueden ser utilizados. Software SPI es implementado por bit-banging y puede ser usado en cualquier pin pero no es tan eficiente. Estas clases tienen los mismos m\u00e9todos disponibles y difieren principalmente en la forma en que se construyen.</p> <p>Todos los detalles de las funciones est\u00e1n en el m\u00f3dulo machine.SoftSPI. Aqu\u00ed solamente se citan.</p> <p>Constructores <ul> <li><code>class machine.SPI(id, ...)</code></li> <li><code>class machine.SoftSPI(baudrate=500000, *, polarity=0, phase=0, bits=8, firstbit=MSB, sck=None, mosi=None, miso=None)</code></li> </ul> <p>M\u00e9todos <ul> <li><code>SPI.init(baudrate=1000000, *, polarity=0, phase=0, bits=8, firstbit=SPI.MSB, sck=None, mosi=None, miso=None, pins=(SCK, MOSI, MISO))</code></li> <li><code>SPI.deinit()</code></li> <li><code>SPI.read(nbytes, write=0x00)</code></li> <li><code>SPI.readinto(buf, write=0x00)</code></li> <li><code>SPI.write(buf)</code></li> <li><code>SPI.write_readinto(write_buf, read_buf)</code></li> </ul> <p>Constantes <ul> <li>Para inicializar el controlador del bus SPI: <code>SPI.CONTROLLER</code></li> <li>Establecer el primer bit como bit mas significativo: <code>SPI.MSB</code>, <code>SoftSPI.MSB</code></li> <li>Establecer el primer bit como bit menos significativo: <code>SPI.LSB</code>, <code>SoftSPI.LSB</code></li> </ul>"},{"location":"upy/rapida/#hardware","title":"Hardware","text":"<p>El RP2040 tiene 2 buses hardware SPI a los que se accede a trav\u00e9s de la clase <code>machine.SPI</code> y tiene los mismos m\u00e9todos que el software SPI visto antes:</p> <pre><code>from machine import Pin, SPI\n\nspi = SPI(1, 10_000_000)  # Asignacion por defectdo: sck=Pin(10), mosi=Pin(11), miso=Pin(8)\nspi = SPI(1, 10_000_000, sck=Pin(14), mosi=Pin(15), miso=Pin(12))\nspi = SPI(0, baudrate=80_000_000, polarity=0, phase=0, bits=8, sck=Pin(6), mosi=Pin(7), miso=Pin(4))\n</code></pre>"},{"location":"upy/rapida/#bus-i2c","title":"Bus I2C","text":"<p>I2C es un protocolo de dos hilos para la comunicaci\u00f3n entre dispositivos. A nivel f\u00edsico consta de 2 hilos: SCL y SDA que son las l\u00edneas de reloj y datos respectivamente.</p> <p>Los objetos I2C se crean en un bus espec\u00edfico. Pueden inicializarse cuando se crean, o inicializarse m\u00e1s tarde.</p> <p>Al imprimir el objeto I2C se obtiene informaci\u00f3n sobre su configuraci\u00f3n.</p> <p>Existen implementaciones de I2C tanto por hardware como por software a trav\u00e9s de las clases <code>machine.I2C</code> y <code>machine.SoftI2C</code>. El hardware I2C utiliza el soporte hardware del sistema para realizar las lecturas/escrituras y suele ser eficiente y r\u00e1pido, pero puede tener restricciones en cuanto a los pines que se pueden utilizar. Software I2C es implementado por bit-banging y puede ser usado en cualquier pin pero no es tan eficiente. Estas clases tienen los mismos m\u00e9todos disponibles y difieren principalmente en la forma en que se construyen.</p> <p>El bus I2C requiere resistencias de pull-up tanto en SDA como en SCL para su funcionamiento. Normalmente son resistencias en el rango de 1 a 10 K, conectadas desde cada SDA/SCL a Vcc. Sin ellas, el comportamiento es indefinido y puede ir desde el bloqueo, reset inesperado del watchdog o simplemente valores err\u00f3neos. A menudo, este circuito de pull-up ya est\u00e1 incorporado en la placa MCU o en las placas de sensores, pero no hay ninguna regla al respecto, por lo que debemos comprobarlo en caso de problemas.</p> <p>Ejemplo de uso:</p> <pre><code>from machine import I2C\n\ni2c = I2C(freq=400000)          # crear perif\u00e9rico I2C a una frecuencia de 400kHz\n                                # dependiendo del puerto, pueden ser necesarios par\u00e1metros adicionales\n                                # para seleccionar el perif\u00e9rico y/o los pines a utilizar\n\ni2c.scan()                      # buscar perif\u00e9ricos, devolviendo una lista de direcciones de 7 bits\n\ni2c.writeto(42, b'123')         # escribir 3 bytes en el perif\u00e9rico con direcci\u00f3n de 7 bits 42\ni2c.readfrom(42, 4)             # leer 4 bytes del perif\u00e9rico con direcci\u00f3n de 7 bits 42\n\ni2c.readfrom_mem(42, 8, 3)      # leer 3 bytes de la memoria del perif\u00e9rico 42, comenzando en la \n                                # direcci\u00f3n de memoria 8 del perif\u00e9rico\ni2c.writeto_mem(42, 2, b'\\x10') # escribir 1 byte en la memoria del perif\u00e9rico 42, comenzando en la \n                                # direcci\u00f3n 2 del perif\u00e9rico\n</code></pre>"},{"location":"upy/rapida/#software_1","title":"Software","text":"<p>Software I2C (usando bit-banging) funciona en todos los pines con capacidad de salida, y se accede a trav\u00e9s de la clase <code>machine.SoftI2C</code>:</p> <pre><code>from machine import Pin, SoftI2C\n\ni2c = SoftI2C(scl=Pin(5), sda=Pin(4), freq=100_000)\n\ni2c.scan()              # b\u00fasqueda de dispositivos\n\ni2c.readfrom(0x3a, 4)   # leer 4 bytes del dispositivo con direcci\u00f3n 0x3a\ni2c.writeto(0x3a, '12') # escribe '12' en dispositivo con direcci\u00f3n 0x3a\n\nbuf = bytearray(10)     # crea un buffer con 10 bytes\ni2c.writeto(0x3a, buf)  # escribir el b\u00fafer en el perif\u00e9rico\n</code></pre> <p>Todos los detalles de las funciones est\u00e1n en el m\u00f3dulo machine.SoftI2C. Aqu\u00ed solamente se citan.</p> <p>Constructor <ul> <li><code>classmachine.I2C(id, *, scl, sda, freq=400000, timeout=50000)</code></li> </ul> <p>Los m\u00e9todos son los mismos que en vemos en hardware.</p>"},{"location":"upy/rapida/#hardware_1","title":"Hardware","text":"<p>Se accede al controlador a trav\u00e9s de la clase <code>machine.I2C</code>.</p> <pre><code>from machine import Pin, I2C\n\ni2c = I2C(0)   # default assignment: scl=Pin(9), sda=Pin(8)\ni2c = I2C(1, scl=Pin(3), sda=Pin(2), freq=400_000)\n</code></pre> <p>Todos los detalles de las funciones est\u00e1n en el m\u00f3dulo machine.I2C. Aqu\u00ed solamente se citan.</p> <p>Constructor <ul> <li><code>classmachine.SoftI2C(scl, sda, *, freq=400000, timeout=50000)</code></li> </ul> <p>M\u00e9todos generales <ul> <li><code>I2C.init(scl, sda, *, freq=400000)</code></li> <li><code>I2C.deinit()</code></li> <li><code>I2C.scan()</code></li> </ul> <p>Operaciones primitivas I2C <p>Los siguientes m\u00e9todos implementan las operaciones primitivas del bus controlador I2C y pueden combinarse para realizar cualquier transacci\u00f3n I2C. Se proporcionan si se necesita m\u00e1s control sobre el bus, de lo contrario se pueden utilizar los m\u00e9todos est\u00e1ndar.</p> <ul> <li><code>I2C.start()</code></li> <li><code>I2C.stop()</code></li> <li><code>I2C.readinto(buf, nack=True, /)</code></li> <li><code>I2C.write(buf)</code></li> </ul> <p>Operaciones est\u00e1ndar del bus <p>Los siguientes m\u00e9todos implementan las operaciones est\u00e1ndar de lectura y escritura del controlador I2C dirigidas a un dispositivo perif\u00e9rico determinado.</p> <ul> <li><code>I2C.readfrom(addr, nbytes, stop=True, /)</code></li> <li><code>I2C.readfrom_into(addr, buf, stop=True, /)</code></li> <li><code>I2C.writeto(addr, buf, stop=True, /)</code></li> <li><code>I2C.writevto(addr, vector, stop=True, /)</code></li> </ul> <p>Operadores con memoria <p>Algunos dispositivos I2C act\u00faan como un dispositivo de memoria (o conjunto de registros) desde el que se puede leer y en el que se puede escribir. En este caso hay dos direcciones asociadas con una transacci\u00f3n I2C: la direcci\u00f3n del perif\u00e9rico y la direcci\u00f3n de la memoria. Los siguientes m\u00e9todos son funciones para comunicarse con tales dispositivos.</p> <ul> <li><code>I2C.readfrom_mem(addr, memaddr, nbytes, *, addrsize=8)</code></li> <li><code>I2C.readfrom_mem_into(addr, memaddr, buf, *, addrsize=8)</code></li> <li><code>I2C.writeto_mem(addr, memaddr, buf, *, addrsize=8)</code></li> </ul>"},{"location":"upy/rapida/#bus-i2s","title":"Bus I2S","text":"<p>I2S es un protocolo serie s\u00edncrono utilizado para conectar dispositivos de audio digital. A nivel f\u00edsico, un bus consta de 3 l\u00edneas: SCK, WS, SD. La clase I2S admite el funcionamiento de controlador. El funcionamiento perif\u00e9rico no est\u00e1 soportado.</p> <p>Los objetos I2S pueden crearse e inicializarse utilizando:</p> <pre><code>from machine import I2S\nfrom machine import Pin\n\n# ESP32\nsck_pin = Pin(14)   # Salida de reloj serie\nws_pin = Pin(13)    # Salida de reloj\nsd_pin = Pin(12)    # Salida de datos serie\n\nor\n\n# PyBoards\nsck_pin = Pin(\"Y6\")   # Salida de reloj serie\nws_pin = Pin(\"Y5\")    # Salida de reloj\nsd_pin = Pin(\"Y8\")    # Salida de datos serie\n\naudio_out = I2S(2,\n                sck=sck_pin, ws=ws_pin, sd=sd_pin,\n                mode=I2S.TX,\n                bits=16,\n                format=I2S.MONO,\n                rate=44100,\n                ibuf=20000)\n\naudio_in = I2S(2,\n               sck=sck_pin, ws=ws_pin, sd=sd_pin,\n               mode=I2S.RX,\n               bits=32,\n               format=I2S.STEREO,\n               rate=22050,\n               ibuf=20000)\n</code></pre> <p>Est\u00e1n soportados tres modos de operaci\u00f3n:</p> <ul> <li>blocking:</li> </ul> <pre><code>num_written = audio_out.write(buf) # bloques hasta vaciar buf\n\nnum_read = audio_in.readinto(buf) # bloquea hasta llenar buf\n</code></pre> <ul> <li>non-blocking:</li> </ul> <pre><code>audio_out.irq(i2s_callback)          # i2s_callback es llamado cuando buf se vac\u00eda\nnum_written = audio_out.write(buf)   # retorna inmediatamente\n\naudio_in.irq(i2s_callback)           # i2s_callback es llamado cuando buf se vac\u00eda\nnum_read = audio_in.readinto(buf)    # retorna inmediatamente\n</code></pre> <ul> <li>asyncio:</li> </ul> <pre><code>swriter = asyncio.StreamWriter(audio_out)\nswriter.write(buf)\nawait swriter.drain()\n\nsreader = asyncio.StreamReader(audio_in)\nnum_read = await sreader.readinto(buf)\n</code></pre> <p>Todos los detalles de las funciones est\u00e1n en el m\u00f3dulo machine.I2S. Aqu\u00ed solamente se citan.</p> <p>Constructor <ul> <li><code>classmachine.I2S(id, *, sck, ws, sd, mck=None, mode, bits, format, rate, ibuf)</code></li> </ul> <p>M\u00e9todos <ul> <li><code>I2S.init(sck, ...)</code></li> <li><code>I2S.deinit()</code></li> <li><code>I2S.readinto(buf)</code></li> <li><code>I2S.write(buf)</code></li> <li><code>I2S.irq(handler)</code></li> <li><code>staticI2S.shift(*, buf, bits, shift)</code></li> </ul> <p>Constantes <ul> <li><code>I2S.RX\u00b6</code></li> <li><code>I2S.TX</code></li> <li><code>I2S.STEREO</code></li> <li><code>I2S.MONO</code></li> </ul> <pre><code>from machine import I2S, Pin\n\ni2s = I2S(0, sck=Pin(16), ws=Pin(17), sd=Pin(18), mode=I2S.TX, bits=16, format=I2S.STEREO, rate=44100, ibuf=40000) # crea objeto I2S\ni2s.write(buf)             # escribir b\u00fafer de muestras de audio en el dispositivo I2S\n\ni2s = I2S(1, sck=Pin(0), ws=Pin(1), sd=Pin(2), mode=I2S.RX, bits=16, format=I2S.MONO, rate=22050, ibuf=40000) # crea objeto I2S\ni2s.readinto(buf)          # llena el b\u00fafer con muestras de audio del dispositivo I2S\n</code></pre>"},{"location":"upy/rapida/#reloj-en-tiempo-real-rtc","title":"Reloj en tiempo real (RTC)","text":"<p>El RTC es un reloj independiente que controla la fecha y la hora.</p> <p>Ejemplo de uso:</p> <pre><code>rtc = machine.RTC()\nrtc.datetime((2020, 1, 21, 2, 10, 32, 36, 0))\nprint(rtc.datetime())\n</code></pre> <p>Todos los detalles de las funciones est\u00e1n en el m\u00f3dulo machine.RTC. Aqu\u00ed solamente se citan.</p> <p>Constructor <ul> <li><code>classmachine.RTC(id=0, ...)</code></li> </ul> <p>M\u00e9todos <ul> <li><code>RTC.datetime([datetimetuple])</code></li> <li><code>RTC.init(datetime)</code></li> <li><code>RTC.now()</code></li> <li><code>RTC.deinit()</code></li> <li><code>RTC.alarm(id, time, *, repeat=False)</code></li> <li><code>RTC.alarm_left(alarm_id=0)</code></li> <li><code>RTC.cancel(alarm_id=0)</code></li> <li><code>RTC.irq(*, trigger, handler=None, wake=machine.IDLE)</code></li> </ul> <p>Constantes <ul> <li><code>RTC.ALARM0</code></li> </ul> <pre><code>from machine import RTC\n\nrtc = RTC()\nrtc.datetime((2017, 8, 23, 2, 12, 48, 0, 0)) # establece fecha y hora\n                                             # por ejemplo 2023/11/10 16:12:48\nrtc.datetime() # obtiene fecha y hora\n</code></pre>"},{"location":"upy/rapida/#temporizador-wdt-watchdog","title":"Temporizador WDT (Watchdog)","text":"<p>El RP2040 tiene un watchdog que es un temporizador de cuenta atr\u00e1s que puede reiniciar partes del chip si llega a cero.</p> <p>El WDT se utiliza para reiniciar el sistema cuando la aplicaci\u00f3n se bloquea y termina en un estado no recuperable. Una vez iniciado no puede ser detenido o reconfigurado de ninguna manera. Despu\u00e9s de habilitarlo, la aplicaci\u00f3n debe \"alimentar\" al watchdog peri\u00f3dicamente para evitar que expire y reinicie el sistema.</p> <p>Ejemplo de uso:</p> <pre><code>from machine import WDT\nwdt = WDT(timeout=2000)  # habilitarlo con un tiempo de espera de 2s\nwdt.feed()\n</code></pre> <p>Todos los detalles de las funciones est\u00e1n en el m\u00f3dulo machine.WDT. Aqu\u00ed solamente se citan.</p> <p>Constructor <ul> <li><code>classmachine.WDT(id=0, timeout=5000)</code></li> </ul> <p>M\u00e9todos <ul> <li><code>WDT.feed()</code></li> </ul> <pre><code>from machine import WDT\n\n# activar el WDT con un tiempo de espera de 5s (1s es el m\u00ednimo)\nwdt = WDT(timeout=5000)\nwdt.feed()\n</code></pre>"},{"location":"upy/rapida/#drive-un-hilo-onewire","title":"Drive un hilo (OneWire)","text":"<p>El controlador OneWire est\u00e1 implementado en software y funciona en todos los pines:</p> <pre><code>from machine import Pin\nimport onewire\n\now = onewire.OneWire(Pin(12)) # crear un bus OneWire en GPIO12\now.scan()               # devuelve una lista de dispositivos en el bus\now.reset()              # reset del bus\now.readbyte()           # lee un byte\now.writebyte(0x12)      # escribe un byte en el bus\now.write('123')         # escribe bytes en el bus\now.select_rom(b'12345678') # seleccionar un dispositivo espec\u00edfico por su c\u00f3digo ROM\n</code></pre> <p>Existe un controlador espec\u00edfico para los dispositivos DS18S20 y DS18B20:</p> <pre><code>import time, ds18x20\nds = ds18x20.DS18X20(ow)\nroms = ds.scan()\nds.convert_temp()\ntime.sleep_ms(750)\nfor rom in roms:\n    print(ds.read_temp(rom))\n</code></pre> <p>Hay que asegurarse de poner una resistencia pull-up de 4.7k en la l\u00ednea de datos. Tengase en cuenta que el m\u00e9todo <code>convert_temp()</code> debe ser llamado cada vez que desee muestrear la temperatura.</p>"},{"location":"upy/rapida/#neopixel-y-driver-apa106","title":"NeoPixel y driver APA106","text":"<p>Uso de los m\u00f3dulos <code>neopixel</code> y <code>apa106</code>:</p> <pre><code>from machine import Pin\nfrom neopixel import NeoPixel\n\npin = Pin(0, Pin.OUT)   # pone GPIO0 como salida para el drive NeoPixels\nnp = NeoPixel(pin, 8)   # crea el drive NeoPixel en GPIO0 para 8 pixels\nnp[0] = (255, 255, 255) # pone el pixel 0 (primero) a blanco\nnp.write()              # escribe datos en todos los pixeles\nr, g, b = np[0]         # obtiene el color del primer pixel\n</code></pre> <p>El controlador APA106 extiende NeoPixel, pero internamente utiliza un orden de colores diferente:</p> <pre><code>from apa106 import APA106\nap = APA106(pin, 8)\nr, g, b = ap[0]\n</code></pre>"},{"location":"upy/ref_clases/","title":"Referencias a clases","text":""},{"location":"upy/ref_clases/#clase-machine","title":"Clase <code>machine</code>","text":"<p>Antes de usar el m\u00f3dulo <code>machine</code> tenemos que a\u00f1adir la sentencia <code>import machine</code> al principio del archivo Python. Algunas de las opciones del m\u00f3dulo son:</p> <ul> <li>machine.freq(freq_val). Cuando 'freq_val' no se especifica devuelve la frecuencia de la CPU actual y si se especifica establece la frecuencia de la CPU.</li> <li>freq_val. Se da en Hz: 125000000Hz (125MHz).</li> <li>machine.reset(). Cuando se invoca a la funci\u00f3n el programa realiza un reset.</li> <li>machine.unique_id(). Obtiene la direcci\u00f3n MAC del dispositivo.</li> <li>machine.idle(). Apaga cualquier funci\u00f3n que no se est\u00e9 utilizando para reducir el consumo de energia durante periodos cortos o largos. Los perif\u00e9ricos siguen funcionando y la ejecuci\u00f3n se reanuda cuando se activa cualquier interrupci\u00f3n.</li> <li>machine.disable_irq(). Desactiva las peticiones de interrupci\u00f3n. Devuelve el estado IRQ anterior, que debe considerarse un valor opaco. Este valor de retorno debe pasarse a la funci\u00f3n enable_irq() para restaurar las interrupciones a su estado original, antes de llamar a disable_irq().</li> <li>machine.enable_irq(state). Rehabilita las peticiones de interrupci\u00f3n. El par\u00e1metro state debe ser el valor devuelto por la \u00faltima llamada a la funci\u00f3n disable_irq().</li> <li>machine.time_pulse_us(pin, pulse_level, timeout_us=1000000, /). Cronometra un pulso externo en el pin indicado y devuelve la duraci\u00f3n del pulso en microsegundos. El argumento pulse_level debe ser 0 para medir el tiempo de un pulso bajo y 1 para medir el tiempo de un pulso alto.</li> </ul> <p>Si el valor de entrada actual del pin es diferente a pulse_level, la funci\u00f3n primero (1) espera hasta que la entrada del pin sea igual a pulse_level, despu\u00e9s (2) multiplica por la duraci\u00f3n en que el pin es igual a pulse_level. Si el pin ya es igual a pulse_level, la temporizaci\u00f3n comienza directamente.</p> <p>La funci\u00f3n devolver\u00e1 -2 si hubo tiempo de espera para la condici\u00f3n marcada con (1) arriba, y -1 si hubo tiempo de espera durante la medici\u00f3n principal, marcada (2) arriba. El tiempo de espera es el mismo para ambos casos y viene dado por timeout_us (que est\u00e1 en microsegundos).</p>"},{"location":"upy/ref_clases/#clase-time","title":"Clase <code>time</code>","text":"<p>Este m\u00f3dulo implementa un subconjunto del m\u00f3dulo CPython correspondiente.</p> <p>El m\u00f3dulo time proporciona funciones para obtener la hora y fecha actuales, medir intervalos de tiempo, y para generar retardos.</p> <p>Unix utiliza la fecha est\u00e1ndar de 1970-01-01 00:00:00 UTC para los sistemas POSIX. Sin embargo, algunos puertos embebidos usan el a\u00f1o 2000-01-01 00:00:00 UTC.</p> <p>Mantener la fecha/hora real del calendario requiere un Reloj en Tiempo Real (RTC). En sistemas con sistema operativo (SO) subyacente (incluyendo algunos RTOS), un RTC puede estar impl\u00edcito. Establecer y mantener la hora real del calendario es responsabilidad del SO/RTOS y se realiza fuera de MicroPython, s\u00f3lo utiliza la API del SO para consultar la fecha/hora. La hora actual del calendario puede establecerse usando la funci\u00f3n machine.RTC().datetime(tuple), y mantenerse por los siguientes medios:</p> <ul> <li>Mediante una bater\u00eda de reserva.</li> <li>Mediante protocolo horario en red (requiere configuraci\u00f3n por parte de un puerto/usuario).</li> <li>Configurado manualmente por un usuario cada vez que se enciende.</li> </ul> <p>Si la hora real del calendario no se mantiene con un sistema/MicroPython RTC, las funciones que vamos a ver a continuaci\u00f3n requieren referencia a la hora absoluta actual y pueden no comportarse como se espera.</p> <p>Antes de utilizar el m\u00f3dulo <code>time</code> tenemos que a\u00f1adir la sentencia <code>import time</code> al principio del archivo Python. Algunas de las opciones del m\u00f3dulo son:</p> <ul> <li>time.sleep(seconds). Detener el n\u00famero de segundos especificado por seconds, que puede ser un <code>int</code> o un <code>float</code>. Hay placas que no aceptan este argumento como <code>float</code> por lo que se implementan las opciones de milisegundos y microsegundos.</li> <li>time.sleep_ms(ms). Detener durante los milisegundos indicados. La funci\u00f3n intenta proporcionar el retardo de los milisegundos indicados de manera precisa, pero puede tardar mas si el sistema tiene que atender un tarea de mayor prioridad.</li> <li>time.sleep_us(us). Detener durante los microsegundos indicados. La funci\u00f3n intenta proporcionar el retardo de los microsegundos indicados de manera precisa, pero puede tardar mas si el sistema tiene que atender un tarea de mayor prioridad.</li> <li>time.time(). Obtiene la marca de tiempo de la CPU en segundos.</li> <li>time.ticks_ms(). Devuelve el incremento del contador en milisegundos.</li> <li>time.ticks_us(). Devuelve el incremento del contador en microsegundos.</li> <li>time.ticks_cpu(). Similar a las dos anteriores pero mas exacto porque retorna el reloj de la CPU.</li> <li>time.ticks_add(ticks, delta). Obtiene la marca de tiempo despu\u00e9s del desfase, donde ticks puede indicarse con ticks_ms(),ticks_us() o ticks_cpu() y delta puede ser cualquier entero o expresi\u00f3n num\u00e9rica.</li> <li>time.ticks_diff(old_t, new_t). Calcula la diferencia de tiempo entre las dos marcas temporales que pueden indicarse con ticks_ms(),ticks_us() o ticks_cpu(). El tiempo de inicio se indica con old_t y el de finalizaci\u00f3n con new_t.</li> </ul>"},{"location":"upy/ref_clases/#clase-pinid-mode-pull-value","title":"Clase <code>Pin(id, mode, pull, value)</code>","text":"<p>Un objeto pin se utiliza para controlar los pines de E/S (tambi\u00e9n conocidos como GPIO - entrada/salida de prop\u00f3sito general). Los objetos pin est\u00e1n com\u00fanmente asociados con un pin f\u00edsico que puede establecer un nivel de tensi\u00f3n de salida y leer tensiones de entrada. La clase pin tiene m\u00e9todos para establecer el modo del pin (IN, OUT, etc) y m\u00e9todos para obtener y establecer el nivel l\u00f3gico digital. Para el control anal\u00f3gico de un pin, se utiliza la clase ADC.</p> <p>Un objeto pin se construye utilizando un identificador que especifica inequ\u00edvocamente un determinado pin de E/S. Las formas permitidas del identificador y el pin f\u00edsico al que se asigna el identificador son espec\u00edficas del puerto. Las posibilidades para el identificador son un entero, una cadena o una tupla con el puerto y el n\u00famero de pin.</p> <p>Modelos de utilizaci\u00f3n:</p> <pre><code>from machine import Pin\n\n# establece como pin de salida el pin0\np0 = Pin(0, Pin.OUT)\n\n# establece el valor del pin en bajo o en alto\np0.value(0)\np0.value(1)\n\n# crea p2 como pin de entrada y activa la resistencia de pull up del pin\np2 = Pin(2, Pin.IN, Pin.PULL_UP)\n\n# lee e imprime el valor del pin\nprint(p2.value())\n\n# reconfigura el pin0 a modo entrada y pone la resistencia pull down\np0.init(p0.IN, p0.PULL_DOWN)\n\n# configura la llamada a una interrupci\u00f3n (irq callback)\np0.irq(lambda p:print(p))\n</code></pre> <p>Antes de utilizar el m\u00f3dulo <code>Pin</code> tenemos que a\u00f1adir la sentencia <code>from machine import Pin</code> al principio del archivo Python. Algunas de las opciones del m\u00f3dulo son:</p> <ul> <li>id. Un n\u00famero de pin.</li> <li>mode. El modo del pin puede establecerse como Pin.IN, Pin.OUT o Pin.OPEN_DRAIN para pin de entrada, de salida o de drenador abierto respectivamente.</li> <li>Pull. Cuando se activan los modos pull up y pull down internos. No se indica nada ni no queremos poner resistencia pull up o pull down, o Pin.PULL_UP para poner el modo pull-up (salida a nivel alto por defecto), o Pin.PULL_DOWN para establecer modo pull-down (salida a nivel bajo por defecto).</li> <li>Value. Nivel l\u00f3gico de estado del pin, alto o bajo (1 o 0).</li> <li>Pin.init(mode, pull). Inicializa los pines.</li> <li>Pin.value([value]). Obtiene o establece el estado de los pines, devuelve 0 o 1 seg\u00fan el nivel l\u00f3gico de los pines. Sin par\u00e1metro, lee el nivel de entrada. Con un par\u00e1metro dado, se establece el nivel de salida. value puede valer <code>True/False</code> o <code>1/0</code>.</li> <li>Pin.irq(trigger, handler). Configura un manejador de interrupciones para ser llamado cuando el nivel del pin cumple una condici\u00f3n.</li> <li> trigger: Pin.IRQ_FALLING para flanco de bajada y Pin.IRQ_RISING para flanco de subida.</li> <li> Handler: Devuelve la llamada a la funci\u00f3n.</li> </ul>"},{"location":"upy/ref_clases/#clase-pwmpin","title":"Clase PWM(pin)","text":"<p>Antes de cada uso del m\u00f3dulo PWM, tenemos que a\u00f1adir la declaraci\u00f3n <code>from machine import PWM</code> al principio del archivo python. Esta clase proporciona PWM.</p> <p>En el ejemplo siguiente se puede ver el funcionamiento b\u00e1sico del uso de la clase:</p> <pre><code>from machine import PWM # enciende el temporizador de hardware\n\n# crea objeto PWM en un pin y establece la frecuencia y el ciclo de trabajo\npwm = PWM(pin, freq=50, duty_u16=8192)\n\npwm.duty_u16(32768)     # ciclo de trabajo al 50%\n\n# reinicializa con un periodo de 200us (f=5000) y un ciclo de trabajo de 5us\npwm.init(freq=5000, duty_ns=5000)\n\npwm.duty_ns(3000)       # establece la anchura del pulso a 3us\n\npwm.deinit() # apaga el temporizador de hardware\n</code></pre> <p>El constructor de la clase tiene la siguiente sintaxis:</p> <p><code>classmachine.PWM(dest, *, freq, duty_u16, duty_ns, invert)</code></p> <p>que construye y retorna un objeto PWM utilizando los siguientes par\u00e1metros:</p> <ul> <li>dest es quien emite el PWM, que suele ser un objeto <code>machine.Pin</code>.</li> <li>freq es un n\u00famero entero que establece la frecuencia en Hz del ciclo PWM.</li> <li>duty_u16 establece el ciclo de trabajo como un ratio duty_u16/65535.</li> <li>duty_ns establece el ancho del pulso en nanosegundos.</li> <li>invert invierte la salida respectiva si su valor es True</li> </ul> <p>Establecer <code>freq</code> puede afectar a otros objetos PWM si los objetos comparten el mismo generador PWM (esto es espec\u00edfico del hardware). S\u00f3lo se debe especificar un duty_u16 y duty_ns si,ultaneamente. El par\u00e1metro <code>invert</code> no est\u00e1 disponible en todos los puertos.</p> <p>La clase tiene disponibles los siguientes m\u00e9todos:</p> <ul> <li>PWM.init(*, freq, duty_u16, duty_ns). Modifica los ajustes del objeto PWM.</li> <li>PWM.deinit(). Desabilita la salida PWM.</li> <li>PWM.freq([value]). Obtiene o ajusta la frecuencia actual de la salida PWM. Sin argumentos devuelve la frecuencia en Hz. Con un \u00fanico argumento de <code>value</code>, la frecuencia se ajusta a ese valor en Hz. El m\u00e9todo puede generar un ValueError si la frecuencia est\u00e1 fuera del rango v\u00e1lido.</li> <li>PWM.duty_u16([value]). Obtiene o establece el ciclo de trabajo actual de la salida PWM, como un valor de 16 bits sin signo en el rango de 0 a 65535 inclusive. Sin argumentos devuelve el ciclo de trabajo. Con un argumento de <code>value</code> \u00fanico, el ciclo de trabajo se establece en ese valor, medido como la relaci\u00f3n entre value/65535.</li> <li>PWM.duty_ns. Obtiene o establece el ancho de pulso actual de la salida PWM, como un valor en nanosegundos. Sin argumentos devuelve el ancho de pulso en nanosegundos. Con un \u00fanico argumento de value, el ancho de pulso se establece en ese valor.</li> </ul>"}]}