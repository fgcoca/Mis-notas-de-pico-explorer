{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introducci\u00f3n","text":"<p>La placa Pico Explorer es una placa de expansi\u00f3n para la Raspberry Pi Pico o Pico W fabricada por Pimoroni, dise\u00f1ada para el aprendizaje de circuitos b\u00e1sicos de electr\u00f3nica mediante la realizaci\u00f3n de experimentos reales. La placa incluye componentes funcionales como una mini protoboard, controladores de motor, un altavoz, una pantalla con cuatro botones utilizables y conectores de Breakout Garden para m\u00f3dulos de expansi\u00f3n. En la imagen siguiente vemos su aspecto.</p> <p> <p> Aspecto de la placa Pico Explorer</p> <p></p>"},{"location":"#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>Altavoz piezoel\u00e9ctrico</li> <li>Pantalla LCD IPS de 1,54\" (240 x 240px)</li> <li>Cuatro pulsadores controlables por el usuario</li> <li>Dos controladores de motor puente en H (con LED indicador de sobrecorriente)</li> <li>Conectores de pines GPIO y ADC de f\u00e1cil acceso</li> <li>Dos enchufes I2C Breakout Garden</li> <li>Mini placa protoboard de pruebas</li> <li>Patitas adhesivas de silicona</li> <li>Compatible con Raspberry Pi Pico/Pico W</li> <li>No se requiere soldadura (siempre que la Pico tenga las tiras de pines soldados).</li> <li>Dimensiones: aproximadas 117 mm x 63 mm x 20 mm (largo x ancho x alto)</li> <li>Requiere de Bibliotecas C/C++ y MicroPython</li> <li>Esquem\u00e1tico</li> </ul>"},{"location":"#pinouts","title":"Pinouts","text":""},{"location":"#raspberry-pi-pico","title":"Raspberry Pi Pico","text":"<p> <p> Distribuci\u00f3n de pines en la Pi Pico</p> <p></p>"},{"location":"#raspberry-pi-pico-w","title":"Raspberry Pi Pico W","text":"<p> <p> Distribuci\u00f3n de pines en la Pi Pico W</p> <p></p>"},{"location":"#placa-pico-explorer","title":"Placa Pico Explorer","text":"<p> <p> Distribuci\u00f3n de pines en la Pico Explorer</p> <p></p>"},{"location":"#pinout-desde-la-linea-de-comandos","title":"Pinout desde la l\u00ednea de comandos","text":"<p>Voy a exponer a t\u00edtulo de curiosidad el trabajo visto en el blog original no oficial de Raspberry Pi de Matt Hawkins donde podemos encontrar un script .sh que no dibuja el pinout de la Pi Pico en una ventana de terminal cuando lo invocamos. La web es muy recomendable por la cantidad de informaci\u00f3n y ejemplos que desarrolla con la Pi Pico.</p> <p>El script lo podemos descargar desde:</p> <ul> <li>wget https://raw.githubusercontent.com/RPiSpy/pi-pico/main/picopins.sh</li> <li>git clone https://github.com/RPiSpy/pi-pico.git</li> <li>Este enlace</li> </ul> <p>Una vez descargado nos dirigimos al directorio donde est\u00e1 el archivo y hacemos que el script sea ejecutable mediante <code>chmod +x piconpins.sh</code>.</p> <p>Ya podemos ejecutar el script tecleando en la l\u00ednea de comandos <code>./piconpins.sh</code> o <code>sh piconpins.sh</code> para obtener el siguiente resultado:</p> <p> <p> Pinout de la Pi Pico desde la l\u00ednea de comandos</p> <p></p> <p>Si queremos tener disponible el script lo podemos llevar al directorio de sistema /bin. En mi caso le voy a cambiar el nombre a pinoutpico haciendo <code>sudo cp picopins.sh /bin/pinoutpico</code>. El nuevo fichero tambi\u00e9n debe tener permiso de ejecuci\u00f3n, por lo que debemos dirigirnos al directorio /bin y en una terminal teclear <code>sudo chmod +x pinoutpico</code>. Ahora ya podemos invocar <code>pinoutpico</code> desde cualquier directorio siempre que lo necesitemos.</p>"},{"location":"Miscelanea/about/","title":"Autor","text":"<p>Federico Coca</p> <ul> <li> <p>GitHub</p> </li> <li> <p>Twitter</p> </li> <li> <p>Instagram</p> </li> <li> <p>Mas informaci\u00f3n</p> </li> <li> <p>En octubre de 2024 he puesto mi nombre para que viaje en la sonda Europa Clipper a estudiar el sat\u00e9lite Europa mientras gira alrededor del planeta J\u00fapiter. La operaci\u00f3n de la NASA se denomina Message in a bottle teniendo prevista su llegada en el 2030 tras recorrer 2900 millones de kil\u00f3metros (1800 millones de millas). El nombre viaja como firma de un poema escrito por Ada Lim\u00f3n, poetisa laureada estadounidense de ascendencia mexicana. En las im\u00e1genes siguientes vemos un captura del poema y el mensaje en la botella.</p> </li> </ul> <p> <p></p> <p></p>"},{"location":"Miscelanea/lic/","title":"Licencias","text":"<ul> <li> <p>Licencia MIT incluida en la creaci\u00f3n del repositorio.</p> </li> <li> <p>Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0 </p> </li> </ul> <p> <p> </p> <p></p>"},{"location":"Miscelanea/soft/","title":"Software utilizado","text":"<ul> <li> <p>Sistema operativo: Ubuntu Ubuntu 22.04.3 LTS  (Jammy Jellyfish)</p> </li> <li> <p>Paquete ofim\u00e1tico de referencia: LibreOffice</p> </li> <li> <p>Libreria Material para MkDocs</p> </li> <li> <p>Visual Studio Code</p> </li> <li> <p>plantilla-taller</p> </li> <li> <p>Creaci\u00f3n de GIF animados para Ubuntu Peek</p> </li> <li> <p>Sistema principal de capturas de pantalla: Shutter</p> </li> <li> <p>Dibujo 2D vectorial Inkscape</p> </li> <li> <p>Retoque de im\u00e1genes GIMP</p> </li> <li> <p>Generador de tablas para Markdown Tables Generator</p> </li> <li> <p>Editor de Python Thonny</p> </li> </ul>"},{"location":"Miscelanea/webgrafia/","title":"Webgraf\u00eda y bibliograf\u00eda","text":"<ul> <li> <p>Wikipedia</p> </li> <li> <p>Pimoroni</p> </li> <li> <p>Repositorio en Github Pimoroni Pico</p> </li> <li> <p>plantilla-taller desarrollada por Cristobal Contreras para La Jaquer\u00eda</p> </li> <li> <p>Hoja de datos de Pico: Datasheet de Pico</p> </li> <li> <p>Freenove Ultimate Starter Kit for Raspberry Pi</p> </li> <li> <p>El Libro De Python</p> </li> <li> <p>Guia oficial de Raspberry Pi Pico: Get started with MicroPython on Raspberry Pi Pico</p> </li> <li> <p>Raspberry Pi Pico Python SDK</p> </li> <li> <p>Blog original no oficial de Raspberry Pi</p> </li> <li> <p>Documentaci\u00f3n de Raspberry Pi</p> </li> </ul>"},{"location":"actividades/A01/","title":"A01.Parpadeo onboard","text":"<p>Esta actividad marca el punto de partida en la construcci\u00f3n y exploraci\u00f3n de proyectos electr\u00f3nicos con Raspberry Pi Pico.</p> <p>Utilizaremos esta actividad para introducir conocimientos referentes a la carga de programas en la Pi Pico, como se importan archivos Python y por supuesto veremos los conocimientos de Python necesarios para un mejor entendimiento de la misma.</p>"},{"location":"actividades/A01/#enunciado","title":"Enunciado","text":"<p>Se trata de hacer parpadear el LED que incorpora la placa Pi Pico pr\u00f3ximo al conector USB que est\u00e1 conectado a GP25.</p>"},{"location":"actividades/A01/#lista-de-componentes","title":"Lista de componentes","text":"<ul> <li> * 1 Raspberry Pi Pico o Pico W</li> <li> * 1 Cable USB A a USB micro que utilizaremos para programar y alimentar la Pi Pico</li> </ul>"},{"location":"actividades/A01/#esquema-del-circuito","title":"Esquema del circuito","text":"<p>Es tan simple como conectar la Pi Pico al ordenador mediante el cable USB.</p> <p> <p> A01</p> <p></p>"},{"location":"actividades/A01/#programa","title":"Programa","text":""},{"location":"actividades/A01/#codigo","title":"C\u00f3digo","text":"<p>El c\u00f3digo de la actividad es el siguiente:</p> <pre><code>from machine import Pin\nimport time\n\n# Comentar una de las lineas y descomentar la otra segun version de Pico\n\n# led = Pin(25, Pin.OUT)   # LED en la Pi Pico\nled = Pin(\"LED\", Pin.OUT) # LED en la Pi Pico\n\ntry:\n    while True:\n        led.value(1)    # Enciende el LED\n        time.sleep(0.5) # Espera medio segundo\n        led.value(0)    # Apaga el LED\n        time.sleep(0.5) # Espera medio segundo\nexcept:\n    pass\n</code></pre> <p>Copiamos el c\u00f3digo anterior en Thonny sin preocuparnos demasiado por entenderlo en este momento. Antes de continuar lo primero que haremos es guardar el proyecto en nuestro caso le ponemos como nombre el n\u00famero de actividad y lo guardamos en un directorio con el mismo nombre.</p> <p> <p> A01_archivo_y_carpeta_guardados</p> <p></p> <p>Lo que vamos a hacer ahora es, con un c\u00f3digo v\u00e1lido y que realiza una tarea, entender como se ejecuta y como se carga en la Pi Pico. Nos dirigimos al enlace siguiente para ver esto:</p> <p>Firmware y software -&gt; Software Thonny -&gt; Ejecutando c\u00f3digo</p> <p>El programa lo podemos descargar de:</p> <ul> <li>A01_parpadeo LED onboard</li> </ul>"},{"location":"actividades/A01/#explicacion","title":"Explicaci\u00f3n","text":"<p>El programa de la imagen siguiente se ejecutar\u00e1 de arriba a abajo l\u00ednea a l\u00ednea. Cuando se encuentra un bucle ejecutar\u00e1 la sentencia del mismo seg\u00fan su condici\u00f3n.</p> <p> <p> A01_programa</p> <p></p> <p>Para trabajar con la Pi Pico necesitamos importar los m\u00f3dulos correspondientes a las funciones que vamos a emplear, en nuestro caso:</p> <pre><code>from machine import Pin\nimport time\n</code></pre> <p>A continuaci\u00f3n configuramos la patilla GPIO a la que est\u00e1 conectado el LED onboard como salida realizamos una asignaci\u00f3n a <code>led</code>. Se trata del pin GP25, que en la Pi Pico W se llama como objeto \"LED\" mientras que en la Pi Pico se llama por el n\u00famero de pin al que est\u00e1 conectado, el 25 en este caso.</p> <pre><code># led = Pin(25, Pin.OUT)\nled = Pin(\"LED\", Pin.OUT)\n</code></pre> <p>Esto significa que a partir de ahora, el LED que representa a GP25 est\u00e1 en modo de salida.</p> <p>Procedemos a poner a 1 <code>led</code> y el pin GP25 pasar\u00e1 a estar a nivel alto, encendiendo el LED.</p> <pre><code>led.value(1)\n</code></pre> <p>Para apagar el LED basta con poner un estado bajo en GP25:</p> <pre><code>led.value(0)\n</code></pre> <p>Entre encendido y apagado establecemos un tiempo de espera:</p> <pre><code>time.sleep(0.5)\n</code></pre> <p>El c\u00f3digo se ejecuta dentro de un bucle while:</p> <pre><code>while True:\n        led.value(1)\n        time.sleep(0.5)\n        led.value(0)\n        time.sleep(0.5\n</code></pre> <p>Este bucle es infinito puesto que la condici\u00f3n <code>True</code> no se cambia y siempre es cierta. </p> <p>Siempre es conveniente poner las instrucciones que pueden causar errores dentro de un bloque <code>try:</code> y las sentencias a ejecutar en caso de error en un bloque <code>except:</code>. En el programa normalmente se ejecutan las sentencias del bloque <code>try:</code>. Cuando se produce un error en la Raspberry Pi Pico se ejecutar\u00e1n las del bloque <code>except</code>. En este caso en <code>except</code> se pone la sentencia <code>pass</code>, que no hace nada, est\u00e1ndo su utilidad en marcar de forma completa la estructura del c\u00f3digo.</p> <pre><code>try:\n    while True:\n    ...\nexcept:\n    pass\n</code></pre> <p>MicroPython utiliza sangr\u00edas para distinguir diferentes bloques de c\u00f3digo. El n\u00famero de sangr\u00edas es modificable, pero debe ser consistente a lo largo de un bloque. Si la sangr\u00eda del mismo bloque de c\u00f3digo es inconsistente, causar\u00e1 errores cuando se ejecute el programa.</p>"},{"location":"actividades/estructura/","title":"Estructura","text":"<p>Las actividades van a mantener la siguiente estructura de manera gen\u00e9rica:</p> <ul> <li> <p>Enunciado describiendo el objetivo que persigue la actividad</p> </li> <li> <p>Lista de componentes con indicaci\u00f3n de los datos necesarios para implementar el programa.</p> </li> <li> <p>Esquema del circuito.</p> </li> <li> <p>C\u00f3digo del programa que resuelve la actividad.</p> </li> <li> <p>Conceptos te\u00f3ricos referentes a Thonny. Los encontraremos en:</p> </li> </ul> <p>Firmware y software -&gt; Software Thonny</p> <ul> <li>Conceptos te\u00f3ricos referentes al componente o componentes utilizados. Los encontraremos en:</li> </ul> <p>Conceptos b\u00e1sicos de electr\u00f3nica</p> <p>Los principios b\u00e1sicos del lenguaje los tenemos descritos en el apartado Python y sus diferentes entradas.</p>"},{"location":"guias/control/","title":"Estructuras de control","text":"<p>Los programas se ejecutan de manera secuencial l\u00ednea tras l\u00ednea de c\u00f3digo, pero existen muchas situaciones en las que nos va a interesar que esto no sea as\u00ed, como por ejemplo hacer dos cosas diferentes seg\u00fan el valor de una variable o repetir un determinado n\u00famero de veces o hasta que se cumpla una condici\u00f3n dada ciertas instrucciones. Para realizar estas tareas se utilizan las estructuras de control que vamos a describir seguidamente.</p>"},{"location":"guias/control/#condicional-if","title":"Condicional if","text":"<p>En este apartado vamos en primer lugar a estudiar la funci\u00f3n if para posteriormente ver como realizar una instrucci\u00f3n muy \u00fatil que existe en otros lenguajes, pero no en Python, se trata de <code>switch</code>.</p>"},{"location":"guias/control/#if","title":"if","text":""},{"location":"guias/control/#switch","title":"Switch","text":""},{"location":"guias/control/#bucle-for","title":"Bucle for","text":""},{"location":"guias/control/#range","title":"Range","text":""},{"location":"guias/control/#bucle-while","title":"Bucle While","text":""},{"location":"guias/control/#break","title":"Break","text":""},{"location":"guias/control/#continue","title":"Continue","text":""},{"location":"guias/datos/","title":"Datos en Python","text":"<p>En Python, al igual que en programaci\u00f3n en general, los tipos de datos especifican el tipo de datos que puede almacenarse en una variable.</p>"},{"location":"guias/datos/#numericos","title":"Num\u00e9ricos","text":"<p>Contienen valores num\u00e9ricos y sabemos que:</p> <ul> <li>Los n\u00fameros enteros son de tipo int</li> <li>Los fraccionarios son de tipo float</li> <li>La divisi\u00f3n (/) siempre devuelve un n\u00famero en coma flotante</li> <li>Para obtener la parte entera de una divisi\u00f3n se usa el operador //</li> <li>Para calcular el resto de una divisi\u00f3n se usa el operador %</li> <li>Para calcular potencias podemos usar el operador **</li> <li>Los par\u00e9ntesis se pueden usar para agrupar expresiones</li> <li>El signo igual (=) se utiliza para asignar un valor (n\u00fameros, booleanos, cadenas, \u2026) a una variable</li> <li>El tipo de la variable ser\u00e1 el del dato asignado, no se declara el tipo de la variable al crearla</li> <li>Por convenci\u00f3n el nombre comienza en min\u00fascula y si son varias palabras se unen por gui\u00f3n bajo</li> </ul> <p>Los tipos b\u00e1sicos de datos son:</p> <ul> <li><code>int</code>: n\u00fameros enteros con signo sin l\u00edmite de tama\u00f1o, ejemplo: entero = 5</li> <li><code>float</code>: n\u00fameros reales, decimales o de coma flotante con precisi\u00f3n de hasta 15 decimales, ejemplo: real = 5.6</li> <li><code>complex</code>: n\u00fameros complejos, por ejemplo 5.5 - 5j</li> <li>Para averiguar el tipo de dato usamos la funci\u00f3n <code>type()</code>.</li> </ul> <p>Podemos realizar conversi\u00f3n de tipos as\u00ed:</p> <ul> <li>A entero int(variable)</li> <li>A real float(variable)</li> </ul>"},{"location":"guias/datos/#cadenas","title":"Cadenas","text":"<p>Contienen secuencias de caracteres. Una cadena es una secuencia de caracteres representada entre comillas simples o dobles.</p> <p>Las cadenas pueden estar encerradas entre comillas simples ('...') o dobles (\"...\") con el mismo resultado. Podemos usar  para incluir comillas en una cadena.</p> <p>La funci\u00f3n print() devuelve la cadena que encierra entre los par\u00e9ntesis, omitiendo las comillas que la encierran.</p> <p>En la imagen siguiente se ven varios ejemplos con cadenas utilizando como editor el IDLE que por defecto se instala con Python y que se abre desde una terminal simplemente invocando a Python.</p> <p> <p> Cadenas en el IDLE</p> <p></p> <p>Una cadena raw (cruda) se interpreta tal como se escribe, es decir, se omiten los caracteres especiales expresados con . Las cadenas raw se escriben entrecomilladas y van precedidas del car\u00e1cter 'r'. En la imagen vemos un ejemplo.</p> <p> <p> Cadena cruda en el IDLE</p> <p></p> <p>Es posible aplicar la operaci\u00f3n de multiplicar a textos haciendo que estos se repitan. En la imagen siguientes vemos ejemplos de concatenaci\u00f3n y multiplicaci\u00f3n, as\u00ed como un error cometido.</p> <p> <p> Concatenar y multiplicar textos en el IDLE</p> <p></p>"},{"location":"guias/datos/#secuencias","title":"Secuencias","text":"<p>Contienen colecciones de datos, como las listas, las tuplas, las colecciones de datos (set) o los diccionarios.</p> <p>Una lista es una colecci\u00f3n ordenada de elementos similares o de distinto tipo separados por comas y encerrados entre corchetes [ ].</p> <p>Tupla es una secuencia ordenada de elementos, igual que una lista. La \u00fanica diferencia es que las tuplas son inmutables. Una vez creadas, las tuplas no pueden modificarse. En Python, se utilizan los par\u00e9ntesis () para almacenar los elementos de una tupla.</p> <p>Las colecciones de datos son un conjunto desordenada de elementos \u00fanicos. Una colecci\u00f3n de datos se define por valores separados por comas dentro de llaves { }.</p> <p>Un diccionario es una colecci\u00f3n ordenada de elementos. Almacena los elementos como pares clave/valor. Siendo las claves identificadores \u00fanicos que se asocian a cada valor.</p> <p>Estudiaremos estos \u00faltimos tipos mas extensamente cuando los necesitemos.</p> <p>Los datos de tipo booleano solamente pueden contener <code>True</code> o <code>False</code>.</p> <p>Dado que en programaci\u00f3n Python todo es un objeto, los tipos de datos son en realidad clases y las variables son instancias(objeto) de estas clases.</p>"},{"location":"guias/intro/","title":"Introducci\u00f3n a Python","text":""},{"location":"guias/intro/#que-es-python-y-de-donde-viene","title":"\u00bfQue es Python y de donde viene?","text":"<p>Una breve introducci\u00f3n a cosas de Python que nos pueden ayudar con la gu\u00eda de MicroPython. Al final se trata el asunto de los permisos en Linux, que aunque sea un poco \"off topic\" puede resultar \u00fatil.</p>"},{"location":"guias/intro/#creador-de-python","title":"Creador de Python","text":"<p>Python es un lenguaje de programaci\u00f3n interpretado (no hay que compilar los programas) cuya filosof\u00eda hace hincapi\u00e9 en una sintaxis que favorezca un c\u00f3digo legible.</p> <p>Python fue creado a finales de los ochenta, por el holand\u00e9s Guido van Rossum en el Centro para las Matem\u00e1ticas y la Inform\u00e1tica (CWI, Centrum Wiskunde &amp; Informatica), en los Pa\u00edses Bajos.</p> <p>El nombre del lenguaje proviene de la afici\u00f3n de su creador por los humoristas brit\u00e1nicos Monty Python y no de la serpiente del mismo nombre. Aunque se suele usar un s\u00edmbolo con una serpiente pit\u00f3n para representarlo, de ah\u00ed la normal confusi\u00f3n.</p> <p>Se trata de un lenguaje de programaci\u00f3n multiparadigma o que soporta m\u00e1s de un paradigma de programaci\u00f3n, representando un paradigma un enfoque particular o filosof\u00eda para la construcci\u00f3n del software. Python soporta:</p> <ul> <li>Orientaci\u00f3n a objetos. En la programaci\u00f3n orientada a objetos (OOP) los objetos manipulan los datos de entrada para la obtenci\u00f3n de datos de salida espec\u00edficos, donde cada objeto ofrece una funcionalidad especial. Los objetos permiten la agrupaci\u00f3n en librer\u00edas y usualmente permiten al usuario la creaci\u00f3n de sus propias librer\u00edas. Se basa en t\u00e9cnicas de herencia, cohesi\u00f3n, abstracci\u00f3n, polimorfismo, acoplamiento y encapsulamiento.</li> <li>Programaci\u00f3n imperativa. Es la forma natural de programar un ordenador, es el estilo de programaci\u00f3n que se utiliza en el ensamblador y el m\u00e1s cercano a la m\u00e1quina. Sigue la arquitectura arquitectura cl\u00e1sica de Von Newmann con una memoria donde se almacenan los datos y el programa y una unidad de control que ejecuta las instrucciones del programa, conocida c\u00f3mo contador del programa.</li> <li>Programaci\u00f3n funcional. Es un estilo de programaci\u00f3n cuyo m\u00e9todo b\u00e1sico de computaci\u00f3n es la aplicaci\u00f3n de funciones a sus argumentos.</li> </ul>"},{"location":"guias/intro/#filosofia-python","title":"Filosof\u00eda Python","text":"<p>Es muy parecida a la filosof\u00eda de Unix. El c\u00f3digo que sigue los principios de Python de legibilidad y transparencia se dice que es \"pythonic\". Por el contrario, el c\u00f3digo opaco u ofuscado es bautizado como \"unpythonic\". Los puntos que describen su filosofia son:</p> <ul> <li>Bello es mejor que feo.</li> <li>Expl\u00edcito es mejor que impl\u00edcito.</li> <li>Simple es mejor que complejo.</li> <li>Complejo es mejor que complicado.</li> <li>Plano es mejor que anidado.</li> <li>Disperso es mejor que denso.</li> <li>La legibilidad cuenta.</li> <li>Los casos especiales no son tan especiales como para quebrantar las reglas.</li> <li>Lo pr\u00e1ctico gana a lo puro.</li> <li>Los errores nunca deber\u00edan dejarse pasar silenciosamente.</li> <li>A menos que hayan sido silenciados expl\u00edcitamente.</li> <li>Frente a la ambig\u00fcedad, rechaza la tentaci\u00f3n de adivinar.</li> <li>Deber\u00eda haber una -y preferiblemente s\u00f3lo una- manera obvia de hacerlo.</li> <li>Aunque esa manera puede no ser obvia al principio a menos que usted sea holand\u00e9s (en clara referencia a su autor).</li> <li>Ahora es mejor que nunca.</li> <li>Aunque nunca es a menudo mejor que ya mismo.</li> <li>Si la implementaci\u00f3n es dif\u00edcil de explicar, es una mala idea.</li> <li>Si la implementaci\u00f3n es f\u00e1cil de explicar, puede que sea una buena idea.</li> <li>Los espacios de nombres (namespaces) son una gran idea \u00a1Hagamos m\u00e1s de esas cosas!</li> </ul> <p>El Zen de Python viene incorporado (en ingl\u00e9s) a partir de la versi\u00f3n 2.1.2 y podemos invocarlo con <code>import this</code> abriendo Python en una terminal en un sistema en el que lo tengamos instalado, l\u00f3gicamente.</p> <p> <p> Arrastrar y soltar un fragmento de c\u00f3digo</p> <p></p>"},{"location":"guias/operaradores/","title":"Operadores en Python","text":"<p>Los operadores son s\u00edmbolos especiales que realizan operaciones con variables y valores.</p> <p>A continuaci\u00f3n tenemos una lista de los diferentes tipos de operadores de Python:</p> <ul> <li>Operadores aritm\u00e9ticos</li> <li>Operadores de asignaci\u00f3n</li> <li>Operadores de Comparaci\u00f3n</li> <li>Operadores L\u00f3gicos</li> <li>Operadores Bitwise</li> <li>Operadores especiales</li> </ul>"},{"location":"guias/operaradores/#operadores-aritmeticos","title":"Operadores aritm\u00e9ticos","text":"<p>Los operadores aritm\u00e9ticos se utilizan para realizar operaciones matem\u00e1ticas como sumas, restas, multiplicaciones, etc.</p> <p> Operador Descripci\u00f3n Ejemplo + Suma o concatenaci\u00f3n en textos <code>5+3=8</code>, <code>\"Hola\" + \"Mundo\" = \"Hola Mundo</code> - Diferencia <code>6-3=3</code> * Multiplicaci\u00f3n <code>3*3=9</code> / Divisi\u00f3n <code>6/2=3</code> // Parte entera de un cociente <code>10//3=3</code> % Resto de un cociente <code>10%3=1</code> ** Potenciaci\u00f3n <code>5**2=25</code> <p></p>"},{"location":"guias/operaradores/#operadores-de-asignacion","title":"Operadores de asignaci\u00f3n","text":"<p>Los operadores de asignaci\u00f3n se utilizan para asignar valores a variables.</p> <p> Operador Descripci\u00f3n Ejemplo = Asignaci\u00f3n <code>x=4</code>, <code>a = a + 1</code> += Suma y asignaci\u00f3n <code>x+=1</code> equivale a <code>x = x + 1</code> -= Diferencia y asignaci\u00f3n <code>x-=1</code> equivale a <code>x = x - 1</code> *= Multiplicaci\u00f3n y asignaci\u00f3n <code>x*=3</code> equivale a <code>x = x * 3</code> /= Divisi\u00f3n y asignaci\u00f3n <code>x/=3</code> equivale a <code>x = x / 3</code> %= Asignaci\u00f3n de restos <code>x%=3</code> equivale a <code>x = x % 3</code> **= Asignaci\u00f3n de exponentes <code>x**=3</code> equivale a <code>x = x ** 3</code> <p></p>"},{"location":"guias/operaradores/#operadores-de-comparacion","title":"Operadores de Comparaci\u00f3n","text":"<p>Los operadores de comparaci\u00f3n comparan dos valores/variables y devuelven un resultado booleano: Verdadero o Falso <code>True</code> o <code>False</code>.</p> <p> Operador Descripci\u00f3n Ejemplo == Igual a <code>2==3</code> retorna <code>False</code> != Distinto de <code>2!=3</code> retorna <code>True</code> &lt; Menor que <code>2&lt;3</code> retorna <code>True</code> &gt; Mayor que <code>2&gt;3</code> retorna <code>False</code> &lt;= Menor o igual que <code>2&lt;=3</code> retorna <code>True</code> &gt;= Mayor o igual que <code>2&gt;=3</code> retorna <code>False</code> <p></p>"},{"location":"guias/operaradores/#operadores-logicos","title":"Operadores L\u00f3gicos","text":"<p>Los operadores l\u00f3gicos se utilizan para comprobar si una expresi\u00f3n es Verdadera o Falsa. Se utilizan en la toma de decisiones.</p> <p> Operador Descripci\u00f3n Ejemplo and AND l\u00f3gica <code>a and b #True si a y b son ciertos</code> or OR l\u00f3gica <code>a or b #True si a o b son ciertos</code> not NOT l\u00f3gica <code>not a #True si el operador a es falso</code> <p></p> <p>En la figura siguiente vemos un ejemplo con lo que devuelve en cada caso.</p> <p> <p> Ejemplos en el IDLE de operadores l\u00f3gicos</p> <p></p>"},{"location":"guias/operaradores/#operadores-bitwise","title":"Operadores Bitwise","text":"<p>Los operadores bit a bit o bitwise act\u00faan sobre los operandos como si fueran cadenas de d\u00edgitos binarios. Operan bit a bit, de ah\u00ed su nombre.</p> <p> Operador Descripci\u00f3n Ejemplo &amp; AND bit a bit <code>5&amp;6 # 101 &amp; 110 = 110 = 4</code> | OR bit a bit <code>5 \\| 6 # 101 \\| 110 = 111 = 7</code> ~ NOT bit a bit <code>~3 # ~011 = 100 = -4</code> ^ XOR bit a bit <code>5^3 # 101^011 = 110 = 6</code> &lt;&lt; Desplazamiento izquierda <code>4&lt;&lt;1 # 100 &lt;&lt; 1 = 1000 = 8</code> &gt;&gt; Desplazamiento derecha <code>4 &gt;&gt; 1 # 100 &gt;&gt; 1 = 010 = 2</code> <p></p>"},{"location":"guias/operaradores/#operadores-especiales","title":"Operadores especiales","text":"<p>El lenguaje Python ofrece algunos tipos especiales de operadores como el operador de identidad (<code>identity</code>) y el operador de pertenencia (<code>membership</code>).</p> <ul> <li>Operadores <code>identity</code></li> </ul> <p>En Python, <code>is</code> e <code>is not</code> se utilizan para comprobar si dos valores se encuentran en la misma parte de la memoria. Dos variables que son iguales no implica que sean id\u00e9nticas. Algunos ejemplos aclaran mejor lo dicho.</p> <pre><code>x1 = 5\ny1 = 5\nx2 = 'Hello'\ny2 = 'Hello'\n\nprint(x1 is not y1)  # False\n\nprint(x2 is y2)  # True\n</code></pre> <p>Vemos que x1 e y1 son enteros con los mismos valores, por lo que son iguales e id\u00e9nticos. Lo mismo ocurre con x2 e y2 (cadenas).</p> <ul> <li>Operadores <code>membership</code></li> </ul> <p>En Python, <code>in</code> y <code>not in</code> son los operadores de pertenencia. Se utilizan para comprobar si un valor o variable se encuentra en una secuencia (cadena, lista, tupla, conjunto y diccionario).</p> <p>En un diccionario s\u00f3lo podemos comprobar la presencia de la clave, no del valor.</p>"},{"location":"guias/permisos/","title":"Permisos en Linux","text":"<p>Aunque no es un tema de Python si es muy probable que necesitemos en alg\u00fan momento cambiar los permisos de un directorio o de un archivo y por eso dejo aqu\u00ed esta peque\u00f1a gu\u00eda.</p>"},{"location":"guias/permisos/#tipos-de-permisos-en-linux","title":"Tipos de permisos en Linux","text":"<p>El comando CHMOD nos da la posibilidad de poder cambiar los permisos de los archivos y directorios combinando entre clases y tipos. Hay cuatro clases:</p> <ul> <li>Propietario (u). Creador del archivo o la carpeta</li> <li>Grupo (g). Usuarios que tendr\u00e1n acceso al archivo o carpeta</li> <li>Otros (o). Todos los usuarios</li> <li>Todos (a). Todos los tipos de usuario (propietario, grupo y otros)</li> </ul> <p>Hay tres tipos de permisos:</p> <ul> <li>Lectura ( r). Permite que el usuario vea el archivo pero no puede realizar cambios en el mismo ni copiarlo o borrarlo.</li> <li>Escritura (w). Se permite que los usuarios que acceden al archivo o carpeta puedan realizar sobre el mismo cualquier tipo de edici\u00f3n, copiar, cortar o borrar.</li> <li>Ejecutar (x). Al activar esta opci\u00f3n, la cual viene por defecto deshabilitada, podemos ejecutar archivos.</li> </ul> <p>Hay tres modificadores para la tarea:</p> <ul> <li>+. Concede el permiso</li> <li>-. Deniega el permiso</li> <li>=. Sobreescribe un permiso con el permiso anterior.</li> </ul> <p>En entornos Unix cada permiso tiene el siguiente valor:</p> <ul> <li>Lectura: 4</li> <li>Escritura: 2</li> <li>Ejecuci\u00f3n: 1</li> </ul>"},{"location":"guias/permisos/#trabajar-con-permisos","title":"Trabajar con permisos","text":"<p>Jugando con sumas de estos valores establecemos distintos permisos, por ejemplo, si queremos dar un permiso de escritura usaremos el 6 = 4 + 2 (Lectura + Escritura). Si queremos que pueda ejecutar usaremos el 7 = 4 + 2 + 1 (Lectura + Escritura + Ejecuci\u00f3n).</p> <p>En la tabla tenemos todos los valores posibles.</p> <p> Dec. Bin. Permiso read write exe 0 000 Sin permisos N N N 1 001 Ejecuci\u00f3n N N Y 2 010 Escritura N Y N 3 011 Lectura y escritura N Y Y 4 100 Lectura Y N N 5 101 Lectura y ejecuci\u00f3n Y N Y 6 110 Lectura y escritura Y Y N 7 111 Lectura, escritura y ejecuci\u00f3n Y Y Y <p></p> <p>El procedimiento para establecer el permiso es muy sencillo. Basta con ir a una terminal y ejecutar la siguiente orden:</p> <pre><code>chmod Tipo-permiso Ruta-Archivo\n</code></pre> <p>Ejemplos para modificar permisos en modo terminal:</p> <pre><code>chmod o=rwx * \u2192 Dar permisos de lectura, escritura y ejecuci\u00f3n a los otros usuarios.\n\nchmod go= * \u2192 Quitar todos los permisos a grupo y los otros usuarios.\n\nchmod 666 /Documentos/curso-python/Ejercicios/holamundo.py\n</code></pre> <p>En sistemas Linux con letras veremos algo como lo siguiente:</p> <ul> <li>0 \u2192 ---  \u2192 sin acceso</li> <li>1 \u2192 --x \u2192 ejecuci\u00f3n</li> <li>2 \u2192 -w- \u2192 escritura</li> <li>3 \u2192 -wx \u2192 escritura y ejecuci\u00f3n</li> <li>4 \u2192 r-- \u2192 lectura</li> <li>5 \u2192 r-x \u2192 lectura y ejecuci\u00f3n</li> <li>6 \u2192 rw- \u2192 lectura y escritura</li> <li>7 \u2192 rwx \u2192 lectura, escritura y ejecuci\u00f3n</li> </ul> <p>Por ejemplo: chmod 777. Le damos a los 3 tipos de usuarios permiso de lectura, ejecuci\u00f3n y escritura (hemos sumado4+2+1).  Si queremos dar permisos de lectura y escritura ser\u00eda 4+2 = 6 y si si lo que queremos es s\u00f3lo dar lectura ser\u00eda 4. Si lo que queremos es dar lectura y ejecuci\u00f3n ser\u00eda de sumar 4 + 1 = 5.</p> <p>Diferentes combinaciones t\u00edpicas:</p> <ul> <li>chmod 755. Permiso de lectura y ejecuci\u00f3n (4+1) a todos los usuarios excepto al propietario que lo tiene completo (lectura, escritura, ejecuci\u00f3n 4+2+1).</li> <li>chmod 666. Permisos de lectura y escritura a todos, excepto ejecuci\u00f3n (4+2). Todos pueden acceder al archivo, leer su contenido y modificarlo.</li> <li>chmod 644. Se suele utilizar para no permitr la escritura a nadie que no sea el propietario. El 755 es similar, lectura y ejecuci\u00f3n aunque este es m\u00e1s restrictivo (s\u00f3lo lectura) y (lectura, escritura para propietario).</li> </ul>"},{"location":"guias/poo/","title":"Programaci\u00f3n Orientada a Objetos","text":"<p>Este apartado se crea especificamente por la dificultad que tiene el tema que vamos a explicar a continuaci\u00f3n:</p> <p>Hay ciertos elementos o dispositivos que van a requerir de una librer\u00eda externa a Python y estas librerias se hacen utilizando las clases. En el editor online de MicroPython de micro:bit se pueden incluir y utilizar este tipo de liber\u00edas. Para centrar un poco el tema vamos a ver:</p> <ul> <li>Las clases en Python de una forma no muy profunda.</li> <li>La utilizaci\u00f3n del men\u00fa Project de python.microbit, necesario para poder incluir librerias</li> <li>Ejemplo de trabajo con una libreria para una LCD I2C.</li> </ul>"},{"location":"guias/poo/#las-clases-en-python","title":"Las clases en Python","text":"<p>La Programaci\u00f3n Orientada a Objetos (POO) es un modelo de programaci\u00f3n que proporciona unas gu\u00edas acerca de c\u00f3mo trabajar con \u00e9l y que est\u00e1 basado en el concepto de clases y objetos.</p> <p>Una clase es una especie de plantilla que define, de forma gen\u00e9rica, como ser\u00e1n los objetos de un determinado tipo. Pongamos por ejemplo que una clase representa a un club, que podemos denominar \"club\". Esta clase puede tener atributos (propiedades) como nombre, edad, profesion. Se pueden implementar como m\u00e9todos (funciones) de esas propiedades comportamientos como socio, socia o imparte_taller.</p> <p>Un ejemplo sencillo de un objeto puede ser un profesor, que puede ser socio por lo que se crea un atributo de profesi\u00f3n y adem\u00e1s puede impartir_taller, por lo que se define un nuevo m\u00e9todo.</p> <p>Una clase en Python es una estructura que permite definir los m\u00e9todos y atributos que definen un objeto. En Python una clase es una plantilla para crear objetos que son instancias de esa clase.</p> <p>En Python, una clase se define mediante la palabra clave <code>class</code>, seguida del nombre de la clase, dos puntos (:) y el cuerpo de la clase. Este cuerpo contiene definiciones de m\u00e9todos y atributos, que pueden ser p\u00fablicos o privados seg\u00fan su acceso.</p> <pre><code>class club:\n    def __init__(self, nombre, edad, profesion):\n        self.nombre = nombre\n        self.edad = edad\n        self.profesion = profesion\n    def saludo(self)\n        print(\"Hola, me llamo \" + self.nombre + \"y soy \" + self.profesion)\n</code></pre> <p>Las principales ventajas de utilizar clases son:</p> <ul> <li>Reutilizaci\u00f3n. Una clase la podemos reutilizar en diferentes partes del programa y en distintos programas. Esto puede ahorrar mucho tiempo y evita repeticiones de c\u00f3digo.</li> <li>Modulaci\u00f3n. El c\u00f3digo de un programa se divide en partes mas peque\u00f1as lo que facilita el mantenimiento y la soluci\u00f3n de problemas.</li> <li>Encapsulaci\u00f3n. Consiste en ocultar la complejidad de un objeto para mostrar solamente una interfaz simple f\u00e1cil de usar para interactuar ese objeto.</li> <li>Polimorfismo. Se trata de implementar el mismo conjunto de m\u00e9todos con diferentes comportamientos para distintos objetos. Esto dota de mayor flexibilidad al dise\u00f1o de programas.</li> </ul> <p>Las principales desventajas de utilizar clases son:</p> <ul> <li>Complejidad. Una clase puede hacer mas dificil de entender y depurar un programa debido al incremento de complejidad.</li> <li>Curva de aprendiza. Aprender Programaci\u00f3n Orientada a Objetos y clases tiene una curva de aprendizaje mas pronunciada, sobre todo cuando se empieza a programar.</li> <li>Abuso. A veces se abusa inncesariamente de las clases en situaciones en las que una funci\u00f3n har\u00eda lo mismo incluso de forma mas eficiente.</li> </ul> <p>Las variables que se definen dentro de las clases se denominan atributos y sirven para almacenar datos de un objeto de esa clase. Se utilizizan para representar propiedades de un objeto.</p> <p>Los atributos pueden ser como las variables normales, enteros, reales, cadenas, listas, tuplas, diccionarios, etc. Adem\u00e1s pueden tener distintos niveles de visibilidad que se indican mediante modificadores de acceso. En Python los modificadores son p\u00fablicos por defecto, lo que significa que son accesibles desde cualquier lugar del programa.</p> <p>Un atributo se define como una variable que se inicializa con el m\u00e9todo <code>__init__</code>. Por ejemplo:</p> <pre><code>class club:\n    def __init__(self, nombre, edad, profesion):\n        self.nombre = nombre\n        self.edad = edad\n        self.profesion = profesion\n</code></pre> <p>En la clase <code>club</code> los atributos nombre, edad y profesion, se definen como se ve en el c\u00f3digo. En este caso los tres son atributos p\u00fablicos de la clase <code>club</code>, que se inicializan con los valores que se proporcionen al crear un objeto de la clase. El acceso a los atributos de un objeto de una clase se utiliza el modificador (.) seguido del nombre del atributo, por ejemplo, para acceder al atributo <code>nombre</code> de un objeto <code>socio</code> de la clase <code>club</code> hariamos:</p> <pre><code>socio1 = socio1.nombre\n</code></pre> <p>Los tipos de atributos son:</p> <ul> <li>P\u00fablicos. Ya hemos indicado que se puede acceder a ellos desde cualquier parte del programa y desde fuera de la clase y que en Python lo son por defecto, por lo que no requieren ning\u00fan modificador de acceso. Se accede a ello con (.).</li> <li>Privados. Solo son accesibles desde la propia clase y se definen con el prefijo (__) seguido del nombre del atributo.</li> <li>Protegidos. Solamente son accesibles desde la propia clase o desde sus clases heredadas. Se utiliza el prefijo \"\" seguido del nombre del atributo para su definici\u00f3n. En Python es simplemente una convenci\u00f3n y si es posible acceder desde fuera de la clase.</li> </ul> <p>En Python se utilizan los m\u00e9todos, que son funciones que se definen dentro de una clase y que se utilizan para hacer operaciones en los objetos creados a partir de esa clase. La definici\u00f3n de un m\u00e9todo se realiza de la misma forma que la de una funci\u00f3n con la diferencia de que en un m\u00e9todo siempre tiene como primer par\u00e1metro el objeto al que se aplicar\u00e1 el m\u00e9todo, que por defecto se llama <code>self</code>.</p> <p>Para utilizar un m\u00e9todo de una clase lo primero que tenemos que hacer es crear un objeto a partir de la clase y as\u00ed poder llamar al m\u00e9todo sobre ese objeto.</p> <p>El objeto <code>self</code> se utiliza como referencia del objeto que se manipula cuando se llama al m\u00e9todo. Al crear una instancia de una clase, necesitamos diferenciar o especificar los atributos de la instancia de los argumentos y otras variables. Y ah\u00ed es donde necesitamos la palabra clave <code>self</code> para especificar que estamos pasando el valor a los atributos de la instancia y no a la variable o argumento local con el mismo nombre.</p> <p>Existen tambi\u00e9n otros m\u00e9todos que se denominan dunder (de double underscore methods) que tienen un doble gui\u00f3n bajo (__) al principio y al final del nombre.</p> <ul> <li>init: Inicializar un objeto cuando se crea una instancia de una clase. Se usa para asignar valores a los atributos de una instancia de clase.</li> <li>str: Se utiliza para devolver una cadena de una instancia de una clase. Es el m\u00e9todo que se llama cuando usamos la funci\u00f3n <code>str()</code> para convertir un objeto en una cadena de caracteres.</li> <li>repr(): M\u00e9todo especial de Python que se utiliza para devolver una cadena legible de un objeto. Se llama cuando usamos la funci\u00f3n repr().</li> </ul> <p>Y bueno, hay mas conceptos y definiciones necesarias para trabajar creando clases, pero como este no es el objetivo, lo vamos a dejar aqu\u00ed que ya es suficiente para manejarnos un poco con clases ya creadas.</p>"},{"location":"guias/sintaxis/","title":"Sintaxis en Python","text":"<p>Se puede decir que sintaxis es el conjunto de reglas que definen como se escribe c\u00f3digo en un determinado lenguaje de programaci\u00f3n, con un paralelismo total con la gramatica de una lengua. Por lo tanto la sintaxis indica la forma en la que debemos escribir las instrucciones de nuestro programa para que se entienda. A diferencia de la sintaxis del lenguaje, en programaci\u00f3n es 100% estricta y no podemos cometer \"faltas de ortografia\". Vamos a ver que peculiaridades tiene el lenguaje Python.</p> <p>Continuando con el paralelismo anterior ocurre exactamente lo mismo en un idioma que en un lenguaje de programaci\u00f3n, solamente por sabernos todas sus palabras no lo hablamos ni programamos correctamente.</p> <p>La forma de escribir un programa en Python es bastante parecida al lenguaje natural. Veamos esto con un sencillo ejemplo:</p> <pre><code># Definimos variable de tipo cadena\ntexto = \"El resultado de a + b*c es: \"\n# Asignamos valores a las variables\na, b, c = 2, 3, 4\n# Realizamos las operaciones y las guardamos en sol\nsol = 2 + 3*4\n# Mostramos resultados\nprint(texto, sol)\n# El resultado obtenido es 14\n</code></pre>"},{"location":"guias/sintaxis/#comentarios","title":"Comentarios","text":"<p>Los comentarios se utilizan para dar informaci\u00f3n complementaria de nuestro c\u00f3digo. Los comentarios no son c\u00f3digo y son ignorados por el interprete de Python. Pueden ser de dos tipos:</p> <ul> <li> <p>Una sola linea: Escribiendo el s\u00edmbolo almohadilla (#) delante del comentario, como los vistos en el ejemplo de mas arriba.</p> </li> <li> <p>Multilinea: Escribiendo triple comillas dobles (\u201c\u201d\u201d) o simples (''') al principio y al final del comentario. Tanto al principio como al final deben ser del mismo tipo.</p> </li> </ul> <p>En los comentarios, pueden incluirse palabras que nos ayuden a identificar adem\u00e1s, el subtipo de comentario:</p> <pre><code># TODO esto es algo por hacer\n# FIXME (arreglarme) esto es algo que debe corregirse\n# XXX esto tambi\u00e9n, es algo que debe corregirse\n</code></pre>"},{"location":"guias/sintaxis/#identation-o-sangria","title":"Identation o sangria","text":"<p>La sangr\u00eda se refiere a los espacios al comienzo de una l\u00ednea de c\u00f3digo. En Python estos espacios se utilizan para definir los bloques de c\u00f3digo. Es posible utilizar (es lo habitual) la tecla de tabulaci\u00f3n para dejar esos espacios.</p> <p>Mientras que en otros lenguajes de programaci\u00f3n la sangr\u00eda en el c\u00f3digo es solo para facilitar la lectura, la sangr\u00eda en Python es muy importante ya que se usa para indicar un bloque de c\u00f3digo.</p> <pre><code>if 5 &gt; 2:\n    print(\"Cinco es mayor que 2\")\n</code></pre> <p>Lo siguiente ser\u00eda un error de sintaxis.</p> <pre><code>if 5 &gt; 2:\nprint(\"Cinco es mayor que 2\")\n</code></pre> <p>El n\u00famero de espacios de la identation puede ser cualquiera siempre que al menos sea un espacio. Siempre hay que usar el mismo n\u00famero de espacios en el mismo bloque de c\u00f3digo y la norma, si no usamos la tabulaci\u00f3n es dejar cuatro espacios.</p> <p>Se puede utilizar el punto y coma (;) para poner dos o mas sentencias en la misma l\u00ednea: <code>a = 2 ; b = 3 ; c = 3</code></p> <p>Hay ocasiones en que una l\u00ednea de c\u00f3digo resulta demasiado larga. En estos casos puede resultar conveniente romper esa l\u00ednea en varias para hacer el c\u00f3digo mas legible.</p> <p>La recomendaci\u00f3n que realiza la guia de estilo para c\u00f3digo Python PEP 8 recomienda que no se excedan los 79 caracteres.</p> <p>Hay dos casos para romper en varias l\u00edneas:</p> <ul> <li>Cuando no hay par\u00e9ntesis. En este caso se a\u00f1ade al final de cada l\u00ednea el conjunto + y se salta a la siguiente.</li> </ul> <pre><code>a = a+1+b+2+c+3 +\\\nd+5+e+f+g+6+7+8+9 +\\\nh+i+j\n</code></pre> <ul> <li>Cuando existen par\u00e9ntesis. En este caso se puede omitir el caracter . Es aplicable a las llamadas a funciones cuando les pasamos par\u00e1metros.</li> </ul> <pre><code>a = (a+1+b+2+c+3 +\nd+5+e+f+g+6+7+8+9 +\nh+i+j)\n</code></pre>"},{"location":"guias/sintaxis/#palabras-reservadas","title":"Palabras reservadas","text":"<p>Son palabras reservadas que tienen un significado especial para el compilador y que no podemos usar para poner nombres a variables o funciones. Todas las palabras, excepto <code>True</code>, <code>False</code> y <code>None</code> se escriben en min\u00fasculas. A continuaci\u00f3n se da un listado de todas las palabras reservadas o keywords:</p> <pre><code>False, None, True, and, as, assert, async, await, break, class, continue, \n\ndef, del, elif, else, except, finally, for, from, global, if, import, in, \n\nis, lambda, nonlocal, not, or, pass, raise, return, try, while, with, yield\n</code></pre> <p>El listado al principio nos puede resultar abrumador, pero imaginemos un lenguaje con tan solo esas palabras y entenderemos que no resultar\u00e1 tan complejo familiarizarse, al menos con las mas usuales.</p>"},{"location":"guias/sintaxis/#identificadores","title":"Identificadores","text":"<p>Los identificadores son los nombres que se dan a variables, clases, m\u00e9todos, etc. No podemos usar palabras reservadas para estos nombres.</p> <p>Algunas reglas que nos pueden resultar \u00fatiles para nombrar idetificadores son:</p> <ul> <li>Los identificadores son sensibles a may\u00fasculas y min\u00fasculas</li> <li>Los identificadores no pueden ser palabras reservadas</li> <li>Los espacios en blanco no est\u00e1n permitidos</li> <li>Un identificador puede ser una secuencia de letras y n\u00fameros. Siempre debe empezar por una letra o por el s\u00edmbolo de subrayado \"_\". El primer car\u00e1cter de un identificador no puede ser un n\u00famero.</li> <li>No podemos utilizar caracteres especiales como la \u00f1, \u00a1, \u00bf o letras con acentos.</li> <li>No podemos utilizar los s\u00edmbolos como !, @, #, $, etc.</li> </ul> <p>Nos va a resultar muy \u00fatil recordar lo siguiente:</p> <ul> <li>Python es un lenguaje que distingue entre may\u00fasculas y min\u00fasculas. Esto significa que <code>Variable</code> y <code>variable</code> no son lo mismo</li> <li>Damos siempre a los identificadores un nombre que tenga sentido. Aunque que <code>c = 10</code> es un perfectamente v\u00e1lido, escribir <code>contador = 10</code> tendr\u00eda m\u00e1s sentido, y ser\u00eda m\u00e1s f\u00e1cil averiguar lo que representa cuando miremo el c\u00f3digo pasado un tiempo.</li> <li>Las palabras m\u00faltiples se pueden separar usando un gui\u00f3n bajo, como por ejemplo <code>esto_es_un_nombre_de_variable_muy_largo</code>.</li> </ul>"},{"location":"guias/sintaxis/#variables-constantes-y-literales","title":"Variables, constantes y literales","text":""},{"location":"guias/sintaxis/#variables","title":"Variables","text":"<p>En programaci\u00f3n, una variable es un nombre que se utiliza para referirse a una posici\u00f3n de memoria donde se almacena un valor. De forma m\u00e1s abstracta, puede considerarse como una caja que almacena un valor. El nombre de la caja es el nombre de la variable y el contenido su valor. Todas las variables constan de tres partes: un nombre, un tipo de dato y un valor. En la figura siguiente vemos tres variables de distintos tipos:</p> <p> <p> Concepto gr\u00e1fico de variable</p> <p>Enlace a la fuente</p> <p></p> <p>La variable <code>name</code> contiene la cadena <code>Bob</code>, la variable <code>winner</code> es cierta y la variable <code>score</code> contiene el valor <code>35</code>.</p> <p>Python no dispone de ning\u00fan comando para declarar variables. Una variable se crea cuando se le asigna valor por primera vez. La t\u00e9cnica de declarar variables es poner un nombre seguido del signo de asignaci\u00f3n (=) y el valor asignado a la variable. En la declaraci\u00f3n es importante tener claro que se distinguen may\u00fasculas de min\u00fasculas y que no est\u00e1n permitidos los caracteres especiales.</p> <p>En Python no se declara de forma explicita el tipo de la variable pues se trata de un lenguaje inferido. Las variables incluso pueden cambiar de tipo desde el que se establece al asignarle valor la primera vez. Es decir, si declaro <code>valor = 5</code> inicialmente la variable ser\u00e1 de tipo entero (int), pero si en el programa se realizan operaciones que al final hacen que <code>valor = 1.33</code> ahora valor es de tipo float. Autom\u00e1ticamente sabe que <code>valor</code> es un n\u00famero entero y declara la variable <code>valor</code> como un <code>int</code>.</p> <p>Aunque no es necesario si es posible especificar el tipo de dato de una variable, haciendo:</p> <pre><code>x = str(22) # x ser\u00e1 la cadena '22'\ny = int(22) # y ser\u00e1 el entero 22\nz = float(22) # z ser\u00e1 el n\u00famero de coma flotante 22.0\n</code></pre> <p>Es posible saber el tipo de una variable en un momento dado con la sentencia <code>type(variable)</code>.</p> <p>Algunas reglas para nombrar variables que podemos tener en cuenta son:</p> <ul> <li>Los nombres pueden tener una combinaci\u00f3n de letras min\u00fasculas o may\u00fasculas o n\u00fameros o el s\u00edmbolo de subrayado \"_\".</li> <li>Crear nombres que tengan sentido, aunque sean largos.</li> <li>Si usamos varias palabras para definir el nombre, estas las separamos por \"_\"</li> <li>Python es sensible a may\u00fasculas y min\u00fasculas.</li> <li>Hay que evitar palabras reservadas en nombres de variables.</li> </ul>"},{"location":"guias/sintaxis/#constantes","title":"Constantes","text":"<p>Una constante no es mas que un tipo especial de variable cuyo valor no puede modificarse.</p> <p>En Python, las constantes suelen declararse y asignarse en un m\u00f3dulo (un nuevo archivo que contiene variables, funciones, etc y que se importa al archivo principal).</p> <p>Veamos c\u00f3mo declaramos constantes en un archivo separado y lo usamos en el archivo principal,</p> <ul> <li>Creamos un archivo que nombramos constantes.py y que contendr\u00e1:</li> </ul> <pre><code>PI = 3.141592\nFUERZA_GRAVEDAD = 9.82\n</code></pre> <ul> <li>Creamos el archivo principal main.py, que contendr\u00e1:</li> </ul> <pre><code>import constantes\n\nprint(constantes.PI)\nprint(constantes.FUERZA_GRAVEDAD)\n</code></pre> <p>En el ejemplo creamos el archivo de m\u00f3dulo constantes.py y asignamos el valor constante a PI y FUERZA_GRAVEDAD.</p> <p>Despu\u00e9s, creamos el archivo main.py e importamos el m\u00f3dulo constantes. Finalmente, imprimimos el valor de cada constante.</p> <p>La convenci\u00f3n es nombrarlas en may\u00fasculas para distinguirlas de las variables.</p>"},{"location":"guias/sintaxis/#literales","title":"Literales","text":"<ul> <li>Num\u00e9ricos</li> </ul> <p>Los literales son representaciones de valores fijos en un programa. Pueden ser n\u00fameros, caracteres, cadenas, etc. Por ejemplo, \"\u00a1Hola, mundo!\", 12, 23.0, \"C\", etc.</p> <p>Los literales num\u00e9ricos son inmutables (no pueden cambiar) y pueden pertenecer a uno de los tres tipos de datos num\u00e9ricos posibles: Entero, Coma flotante y Complejo. Los tipos son:</p> <ul> <li>Decimal. N\u00fameros regulares. Por ejemplo: 5, 22, -40</li> <li>Binario. Deben comenzar por 0b. Por ejemplo: 0b110, 0b11</li> <li>Octal. Deben empezar con 0o. Por ejemplo: 0o13, 0o7</li> <li>Hexadedicmal. Deben empezar con 0x. Por ejemplo 0x13, 0xFF</li> <li>Coma flotante. Contienen el punto decimal. Por ejemplo 10.2, 3.14</li> <li> <p>Complejo. Tienen la forma <code>a + bj</code>. Por ejemplo: 3 - 2j, -4 + j</p> </li> <li> <p>Booleanos</p> </li> </ul> <p>Solamente hay dos literales booleanos <code>True</code> y <code>False</code></p> <ul> <li>Cadenas de caracteres</li> </ul> <p>Los literales de caracteres son caracteres unicode encerrados entre comillas, por ejemplo <code>S</code>. Los literales cadenas de caracteres son cadenas de csaracteres encerradas entre comillas, por ejemplo <code>Python es divertido</code>.</p> <ul> <li>Especiales</li> </ul> <p>En Python existe un literal especial, <code>None</code>. Podemos usarlo, por ejemplo, para especificar una variable nula, por ejemplo:</p> <pre><code>var = None\nprint(var)\n# El resultado ser\u00e1: None\n</code></pre>"},{"location":"inicio/inicio/","title":"Como comenzar","text":"<p>Lo primero que debemos hacer es posicionar nuestra Raspberry Pi Pico o PicoW en su posici\u00f3n teniendo la precuaci\u00f3n de orientarla adecuadamente seg\u00fan nos marca el serigrafiado de la placa que vemos en la imagen siguiente, donde est\u00e1 indicado el conector USB como clara referencia.</p> <p> <p> Serigrafia en la placa Pico Explorer</p> <p></p> <p>Estas notas se van a dedicar a crear programas en MicroPython para RaspBerry Pi Pico, por lo tanto aclaremos algunos conceptos:</p> <ul> <li>Python es un lenguaje de programaci\u00f3n de alto nivel, limpio, elegante. \u00e1gil y sencillo, que facilita el aprendizaje de la programaci\u00f3n dada su curva de aprendizaje.</li> <li> <p>Python no es un lenguaje compilado sino interpretado por lo que se puede experimentar mientras se programa. Dispone de una libreria est\u00e1ndar y de multitud de librerias desarrolladas que permiten realizar tareas complejas de forma mas sencilla que otros lenguajes.</p> </li> <li> <p>MicroPython es un eficiente interprete del lenguaje Python que se ha optimizado para funcionar en microcontroladores y ambientes restringidos.</p> </li> <li>El interprete se encarga de procesar el c\u00f3digo de programa para hacer posible que el hardware ejecute lo que en \u00e9l se indica. El interprete se sit\u00faa como una capa l\u00f3gica de software entre el c\u00f3digo y el hardware.</li> <li>MicroPython dispone de m\u00f3dulos que permiten el acceso al hardware del microcontrolador y dispone de multitud de librerias para las distintas tareas.</li> </ul> <p>Dado el hardware que vamos a utilizar es recomendable comenzar descargando y copiando MicroPython uf2 personalizado de Pimorini en nuestra Rasberry Pi Pico; ya que incluye todas las liberias que necesitaremos para usarlo.</p> <p>En otro apartado vamos a ver como comenzar con RBP Pico, que versi\u00f3n descargar de MicroPython y comenzaremos a trabajar con todo ello.</p>"},{"location":"inicio/inicio_pi_pico/","title":"Inicio con Raspberry Pi Pico","text":"<p>Vamos a realizar una introducci\u00f3n a Raspberry Pi Pico mostrando los pasos necesarios para montarla, configurarla y prepararla para la programaci\u00f3n con MicroPython. Tambi\u00e9n veremos como trabajar con algunas placas que se conectan a los breakout garden.</p> <p>No vamos a profundizar en exceso en los contenidos, aunque si es necesario podemos recurrir a:</p> <ul> <li>Busquedas en la web sobre el tema. Existen multitud de p\u00e1ginas con informaci\u00f3n mas o menos detallada, aunque siempre debemos asegurarnos de que la informaci\u00f3n es confiable.</li> <li>El libro Getting Started with MicroPython on the Raspberry Pi Pico.</li> <li>El sitio oficial de Raspberry Pi.</li> <li>La hoja de datos de Pico: Datasheet de Pico.</li> <li>Repositorio de Github Pimoroni Pico Libraries and Examples.</li> </ul>"},{"location":"inicio/inicio_pi_pico/#sobre-raspberry-pi","title":"Sobre Raspberry Pi","text":"<p>La Raspberry Pi es una placa construida con un microcontrolador RP2040 a la que si a\u00f1adimos un teclado, un rat\u00f3n y un monitor se convierte en un ordenador que ejecuta Linux con un buen nivel de procesamiento y memoria RAM.</p> <p>Raspberri Pi Pico est\u00e1 orientada a computaci\u00f3n f\u00edsica, es decir, para conectarla a sensores y actuadores. A diferencia de la Pi, la Pico est\u00e1 dotada de conversores anal\u00f3gico a digital (ADC) pra ampliar la gama de sensores y entradas. La mayor\u00eda de los pines son de tipo PIO (Programmable Input Output) de prop\u00f3sito general. En el RP2040 estos pines est\u00e1n controlados por el IO programable, lo que significa que se actualizan en segundo plano con muy poco uso de la CPU. Esto hace que las entradas/salidas programables sean tan r\u00e1pidas que se puede alcanzar una resoluci\u00f3n de 14 bits en lugar de los 8 bits habituales.</p> <p>La Raspberry Pi Pico es programable a trav\u00e9s de USB con C, C++ o MicroPython, siendo este \u00faltimo lenguaje el que nos ocupar\u00e1 aqu\u00ed.</p> <p>Desde el mes de julio de 2022 adem\u00e1s se puede conseguir la Pico W con conectividad inal\u00e1mbrica.</p>"},{"location":"inicio/inicio_pi_pico/#lo-que-vamos-a-necesitar","title":"Lo que vamos a necesitar","text":"<ul> <li>Una Raspberry Pi Pico o Pico W</li> </ul> <p> <p> Aspecto de las Pi Pico y Pico W</p> <p></p> <ul> <li>Un cable micro USB para conectar la Pico al ordenador y as\u00ed poder programarla. Lo \u00fanico a tener en cuenta aqu\u00ed es que el cable debe ser apto para alimentaci\u00f3n y datos. Esto se indica porque algunos cables de tel\u00e9fonos antiguos por ejemplo, solamente suministran alimentaci\u00f3n.</li> </ul> <p> <p> Cable USB micro</p> <p></p> <ul> <li>Tiras de pines rectos macho de paso 2.54 mm para poder conectar la Pi Pico a la placa Pico Explorer (veremos como soldarlas mas adelante). Usualmente se comercializan como tiras de 40 pines que debemos cortar en dos trozos de 20 como los que vemos en la imagen siguiente:</li> </ul> <p> <p> Tiras de 20 pines rectos macho de paso 2.54 mm</p> <p></p> <ul> <li>Un ordenador desde el que programar la Pi Pico con el software (usaremos Thonny) que vamos a utilizar instalado.</li> </ul>"},{"location":"inicio/inicio_pi_pico/#soldar-las-tiras-de-pines","title":"Soldar las tiras de pines","text":"<p>Aunque vamos a dar unos consejos pr\u00e1cticos de soldadura y partienfdo de la base de que las PCB actuales son f\u00e1ciles de soldar, si no tenemos herramientas adecuadas y una m\u00ednima experiencia es aconsejable adquirir la Pi Pico con las tiras de pines ya soldadas.</p>"},{"location":"inicio/inicio_pi_pico/#equipo-basico-de-soldadura","title":"Equipo b\u00e1sico de soldadura","text":"<p>Es relativamente sencillo localizar en la web informaci\u00f3n de como realizar soldaduras electr\u00f3nicas para ver como se hace, pero omitimos recomendar ninguno concreto, pues sobre todo, el \u00e9xito o fracaso va a depender del equipamiento que tengamos para soldar, y si no tenemos previsto utilizarlo con cierta frecuencia casi mejor no adquirir ninguno y solicitar a alguien que nos suelde las tiras.</p> <p>En mi caso voy a enumerar y describir brevemente el equipo que yo utilizo con el que llevo trabajando muchos a\u00f1os.</p> <p>1.- Alfombrilla o tapete de silicona. Permite tener el material ordenado y evita quemaduras o rayaduras accidentales sobre la superficie de trabajo.</p> <p> <p> Alfombrilla de silicona de 45x30</p> <p></p> <p>2.- Soldador. Es la herramienta principal para esta tarea y no puede sere de baja calidad. Hay que huir de los t\u00edpicos que encontramos muy econ\u00f3micos. En mi caso dispongo de dos tipos, ambos de bastante calidad.</p> <p> <p> Soldadores</p> <p></p> <p>3.- Esta\u00f1o de 0.5 a 1mm de di\u00e1metro. Se recomienda el uso de esta\u00f1o libre de plomo. En la imagen vemos un carrete de Sn99.3-Cu0.7.</p> <p> <p> Esta\u00f1o</p> <p></p> <p>4.- Soporte para soldador. Imprescindible si queremos evitar quemaduras accidentales.</p> <p> <p> Soporte para soldador</p> <p></p> <p>5.- Limpiador de puntas de soldador. Permite eliminar en caliente los restos de esta\u00f1o y resina de la punta del soldador manteniendola en perfectas condiciones de uso.</p> <p> <p> Limpiador de puntas de soldador</p> <p></p> <p>6.- Algunas herramientas de uso b\u00e1sico en electr\u00f3nica como pinzas, alicates de corte, tijeras, destornilladores, etc.</p>"},{"location":"inicio/inicio_pi_pico/#teoria-de-soldadura","title":"Teor\u00eda de soldadura","text":"<p>Una vez pertrechados con el equipamiento vamos a recomendar unos tutoriales b\u00e1sicos de soldadura:</p> <ul> <li>El primero es en forma de comic realizado por Mitch Altman (conocimientos de soldadura), Andie Nordgren (adaptaci\u00f3n a comic) y Jeff Keyzer (dise\u00f1o y edici\u00f3n) titulado Soldar es f\u00e1cil, aqu\u00ed est\u00e1 como hacerlo. El comic data de 2001 y recomienda el uso del esta\u00f1o tradicional con aleaci\u00f3n de Esta\u00f1o/Plomo al 60/40 con n\u00facleo de resina. Actualmente este tipo de esta\u00f1o no se usa habitualmente debido a la alta toxicidad del plomo aunque es f\u00e1cil de encontrar en el mercado. Existen directivas comunitarias europeas que prohiben su uso. Se recomienda encarecidamente la lectura de este comic, resulta instructivo y entretenido.</li> <li>El segundo son dos infografias de Adafruit que aunque est\u00e1n en ingl\u00e9s se entienden perfectamente. Estas las podemos encontrar en la colecci\u00f3n de tarjetas que tiene en Github y son Card 4 Back.pdf y Card 4 Front.pdf que reproducimos como im\u00e1genes a continuaci\u00f3n.</li> </ul> <p> <p> Card 4 Front</p> <p> Card 4 Back</p> <p></p>"},{"location":"inicio/inicio_pi_pico/#soldar-las-tiras-de-pines_1","title":"Soldar las tiras de pines","text":"<p>Las tiras de pines debemos soldarlas de manera que queden perpendiculares a la base de la Pi Pico y, para ello, lo m\u00e1s f\u00e1cil y comodo es pincharlas a la distancia apropiada sobre una placa protoboard. La parte que pinchamos en la protoboard es la parte mas larga de los pines.</p> <p> <p> Colocaci\u00f3n de las tiras en una protoboard</p> <p></p> <p>Colocamos encima de las tiras la Pi Pico con la frambuesa mirando hacia arriba.</p> <p> <p> Colocaci\u00f3n de la Pi Pico sobre las tiras de pines</p> <p></p> <p>Procedemos a soldar cada uno de los pines. Para ello se recomienda soldar los pines de las cuatro esquinas asegr\u00e1ndonos de que la placa est\u00e1 apoyada correctamente. Si no est\u00e1 todo correcto ahora es el momento de realizar las correcciones oportunas porque m\u00e1s adelante ya no podremos. Sobre todo comprobar que est\u00e1n a 90\u00ba y podemos continuar con el resto de pines. Se recomienda no soldar los pines uno al lado del otro para evitar sobrecalentamientos de la placa, siendo una buena t\u00e9cnica ir cambiando de una tira a otra hasta completar todas las soldaduras.</p> <p> <p> Tiras de pines soldadas</p> <p></p> <p>Ya podemos retirar la Pi Pico de la protoboard y colocarla en su lugar en la Pico Explorer. Se recomienda para hacerlo sujetar la placa por los bordes largos y balancearla suavemente o incluso ayudarno de un peque\u00f1o destornillador que nos permita hacer palanca, pero debemos hacerlo con cuidado para no doblar ning\u00fan pin.</p>"},{"location":"inicio/pi_pico_picoW/","title":"La Pi Pico y Pico W","text":"<p>Realizaremos una breve descripci\u00f3n de los modelos lanzados de la Pi Pico, describiendo sus principales caracter\u00edsticas. El modelo Pico W es totalmente similar con la salvedad de que integra conectividad WiFi.</p> <ul> <li>La Raspberry Pi Pico se lanz\u00f3 al mercado el 21 de enero de 2021.</li> <li>La Pico W se lanz\u00f3 el 30 de junio de 2022 como reemplazo directo de la Pi Pico para trabajar IoT.</li> </ul> <p> <p> Partes principales en la Pi Pico</p> <p></p> <p> <p> Partes principales en la Pi Pico W</p> <p></p> <p>En la tabla siguiente vemos las principales caracter\u00edsticas de la Pi Pico.</p> <p> caracteristicas y especificaciones Valores Microntrolador RP2040 N\u00facleos Dos (dual core) Arquitectura de nucleo 32-bits ARM Cortex-M0+ Reloj de la CPU Configurable hasta 133MHz Memoria RAM 264 KBytes de SRAM Memoria Flash 2 MBytes Q-SPI Lenguajes soportados MicroPython, C y C++ Alimentaci\u00f3n 5V DC por micro USB Alimentaci\u00f3n alternativa 2 a 5V DC por VSYS (pin 39) Tensi\u00f3n MCU 3.3V DC Tensi\u00f3n GPIO 3.3V DC Interface USB USB 1.1 GPIO 26 entradas/salidas digitales ADC 3x12 bits a 500ksps Sensor de temperatura integrado de 12 bits UART 2 I2C 2 SPI 2 PWM 16 Timer Un timer con 4 alarmas RTC Un contador en tiempo real PIO 2 IO programables de alta velocidad LED en placa Un LED programable (GP25) Bot\u00f3n en placa Un bot\u00f3n BOOTSEL Puerto de depuraci\u00f3n Puerto de 3 pines ARM Serial Wire Debug Inal\u00e1mbrico IEEE 802.11 b/n/g de 2.4 GHz. Bluetooth 5.2 Antena Incorporada en la propia placa <p></p> <p>La Pi Pico est\u00e1 dise\u00f1ada para integrarse en otros productos, bien a partir de SMT (Surface Mount Technology) gracias al dise\u00f1o de borde de los pines, o bien a trav\u00e9s de tiras de pines.</p> <p> <p> Pi Pico para SMT y tiras de pines</p> <p></p> <p>Entre los 26 pines GPIO se pueden configurar como:</p> <ul> <li>3 como ADC de 12 bits a 500 ksps (kilo muestras por segundo)</li> <li>2 como UART</li> <li>2 como SPI</li> <li>2 como I2C</li> <li>Hasta 16 como pines PWM</li> </ul> <p>Internamente viene con un temporizador con 4 alarmas, y un contador en tiempo real y los perif\u00e9ricos duales de E/S programables (PIO) que son E/S de alta velocidad flexibles y programables por el usuario. Puede emular interfaces como tarjetas SD y VGA.</p> <p>En la imagen siguiente vemos la posible configuraci\u00f3n de pines PWM en la Raspberry Pi Pico.</p> <p> <p> Pines PWM en la Pi Pico</p> <p></p> <p>IMPORTANTE: Los pines GPIO de la Pi Pico trabajan a 3,3V como voltaje m\u00e1ximo de entrada y/o salida. Si aplicamos tensiones superiores a cualquiera de ellos podemos da\u00f1ar la placa de manera irreversible.</p>"},{"location":"inicio/pi_pico_picoW/#la-familia-pi-pico","title":"La familia Pi Pico","text":"<p>La familia de Raspberry Pi Pico est\u00e1 formada por la cuatro placas que vemos en la imagen siguiente:</p> <p> <p> La familia Pi Pico Imagen obtenida de aqu\u00ed</p> <p></p>"},{"location":"inicio/pi_pico_picoW/#pi-pico-y-pico-h","title":"Pi Pico y Pico H","text":"<p>La Raspberry Pi Pico viene con medios agujeros en el borde que permiten soldarla directamente a otras placas base, mientras que la Pico H viene con terminales pre-soldados.</p> <p>Ambas placas tienen tres pines Serial Wire Debug (SWD). En la Pico H viene soldado un peque\u00f1o conector de 3 vias con retenci\u00f3n tipo JST, mientras que la Pico tiene tres agujeros pasantes junto a los medios agujeros del borde de la placa.</p> <p>A continuaci\u00f3n tenemos diferentes archivos sobre informaci\u00f3n de las placas.</p> <ul> <li>Enlace al pinout en pdf</li> <li>Enlace al esquema p\u00fablico en pdf</li> <li>En la imagen siguiente vemos los modelos Fritzing de la Pico y de la Pico H en el IDE del mismo.</li> </ul> <p> <p> Pi Pico y Pico H en Fritzing</p> <p></p> <ul> <li>En la imagen podemos ver el modelo .STEP en FreeCAD en el IDE del mismo.</li> </ul> <p> <p> Pi Pico en FreeCAD</p> <p></p> <ul> <li>Hoja de datos de la Pi Pico</li> </ul>"},{"location":"inicio/pi_pico_picoW/#pi-pico-w-y-pico-wh","title":"Pi Pico W y Pico WH","text":"<p>Raspberry Pi Pico W a\u00f1ade interfaces inal\u00e1mbricas integradas de banda \u00fanica de 2,4 GHz (802.11n) utilizando el chip Infineon CYW43439, manteniendo el factor de forma Pico. La interfaz inal\u00e1mbrica integrada de 2,4 GHz tiene las siguientes caracter\u00edsticas:</p> <ul> <li>WPA3</li> <li>Punto de acceso compatible con hasta cuatro clientes</li> <li>Bluetooth 5.2. Compatibilidad con Bluetooth BLE y Bluetooth Classic</li> </ul> <p>La antena es una antena integrada con licencia de ABRACON (anteriormente ProAnt). La interfaz inal\u00e1mbrica est\u00e1 conectada mediante SPI al microcontrolador RP2040.</p> <p>Debido a las limitaciones de pines, algunos de los pines de la interfaz inal\u00e1mbrica son compartidos. El CLK se comparte con el monitor VSYS, por lo que s\u00f3lo cuando no hay una transacci\u00f3n SPI en curso puede leerse VSYS a trav\u00e9s del ADC. El Infineon CYW43439 DIN/DOUT e IRQ comparten un pin en el RP2040. S\u00f3lo cuando una transacci\u00f3n SPI no est\u00e1 en progreso es adecuado comprobar si hay IRQs. La interfaz funciona t\u00edpicamente a 33MHz.</p> <p>Para un mejor rendimiento inal\u00e1mbrico, la antena debe estar en un espacio libre. Por ejemplo, poner metal debajo o cerca de la antena puede reducir su rendimiento tanto en t\u00e9rminos de ganancia como de ancho de banda. A\u00f1adir partes met\u00e1licas conectadas a tierra a los lados de la antena puede mejorar su ancho de banda.</p> <p>A continuaci\u00f3n tenemos diferentes archivos sobre informaci\u00f3n de las placas.</p> <ul> <li>Enlace al pinout en pdf</li> <li>En la imagen siguiente vemos el modelo Fritzing de la Pico W en el IDE del mismo.</li> </ul> <p> <p> Pi Pico W en Fritzing</p> <p></p> <ul> <li>En la imagen podemos ver el modelo .STEP en FreeCAD en el IDE del mismo.</li> </ul> <p> <p> Pi Pico W en FreeCAD</p> <p></p> <ul> <li>Hoja de datos de la Pi Pico W</li> </ul>"},{"location":"up/firm/","title":"Firmware","text":"<p>Para programar la Pi Pico se pueden utilizar herramientas basadas en los est\u00e1ndares MicroPython y CircuitPython as\u00ed como el IDE de Arduino. Por otra parte, existe una herramienta de programaci\u00f3n basada en Snap! que se denomina MicroBlocks que ofrece una forma sencilla de iniciarse en la programaci\u00f3n de forma grafica. Thonny es otra plataforma de software libre y de c\u00f3digo abierto de tama\u00f1o compacto, interfaz sencilla, por lo que es un IDE de Python ideal para principiantes. El sitio oficial de Thonny y sus repositorios de c\u00f3digo abierto nos ofrecen tanto el programa como la informaci\u00f3n del mismo. En estas notas vamos a trabajar fundamentalmente con Thonny y con MicroBlocks.</p> <p>Para terminar con la preparaci\u00f3n de nuestra placa y comenzar a trabajar con la misma vamos a ver como grabar el firmware en la Pi Pico y como instalar y usar el compilador Thonny que usaremos para programar la Pi Pico.</p>"},{"location":"up/firm/#instalacion-del-firmware","title":"Instalaci\u00f3n del firmware","text":"<p>Ya hemos indicado que vamos a utilizar la versi\u00f3n de MicrPython de Pimorini. Podemos obtener la versi\u00f3n en: https://github.com/pimoroni/pimoroni-pico/releases/latest/. Para instalar MicroPython, tenemos que copiar el archivo .uf2 apropiado de la p\u00e1gina de versiones al dispositivo PI Pico mientras est\u00e1 en modo DFU/bootloader.</p>"},{"location":"up/firm/#que-archivo-descargar","title":"\u00bfQue archivo descargar?","text":"<p>En la [p\u00e1gina de versiones] tenemos todos los archivos disponibles de los que a nosotros nos van a interesar uno de los dos que se describen en la tabla e imagen siguientes:</p> <p> Placa Que archivo uf2 utilizo Raspberry Pi Pico y otras  placas con RP22040 inal\u00e1mbricas (Plasma 2040, Interstate 75, Servo 2040, Motor 2040, Tiny 2040 2MB) pimoroni-pico-vx.x.x-micropython.uf2 Raspberry Pi Pico W y otras  placas Pico W (Automation 2040 W, Inventor 2040 W, Plasma Stick, Interstate 75 W) pimoroni-picow-vx.x.x-micropython.uf2 <p></p> <p> <p> Archivos a descargar para la Pi Pico</p> <p></p>"},{"location":"up/firm/#grabar-firmware-uf2-en-la-pi-pico","title":"Grabar firmware .uf2 en la Pi Pico","text":"<p>Para copiar el archivo a la Pico, debemos ponerla en modo de gestor de arranque. Para hacer esto, mantenemos presionado el bot\u00f3n BOOTSEL mientras conectamos el cable USB al ordenador; ahora deber\u00eda aparecer como una unidad llamada RPI-RP2.</p> <p> <p> Localizaci\u00f3n del bot\u00f3n BOOTSEL</p> <p></p> <p>As\u00ed es como se ve en Ubuntu:</p> <p> <p> Unidad RPI-RP2 montada</p> <p></p> <p>Copiamos el archivo descargado en la unidad. La Pico se reinicia y, transcurridos unos segundos, ejecutar\u00e1 MicroPython. Es muy probable que no notemos ninguna diferencia pero ahora la Pico est\u00e1 cantando canciones piratas para si misma en voz baja.</p> <p>A partir de ahora, la Pico ya no aparecer\u00e1 como una unidad cuando la conectamos y ser\u00e1 necesario usar un interprete para comunicarnos con ella. Este interprete se llama Thonny, MicroBlocks, etc.</p>"},{"location":"up/soft/","title":"Software Thonny","text":"<p>Thonny es un sencillo editor gr\u00e1fico para aprender Python siendo un principiante en el tema.</p>"},{"location":"up/soft/#instalar-thonny","title":"Instalar Thonny","text":"<p>Thonny es un IDE (Integrated Development Environment o entorno de desarrollo integrado) de Python y es el software que utilizaremos para programar la Pico.</p> <p>Si trabajamos desde un Raspberry Pi es muy probable que ya tengamos Thonny instalado y tan solo tengamos que actualizar a la versi\u00f3n mas reciente para disponer de las opciones espec\u00edficas de Pico. Abrimos una terminal, por ejemplo con Ctrl+Alt+T y escribimos:</p> <p><code>sudo apt update &amp;&amp; sudo apt upgrade -y</code></p> <p>y presionamos Enter para que se ejecute.</p> <p>Si estamos trabajando en un ordenador, las versiones disponibles para Linux, Mac o Windows est\u00e1n aqu\u00ed listas para descargar e instalar.</p> <p>En el caso de Ubunto lo tenemos disponible en la tienda Snap a trav\u00e9s de Ubuntu Software.</p> <p> <p> Thonny en la tienda Snap</p> <p></p> <p>Una vez instalado lo ejecutamos y veremos la ventana siguiente:</p> <p> <p> IDE de Thonny</p> <p></p> <p>Pero seguro que instalando desde las distribuciones de paquetes o tienda Snap no obtenemos la \u00faltima versi\u00f3n. Si queremos instalar esta \u00faltima versi\u00f3n en Ubuntu 22.04 debemos visitar el repositorio de versiones de Thonny y descargar el archivo .bash de la versi\u00f3n que queramos.</p> <p> <p> Repo de versiones de Thonny</p> <p></p> <p>Abrimos una terminal en el directorio donde tengamos el archivo descargado, thonny-4.1.3.bash en este caso, y tecleamos:</p> <p> <p> Ejecutamos thonny-4.1.3.bash</p> <p></p> <p>Una vez finalizadas todas las tareas tenemos Thonny listo para ejecutar.</p> <p> <p> Thonny-4.1.3.bash instalado</p> <p></p> <p>Ya estamos listos para ejecutar la versi\u00f3n de Thonny, que en este caso se distingue porque aparece una banderita de Ucrania que permite solidarizarse con el pais.</p> <p> <p> IDE Thonny-4.1.3</p> <p></p>"},{"location":"up/soft/#descripcion-del-ide-de-thonny","title":"Descripci\u00f3n del IDE de Thonny","text":"<p>Una vez instalado, la primera vez que abrimos el programa se muestra la ventana que vemos a continuaci\u00f3n.</p> <p> <p> Partes del IDE Thonny-4.1.3</p> <p></p> <p>A continuaci\u00f3n realizamos una breve descripci\u00f3n de las partes numeradas:</p> <ol> <li>Barra de t\u00edtulo, donde vemos el nombre del programa y el nombre del archivo actual que por defecto es . <li>Barra de men\u00fas, que nos da acceso a todas las partes de Thonny.</li> <li>Barra de herramientas, con accesos r\u00e1pidos a las tareas habituales.</li> <li>Editor, donde se escribe el c\u00f3digo de nuestra aplicaci\u00f3n. Es una pesta\u00f1a con el nombre del archivo y pueden coexistir varias pesta\u00f1as, lo que permite tener varios archivos abiertos y cambiar rapidamente de uno a otro con tan solo hacer clic en la pesta\u00f1a.</li> <li>Int\u00e9rprete de comandos o consola, desde donde interactuar con nuestro ordenador. En realidad esta zona se denomina REPL (Read, Evaluate, Print y Loop) que traducido ser\u00eda bucle Lectura-Evaluaci\u00f3n-Impresi\u00f3n. Esto viene a significar algo as\u00ed como \"lee lo escrito, eval\u00faa el c\u00f3digo escrito, imprime los resultados y vuelve a empezar\".</li> <li>Barra de estado, donde indica con que Python est\u00e1 trabajando y nos da acceso a la configuraci\u00f3n del int\u00e9rprete.</li> <p>Desde el men\u00fa \"Visualizar\" se pueden activar y desactivar las herramientas de Thonny. A Continuaci\u00f3n vemos este men\u00fa desplegado. Activar (o desactivar si ya est\u00e1 activa) una herramienta es hacer clic sobre su nombre en este men\u00fa.</p> <p> <p> Men\u00fa Visualizar</p> <p></p> <p>Describimos brevemente estas herramientas.</p> <ul> <li>Archivos (\u00c1rbol de archivos). Especialmente \u00fatil cuando trabajamos en proyectos con varios archivos.</li> <li>Asistente. Un ayudante del editor Python que nos guiar\u00e1 en los problemas en la ejecuci\u00f3n o al implementar la aplicaci\u00f3n.</li> <li>Ayuda. Ayuda sobre el uso de la aplicaci\u00f3n, del depurador, etc.</li> <li>Esquema. Es un \u00e1rbol con todas las funciones, objetos y m\u00e9todos definidos en nuestra aplicaci\u00f3n. Es como un vistazo general a la aplicaci\u00f3n que nos permite movernos con rapidez por la misma. Simplemente cuando hacemos clic en un m\u00e9todo, funci\u00f3n o clase, nos desplazamos a ella.</li> <li>Excepci\u00f3n. Es donde se muestran los errores, cuando los hay.</li> <li>Inspector de objetos. Permite examinar las variables que se muestran tanto en heap como en Variables.</li> <li>Mont\u00edculo (heap). Cuando lo activamos podemos ver el valor de las variables.</li> <li>Notas. Para tener un lugar donde hacer anotaciones y tenerlas siempre a mano. Lo que escribamos aqu\u00ed se guar de manera autom\u00e1tica y se carga en el siguiente arranque de Thonny.</li> <li>PORHACER. Visualiza las etiquetas #TODO que hemos puesto como aviso de que la tarea est\u00e1 pendiente.</li> <li>Pila (stack). Nos da una visi\u00f3n de la parte de la aplicaci\u00f3n en la que nos encontramos en tiempo de ejecuci\u00f3n.</li> <li>Variables. Nos permite identificar, en tiempo de ejecuci\u00f3n, cada una de las variables de nuestra aplicaci\u00f3n. Si tenemos activado el heap lo que se muestra es el identificador de la variable, mientras que si no est\u00e1 activado heap veremos el valor de la variable.</li> <li>\u00c1rbol del programa. Es otra visi\u00f3n o punto de vista del programa que permite analizar el funcionamiento del mismo de una manera totalmente diferente.</li> </ul>"},{"location":"up/soft/#configuracion-basica-de-thonny","title":"Configuraci\u00f3n b\u00e1sica de Thonny","text":"<p>Thonny es f\u00e1cil de configurar dada lo b\u00e1sica que es la misma. Podemos acceder a la configuraci\u00f3n o bien desde el men\u00fa Herramientas o bien desde la parte inferior derecha de la ventana. En este \u00faltimo caso se abrir\u00e1 la ventana en la pesta\u00f1a Interprete.</p> <p> <p> Acceso a la ventana de configuraci\u00f3n</p> <p></p>"},{"location":"up/soft/#general","title":"General","text":"<p>En esta pesta\u00f1a se configuran aspecto generales de la aplicaci\u00f3n, como la posibilidad de lanzar varias instancias de Thonny, reabrir todos los archivos de la \u00faltima sesi\u00f3n o configurar el idioma.</p> <p> <p> Pesta\u00f1a General</p> <p></p>"},{"location":"up/soft/#interprete","title":"Int\u00e9rprete","text":"<p>Thonny permite seleccionar diferentes int\u00e9rpretes, es decir, diferentes versiones de Python. Como regla regla general, se utiliza el mismo int\u00e9rprete que el que ejecuta Thonny. Sin embargo, en nuestro caso, usaremos un int\u00e9rprete concreto. Necesitamos tener seleccionado 'MicroPython (Raspberry Pi Pico)' como int\u00e9rprete de Python; esto se puede hacer clicando en el cuadro en la parte inferior derecha. Thonny puede ofrecernos instalar MicroPython, pero no necesitamos hacerlo ya que ya tenemos la variante de MicroPython que necesitamos instalada. Teniendo las Pi Pico conectada a un puerto USB esta acci\u00f3n nos devolver\u00e1 algo similar a la imagen siguiente:</p> <p> <p> Selecci\u00f3n del Int\u00e9rprete</p> <p></p> <p>Tras la selecci\u00f3n Thonny muestra el siguiente aspecto:</p> <p> <p> Thonny tras la selecci\u00f3n del Int\u00e9rprete</p> <p></p> <p>Si no vemos la ventana como la de arriba, podemos probar a hacer clic en el bot\u00f3n rojo de detener para interrumpir cualquier proceso que se est\u00e9 ejecutando.</p> <p>Si Thonny tiene problemas para la detecci\u00f3n autom\u00e1tica la podemos seleccionar manualmente desde la pesta\u00f1a de configuraci\u00f3n Int\u00e9rprete, desde donde podremos seleccionar la placa y el puerto de forma correcta.</p> <p> <p> Pesta\u00f1a Int\u00e9rprete</p> <p></p>"},{"location":"up/soft/#editor","title":"Editor","text":"<p>En esta pesta\u00f1a podemos seleccionar diferentes opciones que nos ayudar\u00e1n en nuestro d\u00eda a d\u00eda programando.</p> <p> <p> Pesta\u00f1a Editor</p> <p></p>"},{"location":"up/soft/#temas-y-fuentes","title":"Temas y fuentes","text":"<p>Esta pesta\u00f1a est\u00e1 orientada a cambiar el aspecto est\u00e9tico de la aplicaci\u00f3n seg\u00fan nuestras preferencias.</p> <p> <p> Pesta\u00f1a Temas y fuentes</p> <p></p>"},{"location":"up/soft/#ejecutar-y-depurar","title":"Ejecutar y depurar","text":"<p>Para configurar una serie de ayudas que mejorean el funcionamiento y permiten trabajar mas comodamente, como por ejemplo la de abrir y cerrar el Stack autom\u00e1ticamente.</p> <p> <p> Pesta\u00f1a Ejecutar y depurar</p> <p></p>"},{"location":"up/soft/#terminal","title":"Terminal","text":"<p>En esta pesta\u00f1a podemos configurar las opciones del terminal.</p> <p> <p> Pesta\u00f1a Terminal</p> <p></p>"},{"location":"up/soft/#consola","title":"Consola","text":"<p>En esta pesta\u00f1a podemos configurar las opciones referentes al comportamiento al terminar un proceso o una aplicaci\u00f3n.</p> <p> <p> Pesta\u00f1a Consola</p> <p></p>"},{"location":"up/soft/#asistente","title":"Asistente","text":"<p>En esta pesta\u00f1a quiz\u00e1 la opci\u00f3n mas interesante sea la de habilitar o deshabilitar la apertura del asistente, de forma autom\u00e1tica, cuando se produce un error en el programa. Tambi\u00e9n es interesante activar este comportamiento para los warning.  <p> Pesta\u00f1a Asistente</p> <p></p>"},{"location":"up/soft/#primeros-pasos-con-thonny","title":"Primeros pasos con Thonny","text":"<p>Conectamos la Pi Pico con el firmware grabado al ordenador mediante un cable USB, arrancamos Thonny y hacemos clic en el 'Shell' o consola, obtendremos un cursor parpadeante. Escribiendo instrucciones en este cuadro damos \u00f3rdenes a la Pico directamente, una orden cada vez (esto se llama REPL, o Read-Eval-Print Loop). En la animaci\u00f3n siguiente vemos su funcionamiento.</p> <p> <p> Ordenes en la consola (REPL)</p> <p></p> <p>Pero tal vez lo que queramos sea poner mas de una l\u00ednea de instrucciones para componer un programa y que al ejecutarlo se realicen las acciones programadas. Esto lo hacemos en la ventana de programa, como por ejemplo en la animaci\u00f3n siguiente:</p> <p> <p> Programa b\u00e1sico</p> <p></p>"},{"location":"up/soft/#funcionamiento-en-linea","title":"Funcionamiento en l\u00ednea","text":"<p>Podemos trabajar con la Raspberry Pi Pico en l\u00ednea o conectada para compilar o depurar programas, pero es necesario tenerla conectada al ordenador.</p> <p>Las ventajas que esto no ofrece son:</p> <ul> <li>Podemos utilizar Thonny para compilar o depurar programas.</li> <li>A trav\u00e9s de la ventana \"Shell\", obtenemos la informaci\u00f3n de errores y los resultados de salida generados durante la ejecuci\u00f3n del programa. Tambi\u00e9n es posible consultar informaci\u00f3n de funciones para ayudar a mejorar el programa.</li> </ul> <p>Las desventajas son:</p> <ul> <li>Para trabajar en l\u00ednea la Raspberry Pi Pico tiene que estar conectada a un ordenador y ejecutar con Thonny.</li> <li>Si la Raspberry Pi Pico se desconecta del ordenador, el programa no se ejecutar\u00e1 de nuevo cuando se vuelve a conectar la Pi Pico.</li> </ul> <p>Partimos de Thonny reciente abierto y lo primero que hacemos es localizar un proyecto para abrirlo o bien crear uno nuevo. El proceso de apertura es el de la animaci\u00f3n siguiente:</p> <p> <p> Abrir un programa desde Thonny</p> <p></p> <p>En la animaci\u00f3n observamos lo f\u00e1cil que es abrir el archivo y ejecutarlo haciendo clic en el bot\u00f3n Ejecutar el script actual o pulsando F5. Cuando estamos en modo de ejecute en l\u00ednea, podemos hacer clic en Detener/Reiniciar el backend en Thonny o pulsar Ctrl+C para salir del programa. Esta acci\u00f3n l\u00edmpia el contenido de la consola al igual que la combinaci\u00f3n de teclas Ctrl+L.</p>"},{"location":"up/soft/#funcionamiento-sin-conexion","title":"Funcionamiento sin conexi\u00f3n","text":"<p>La Raspberry Pi Pico no necesita estar conectada al ordenador y a Thonny para ejecutar los programas almacenados en main.py en el dispositivo una vez que lo alimentemos.</p> <p>La ventaja es que se pueden ejecutar programas cuando se enciende sin conectarse a la computadora y Thonny.</p> <p>La desventaja es que el programa se detendr\u00e1 autom\u00e1ticamente cuando se produzca un error o la Raspberry Pi Pico se quede sin energ\u00eda. En esta situaci\u00f3n el c\u00f3digo no se puede cambiar f\u00e1cilmente.</p> <p>Cuando se alimenta, la Raspberry Pi Pico comprobar\u00e1 autom\u00e1ticamente si existe main.py en el dispositivo. Si est\u00e1 presente, ejecuta los programas en main.py y luego entra en el modo de comandos del shell. Es decir, si queremos que nuestro programa se ejecute offline basta con guardarlo con el nombre main.py. Si main.py no existe, el sistema entrar\u00e1 en el modo de comandos shell directamente.</p> <p></p>"},{"location":"up/soft/#ejecutando-codigo","title":"Ejecutando c\u00f3digo","text":"<p>Con la Pi Pico conectada al ordenador podemos hacer clic sobre el bot\u00f3n ejecutar y ver como parpadea el LED en la placa y la informaci\u00f3n que se muestra en la consola.</p> <p> <p> Ejecutar un programa desde Thonny</p> <p></p> <p>Si ahora hacemos clic en el bot\u00f3n de parada/reinicio el programa se detiene, el LED se apaga y se muestra informaci\u00f3n en la consola.</p> <p> <p> Detener un programa desde Thonny</p> <p></p> <p>De esta forma estamos ejecutando c\u00f3digo online o en conexi\u00f3n. Si ahora desconectamos el cable USB del ordenador, Thonny nos va a mostrar el siguiente mensaje:</p> <p> <p> Conexi\u00f3n perdida</p> <p></p> <p>Ahora volvemos a conectar el cable USB y recuperamos la conexi\u00f3n haciendo clic en el bot\u00f3n STOP. En esta situaci\u00f3n hacemos clic derecho sobre el nombre del archivo A01.py y escogemos la opci\u00f3n Subir a / para grabar el programa en la Pi Pico.</p> <p> <p> Subir a /</p> <p></p> <p>Podemos observar como ahora hay un archivo en la Pi Pico con el mismo nombre que el que teniamos en el IDE de Thonny.</p> <p> <p> Archivo subido a la Pi Pico</p> <p></p> <p>Pero este archivo por si solo no puede ejecutarse en la Pi Pico ya que el interprete MicroPython que contiene espera un archivo <code>main.py</code>. Lo que vamos a hacer es descargar el archivo main.py, que est\u00e1 en un directorio del mismo nombre, y lo copiamos en el directorio de A01. Simplemente indicar por ahora que desde MicroPython se invoca la ejecuci\u00f3n de este archivo main.py. Una vez copiado el archivo al directorio lo llevamos a la Pico de la misma forma que antes. Tendremos la siguiente situaci\u00f3n:</p> <p> <p> Archivo main.py subido a la Pi Pico</p> <p></p> <p>Desconectamos el cable USB y lo volvemos a conectar. El LED en la pico parpadea seg\u00fan el programa A01.py mientras que Thonny se muestra como vemos a continuaci\u00f3n:</p> <p> <p> Ejecuci\u00f3n desde la Raspberry Pi Pico</p> <p></p> <p>El c\u00f3digo se est\u00e1 ejecutando sin conexi\u00f3n (offline) entre Thonny y la Pico. Si queremos volver a tomar el control desde Thonny basta con hacer clic en el bot\u00f3n STOP y se mostrar\u00e1 la ventana siguiente:</p> <p> <p> Vuelta al modo online</p> <p></p>"},{"location":"upy/rapida/","title":"Gu\u00eda de refencia r\u00e1pida de RP2","text":"<p>RP2 hace referencia al microcontrolador RP2040.</p> <p>Es muy importante leerse, si a\u00fan no lo hemos hecho, los apartados de \"Introducci\u00f3n\" y \"Firmware y software\" antes de continuar con esta guia r\u00e1pida de MicroPython basada en los contenidos del enlace Quick reference for the RP2.</p>"},{"location":"upy/rapida/#control-general","title":"Control general","text":""},{"location":"upy/rapida/#retardos-y-sincronizacion","title":"Retardos y sincronizaci\u00f3n","text":""},{"location":"upy/rapida/#temporizadores","title":"Temporizadores","text":""},{"location":"upy/rapida/#pines-y-gpio","title":"Pines y GPIO","text":""},{"location":"upy/rapida/#entradassalidas-programables-pio","title":"Entradas/Salidas programables (PIO)","text":""},{"location":"upy/rapida/#uart-bus-serie","title":"UART (bus serie)","text":""},{"location":"upy/rapida/#pwm","title":"PWM","text":""},{"location":"upy/rapida/#adc","title":"ADC","text":""},{"location":"upy/rapida/#bus-spi","title":"Bus SPI","text":""},{"location":"upy/rapida/#software","title":"Software","text":""},{"location":"upy/rapida/#hardware","title":"Hardware","text":""},{"location":"upy/rapida/#bus-i2c","title":"Bus I2C","text":""},{"location":"upy/ref_clases/","title":"Referencias a clases","text":""},{"location":"upy/ref_clases/#clase-machine","title":"Clase <code>machine</code>","text":""},{"location":"upy/ref_clases/#clase-time","title":"Clase <code>time</code>","text":""},{"location":"upy/ref_clases/#clase-pinid-mode-pull-value","title":"Clase <code>Pin(id, mode, pull, value)</code>","text":""}]}